[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.14.1","content-config-digest","1daf7be322ffbf2b","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"where\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":false,\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null,null,null,null,null,null,null],\"rehypePlugins\":[null,null,[null,{\"experimentalHeadingIdCompat\":false}],null,[null,{\"themes\":[{\"name\":\"Night Owl No Italics\",\"type\":\"dark\",\"colors\":{\"focusBorder\":\"#122d42\",\"foreground\":\"#d6deeb\",\"disabledForeground\":\"#cccccc80\",\"descriptionForeground\":\"#d6deebb3\",\"errorForeground\":\"#ef5350\",\"icon.foreground\":\"#c5c5c5\",\"contrastActiveBorder\":null,\"contrastBorder\":\"#122d42\",\"textBlockQuote.background\":\"#7f7f7f1a\",\"textBlockQuote.border\":\"#007acc80\",\"textCodeBlock.background\":\"#4f4f4f\",\"textLink.activeForeground\":\"#3794ff\",\"textLink.foreground\":\"#3794ff\",\"textPreformat.foreground\":\"#d7ba7d\",\"textSeparator.foreground\":\"#ffffff2e\",\"editor.background\":\"#23262f\",\"editor.foreground\":\"#d6deeb\",\"editorLineNumber.foreground\":\"#4b6479\",\"editorLineNumber.activeForeground\":\"#c5e4fd\",\"editorActiveLineNumber.foreground\":\"#c6c6c6\",\"editor.selectionBackground\":\"#1d3b53\",\"editor.inactiveSelectionBackground\":\"#7e57c25a\",\"editor.selectionHighlightBackground\":\"#5f7e9779\",\"editorError.foreground\":\"#ef5350\",\"editorWarning.foreground\":\"#b39554\",\"editorInfo.foreground\":\"#3794ff\",\"editorHint.foreground\":\"#eeeeeeb2\",\"problemsErrorIcon.foreground\":\"#ef5350\",\"problemsWarningIcon.foreground\":\"#b39554\",\"problemsInfoIcon.foreground\":\"#3794ff\",\"editor.findMatchBackground\":\"#5f7e9779\",\"editor.findMatchHighlightBackground\":\"#1085bb5d\",\"editor.findRangeHighlightBackground\":\"#3a3d4166\",\"editorLink.activeForeground\":\"#4e94ce\",\"editorLightBulb.foreground\":\"#ffcc00\",\"editorLightBulbAutoFix.foreground\":\"#75beff\",\"diffEditor.insertedTextBackground\":\"#99b76d23\",\"diffEditor.insertedTextBorder\":\"#c5e47833\",\"diffEditor.removedTextBackground\":\"#ef535033\",\"diffEditor.removedTextBorder\":\"#ef53504d\",\"diffEditor.insertedLineBackground\":\"#9bb95533\",\"diffEditor.removedLineBackground\":\"#ff000033\",\"editorStickyScroll.background\":\"#011627\",\"editorStickyScrollHover.background\":\"#2a2d2e\",\"editorInlayHint.background\":\"#5f7e97cc\",\"editorInlayHint.foreground\":\"#ffffff\",\"editorInlayHint.typeBackground\":\"#5f7e97cc\",\"editorInlayHint.typeForeground\":\"#ffffff\",\"editorInlayHint.parameterBackground\":\"#5f7e97cc\",\"editorInlayHint.parameterForeground\":\"#ffffff\",\"editorPane.background\":\"#011627\",\"editorGroup.emptyBackground\":\"#011627\",\"editorGroup.focusedEmptyBorder\":null,\"editorGroupHeader.tabsBackground\":\"var(--sl-color-black)\",\"editorGroupHeader.tabsBorder\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"editorGroupHeader.noTabsBackground\":\"#011627\",\"editorGroupHeader.border\":null,\"editorGroup.border\":\"#011627\",\"editorGroup.dropBackground\":\"#7e57c273\",\"editorGroup.dropIntoPromptForeground\":\"#d6deeb\",\"editorGroup.dropIntoPromptBackground\":\"#021320\",\"editorGroup.dropIntoPromptBorder\":null,\"sideBySideEditor.horizontalBorder\":\"#011627\",\"sideBySideEditor.verticalBorder\":\"#011627\",\"scrollbar.shadow\":\"#010b14\",\"scrollbarSlider.background\":\"#ffffff17\",\"scrollbarSlider.hoverBackground\":\"#ffffff40\",\"scrollbarSlider.activeBackground\":\"#084d8180\",\"panel.background\":\"#011627\",\"panel.border\":\"#5f7e97\",\"panelTitle.activeBorder\":\"#5f7e97\",\"panelTitle.activeForeground\":\"#ffffffcc\",\"panelTitle.inactiveForeground\":\"#d6deeb80\",\"panelSectionHeader.background\":\"#80808051\",\"terminal.background\":\"#011627\",\"widget.shadow\":\"#011627\",\"editorWidget.background\":\"#021320\",\"editorWidget.foreground\":\"#d6deeb\",\"editorWidget.border\":\"#5f7e97\",\"quickInput.background\":\"#021320\",\"quickInput.foreground\":\"#d6deeb\",\"quickInputTitle.background\":\"#ffffff1a\",\"pickerGroup.foreground\":\"#d1aaff\",\"pickerGroup.border\":\"#011627\",\"editor.hoverHighlightBackground\":\"#7e57c25a\",\"editorHoverWidget.background\":\"#011627\",\"editorHoverWidget.foreground\":\"#d6deeb\",\"editorHoverWidget.border\":\"#5f7e97\",\"editorHoverWidget.statusBarBackground\":\"#011a2f\",\"titleBar.activeBackground\":\"var(--sl-color-black)\",\"titleBar.activeForeground\":\"var(--sl-color-text)\",\"titleBar.inactiveBackground\":\"#010e1a\",\"titleBar.inactiveForeground\":\"#eeefff99\",\"titleBar.border\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"toolbar.hoverBackground\":\"#5a5d5e50\",\"toolbar.activeBackground\":\"#63666750\",\"tab.activeBackground\":\"#0b2942\",\"tab.unfocusedActiveBackground\":\"#0b2942\",\"tab.inactiveBackground\":\"#01111d\",\"tab.unfocusedInactiveBackground\":\"#01111d\",\"tab.activeForeground\":\"var(--sl-color-text)\",\"tab.inactiveForeground\":\"#5f7e97\",\"tab.unfocusedActiveForeground\":\"#5f7e97\",\"tab.unfocusedInactiveForeground\":\"#5f7e97\",\"tab.hoverBackground\":null,\"tab.unfocusedHoverBackground\":null,\"tab.hoverForeground\":null,\"tab.unfocusedHoverForeground\":null,\"tab.border\":\"#272b3b\",\"tab.lastPinnedBorder\":\"#585858\",\"tab.activeBorder\":\"transparent\",\"tab.unfocusedActiveBorder\":\"#262a39\",\"tab.activeBorderTop\":\"var(--sl-color-accent-high)\",\"tab.unfocusedActiveBorderTop\":null,\"tab.hoverBorder\":null,\"tab.unfocusedHoverBorder\":null,\"tab.activeModifiedBorder\":\"#3399cc\",\"tab.inactiveModifiedBorder\":\"#3399cc80\",\"tab.unfocusedActiveModifiedBorder\":\"#3399cc80\",\"tab.unfocusedInactiveModifiedBorder\":\"#3399cc40\",\"badge.background\":\"#5f7e97\",\"badge.foreground\":\"#ffffff\",\"button.background\":\"#7e57c2cc\",\"button.foreground\":\"#ffffffcc\",\"button.border\":\"#122d42\",\"button.separator\":\"#ffffff52\",\"button.hoverBackground\":\"#7e57c2\",\"button.secondaryBackground\":\"#3a3d41\",\"button.secondaryForeground\":\"#ffffff\",\"button.secondaryHoverBackground\":\"#46494e\",\"dropdown.background\":\"#011627\",\"dropdown.foreground\":\"#ffffffcc\",\"dropdown.border\":\"#5f7e97\",\"list.activeSelectionBackground\":\"#234d708c\",\"list.activeSelectionForeground\":\"#ffffff\",\"tree.indentGuidesStroke\":\"#585858\",\"input.background\":\"#0b253a\",\"input.foreground\":\"#ffffffcc\",\"input.placeholderForeground\":\"#5f7e97\",\"inputOption.activeBorder\":\"#ffffffcc\",\"inputOption.hoverBackground\":\"#5a5d5e80\",\"inputOption.activeBackground\":\"#122d4266\",\"inputOption.activeForeground\":\"#ffffff\",\"inputValidation.infoBackground\":\"#00589ef2\",\"inputValidation.infoBorder\":\"#64b5f6\",\"inputValidation.warningBackground\":\"#675700f2\",\"inputValidation.warningBorder\":\"#ffca28\",\"inputValidation.errorBackground\":\"#ab0300f2\",\"inputValidation.errorBorder\":\"#ef5350\",\"keybindingLabel.background\":\"#8080802b\",\"keybindingLabel.foreground\":\"#cccccc\",\"keybindingLabel.border\":\"#33333399\",\"keybindingLabel.bottomBorder\":\"#44444499\",\"menu.foreground\":\"#ffffffcc\",\"menu.background\":\"#011627\",\"menu.selectionForeground\":\"#ffffff\",\"menu.selectionBackground\":\"#234d708c\",\"menu.separatorBackground\":\"#606060\",\"editor.snippetTabstopHighlightBackground\":\"#7c7c74c\",\"editor.snippetFinalTabstopHighlightBorder\":\"#525252\",\"terminal.ansiBlack\":\"#011627\",\"terminal.ansiRed\":\"#ef5350\",\"terminal.ansiGreen\":\"#22da6e\",\"terminal.ansiYellow\":\"#c5e478\",\"terminal.ansiBlue\":\"#82aaff\",\"terminal.ansiMagenta\":\"#c792ea\",\"terminal.ansiCyan\":\"#21c7a8\",\"terminal.ansiWhite\":\"#ffffff\",\"terminal.ansiBrightBlack\":\"#575656\",\"terminal.ansiBrightRed\":\"#ef5350\",\"terminal.ansiBrightGreen\":\"#22da6e\",\"terminal.ansiBrightYellow\":\"#ffeb95\",\"terminal.ansiBrightBlue\":\"#82aaff\",\"terminal.ansiBrightMagenta\":\"#c792ea\",\"terminal.ansiBrightCyan\":\"#7fdbca\",\"terminal.ansiBrightWhite\":\"#ffffff\",\"selection.background\":\"#4373c2\",\"input.border\":\"#5f7e97\",\"punctuation.definition.generic.begin.html\":\"#ef5350f2\",\"progress.background\":\"#7e57c2\",\"breadcrumb.foreground\":\"#a599e9\",\"breadcrumb.focusForeground\":\"#ffffff\",\"breadcrumb.activeSelectionForeground\":\"#ffffff\",\"breadcrumbPicker.background\":\"#001122\",\"list.invalidItemForeground\":\"#975f94\",\"list.dropBackground\":\"#011627\",\"list.focusBackground\":\"#010d18\",\"list.focusForeground\":\"#ffffff\",\"list.highlightForeground\":\"#ffffff\",\"list.hoverBackground\":\"#011627\",\"list.hoverForeground\":\"#ffffff\",\"list.inactiveSelectionBackground\":\"#0e293f\",\"list.inactiveSelectionForeground\":\"#5f7e97\",\"activityBar.background\":\"#011627\",\"activityBar.dropBackground\":\"#5f7e97\",\"activityBar.foreground\":\"#5f7e97\",\"activityBar.border\":\"#011627\",\"activityBarBadge.background\":\"#44596b\",\"activityBarBadge.foreground\":\"#ffffff\",\"sideBar.background\":\"#011627\",\"sideBar.foreground\":\"#89a4bb\",\"sideBar.border\":\"#011627\",\"sideBarTitle.foreground\":\"#5f7e97\",\"sideBarSectionHeader.background\":\"#011627\",\"sideBarSectionHeader.foreground\":\"#5f7e97\",\"editorCursor.foreground\":\"#80a4c2\",\"editor.wordHighlightBackground\":\"#f6bbe533\",\"editor.wordHighlightStrongBackground\":\"#e2a2f433\",\"editor.lineHighlightBackground\":\"#0003\",\"editor.rangeHighlightBackground\":\"#7e57c25a\",\"editorIndentGuide.background\":\"#5e81ce52\",\"editorIndentGuide.activeBackground\":\"#7e97ac\",\"editorRuler.foreground\":\"#5e81ce52\",\"editorCodeLens.foreground\":\"#5e82ceb4\",\"editorBracketMatch.background\":\"#5f7e974d\",\"editorOverviewRuler.currentContentForeground\":\"#7e57c2\",\"editorOverviewRuler.incomingContentForeground\":\"#7e57c2\",\"editorOverviewRuler.commonContentForeground\":\"#7e57c2\",\"editorGutter.background\":\"#011627\",\"editorGutter.modifiedBackground\":\"#e2b93d\",\"editorGutter.addedBackground\":\"#9ccc65\",\"editorGutter.deletedBackground\":\"#ef5350\",\"editorSuggestWidget.background\":\"#2c3043\",\"editorSuggestWidget.border\":\"#2b2f40\",\"editorSuggestWidget.foreground\":\"#d6deeb\",\"editorSuggestWidget.highlightForeground\":\"#ffffff\",\"editorSuggestWidget.selectedBackground\":\"#5f7e97\",\"debugExceptionWidget.background\":\"#011627\",\"debugExceptionWidget.border\":\"#5f7e97\",\"editorMarkerNavigation.background\":\"#0b2942\",\"editorMarkerNavigationError.background\":\"#ef5350\",\"editorMarkerNavigationWarning.background\":\"#ffca28\",\"peekView.border\":\"#5f7e97\",\"peekViewEditor.background\":\"#011627\",\"peekViewEditor.matchHighlightBackground\":\"#7e57c25a\",\"peekViewResult.background\":\"#011627\",\"peekViewResult.fileForeground\":\"#5f7e97\",\"peekViewResult.lineForeground\":\"#5f7e97\",\"peekViewResult.matchHighlightBackground\":\"#ffffffcc\",\"peekViewResult.selectionBackground\":\"#2e3250\",\"peekViewResult.selectionForeground\":\"#5f7e97\",\"peekViewTitle.background\":\"#011627\",\"peekViewTitleDescription.foreground\":\"#697098\",\"peekViewTitleLabel.foreground\":\"#5f7e97\",\"merge.currentHeaderBackground\":\"#5f7e97\",\"merge.incomingHeaderBackground\":\"#7e57c25a\",\"statusBar.background\":\"#011627\",\"statusBar.foreground\":\"#5f7e97\",\"statusBar.border\":\"#262a39\",\"statusBar.debuggingBackground\":\"#202431\",\"statusBar.debuggingBorder\":\"#1f2330\",\"statusBar.noFolderBackground\":\"#011627\",\"statusBar.noFolderBorder\":\"#25293a\",\"statusBarItem.activeBackground\":\"#202431\",\"statusBarItem.hoverBackground\":\"#202431\",\"statusBarItem.prominentBackground\":\"#202431\",\"statusBarItem.prominentHoverBackground\":\"#202431\",\"notifications.background\":\"#01111d\",\"notifications.border\":\"#262a39\",\"notificationCenter.border\":\"#262a39\",\"notificationToast.border\":\"#262a39\",\"notifications.foreground\":\"#ffffffcc\",\"notificationLink.foreground\":\"#80cbc4\",\"extensionButton.prominentForeground\":\"#ffffffcc\",\"extensionButton.prominentBackground\":\"#7e57c2cc\",\"extensionButton.prominentHoverBackground\":\"#7e57c2\",\"terminal.selectionBackground\":\"#1b90dd4d\",\"terminalCursor.background\":\"#234d70\",\"debugToolBar.background\":\"#011627\",\"welcomePage.buttonBackground\":\"#011627\",\"welcomePage.buttonHoverBackground\":\"#011627\",\"walkThrough.embeddedEditorBackground\":\"#011627\",\"gitDecoration.modifiedResourceForeground\":\"#a2bffc\",\"gitDecoration.deletedResourceForeground\":\"#ef535090\",\"gitDecoration.untrackedResourceForeground\":\"#c5e478ff\",\"gitDecoration.ignoredResourceForeground\":\"#395a75\",\"gitDecoration.conflictingResourceForeground\":\"#ffeb95cc\",\"source.elm\":\"#5f7e97\",\"string.quoted.single.js\":\"#ffffff\",\"meta.objectliteral.js\":\"#82aaff\"},\"fg\":\"#d6deeb\",\"bg\":\"#23262f\",\"semanticHighlighting\":false,\"settings\":[{\"name\":\"Changed\",\"scope\":[\"markup.changed\",\"meta.diff.header.git\",\"meta.diff.header.from-file\",\"meta.diff.header.to-file\"],\"settings\":{\"foreground\":\"#a2bffc\"}},{\"name\":\"Deleted\",\"scope\":[\"markup.deleted.diff\"],\"settings\":{\"foreground\":\"#f27775fe\"}},{\"name\":\"Inserted\",\"scope\":[\"markup.inserted.diff\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Global settings\",\"settings\":{\"background\":\"#011627\",\"foreground\":\"#d6deeb\"}},{\"name\":\"Comment\",\"scope\":[\"comment\"],\"settings\":{\"foreground\":\"#919f9f\",\"fontStyle\":\"\"}},{\"name\":\"String\",\"scope\":[\"string\"],\"settings\":{\"foreground\":\"#ecc48d\"}},{\"name\":\"String Quoted\",\"scope\":[\"string.quoted\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#ecc48d\"}},{\"name\":\"Support Constant Math\",\"scope\":[\"support.constant.math\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Number\",\"scope\":[\"constant.numeric\",\"constant.character.numeric\"],\"settings\":{\"foreground\":\"#f78c6c\",\"fontStyle\":\"\"}},{\"name\":\"Built-in constant\",\"scope\":[\"constant.language\",\"punctuation.definition.constant\",\"variable.other.constant\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"User-defined constant\",\"scope\":[\"constant.character\",\"constant.other\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Constant Character Escape\",\"scope\":[\"constant.character.escape\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"RegExp String\",\"scope\":[\"string.regexp\",\"string.regexp keyword.other\"],\"settings\":{\"foreground\":\"#5ca7e4\"}},{\"name\":\"Comma in functions\",\"scope\":[\"meta.function punctuation.separator.comma\"],\"settings\":{\"foreground\":\"#889fb2\"}},{\"name\":\"Variable\",\"scope\":[\"variable\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Keyword\",\"scope\":[\"punctuation.accessor\",\"keyword\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Storage\",\"scope\":[\"storage\",\"meta.var.expr\",\"meta.class meta.method.declaration meta.var.expr storage.type.js\",\"storage.type.property.js\",\"storage.type.property.ts\",\"storage.type.property.tsx\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type.function.arrow.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Class name\",\"scope\":[\"entity.name.class\",\"meta.class entity.name.type.class\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Inherited class\",\"scope\":[\"entity.other.inherited-class\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Function name\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Meta Tag\",\"scope\":[\"punctuation.definition.tag\",\"meta.tag\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"HTML Tag names\",\"scope\":[\"entity.name.tag\",\"meta.tag.other.html\",\"meta.tag.other.js\",\"meta.tag.other.tsx\",\"entity.name.tag.tsx\",\"entity.name.tag.js\",\"entity.name.tag\",\"meta.tag.js\",\"meta.tag.tsx\",\"meta.tag.html\"],\"settings\":{\"foreground\":\"#caece6\",\"fontStyle\":\"\"}},{\"name\":\"Tag attribute\",\"scope\":[\"entity.other.attribute-name\"],\"settings\":{\"fontStyle\":\"\",\"foreground\":\"#c5e478\"}},{\"name\":\"Entity Name Tag Custom\",\"scope\":[\"entity.name.tag.custom\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Library (function & constant)\",\"scope\":[\"support.function\",\"support.constant\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Support Constant Property Value meta\",\"scope\":[\"support.constant.meta.property-value\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Library class/type\",\"scope\":[\"support.type\",\"support.class\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Support Variable DOM\",\"scope\":[\"support.variable.dom\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Invalid\",\"scope\":[\"invalid\"],\"settings\":{\"background\":\"#ff2c83\",\"foreground\":\"#ffffff\"}},{\"name\":\"Invalid deprecated\",\"scope\":[\"invalid.deprecated\"],\"settings\":{\"foreground\":\"#ffffff\",\"background\":\"#d3423e\"}},{\"name\":\"Keyword Operator\",\"scope\":[\"keyword.operator\"],\"settings\":{\"foreground\":\"#7fdbca\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Relational\",\"scope\":[\"keyword.operator.relational\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Assignment\",\"scope\":[\"keyword.operator.assignment\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Arithmetic\",\"scope\":[\"keyword.operator.arithmetic\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Bitwise\",\"scope\":[\"keyword.operator.bitwise\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Increment\",\"scope\":[\"keyword.operator.increment\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Ternary\",\"scope\":[\"keyword.operator.ternary\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Double-Slashed Comment\",\"scope\":[\"comment.line.double-slash\"],\"settings\":{\"foreground\":\"#919f9f\"}},{\"name\":\"Object\",\"scope\":[\"object\"],\"settings\":{\"foreground\":\"#cdebf7\"}},{\"name\":\"Null\",\"scope\":[\"constant.language.null\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Meta Brace\",\"scope\":[\"meta.brace\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Meta Delimiter Period\",\"scope\":[\"meta.delimiter.period\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Punctuation Definition String\",\"scope\":[\"punctuation.definition.string\"],\"settings\":{\"foreground\":\"#d9f5dd\"}},{\"name\":\"Punctuation Definition String Markdown\",\"scope\":[\"punctuation.definition.string.begin.markdown\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Boolean\",\"scope\":[\"constant.language.boolean\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Object Comma\",\"scope\":[\"object.comma\"],\"settings\":{\"foreground\":\"#ffffff\"}},{\"name\":\"Variable Parameter Function\",\"scope\":[\"variable.parameter.function\"],\"settings\":{\"foreground\":\"#7fdbca\",\"fontStyle\":\"\"}},{\"name\":\"Support Type Property Name & entity name tags\",\"scope\":[\"support.type.vendor.property-name\",\"support.constant.vendor.property-value\",\"support.type.property-name\",\"meta.property-list entity.name.tag\"],\"settings\":{\"foreground\":\"#80cbc4\",\"fontStyle\":\"\"}},{\"name\":\"Entity Name tag reference in stylesheets\",\"scope\":[\"meta.property-list entity.name.tag.reference\"],\"settings\":{\"foreground\":\"#57eaf1\"}},{\"name\":\"Constant Other Color RGB Value Punctuation Definition Constant\",\"scope\":[\"constant.other.color.rgb-value punctuation.definition.constant\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Constant Other Color\",\"scope\":[\"constant.other.color\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Keyword Other Unit\",\"scope\":[\"keyword.other.unit\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Meta Selector\",\"scope\":[\"meta.selector\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Entity Other Attribute Name Id\",\"scope\":[\"entity.other.attribute-name.id\"],\"settings\":{\"foreground\":\"#fad430\"}},{\"name\":\"Meta Property Name\",\"scope\":[\"meta.property-name\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"Doctypes\",\"scope\":[\"entity.name.tag.doctype\",\"meta.tag.sgml.doctype\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Punctuation Definition Parameters\",\"scope\":[\"punctuation.definition.parameters\"],\"settings\":{\"foreground\":\"#d9f5dd\"}},{\"name\":\"Keyword Control Operator\",\"scope\":[\"keyword.control.operator\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Keyword Operator Logical\",\"scope\":[\"keyword.operator.logical\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Variable Instances\",\"scope\":[\"variable.instance\",\"variable.other.instance\",\"variable.readwrite.instance\",\"variable.other.readwrite.instance\",\"variable.other.property\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Variable Property Other object property\",\"scope\":[\"variable.other.object.property\"],\"settings\":{\"foreground\":\"#faf39f\",\"fontStyle\":\"\"}},{\"name\":\"Variable Property Other object\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Entity Name Function\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#82aaff\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Comparison, returns, imports, and Keyword Operator Ruby\",\"scope\":[\"keyword.control.conditional.js\",\"keyword.operator.comparison\",\"keyword.control.flow.js\",\"keyword.control.flow.ts\",\"keyword.control.flow.tsx\",\"keyword.control.ruby\",\"keyword.control.def.ruby\",\"keyword.control.loop.js\",\"keyword.control.loop.ts\",\"keyword.control.import.js\",\"keyword.control.import.ts\",\"keyword.control.import.tsx\",\"keyword.control.from.js\",\"keyword.control.from.ts\",\"keyword.control.from.tsx\",\"keyword.control.conditional.js\",\"keyword.control.conditional.ts\",\"keyword.control.switch.js\",\"keyword.control.switch.ts\",\"keyword.operator.instanceof.js\",\"keyword.operator.expression.instanceof.ts\",\"keyword.operator.expression.instanceof.tsx\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Support Constant, `new` keyword, Special Method Keyword, `debugger`, other keywords\",\"scope\":[\"support.constant\",\"keyword.other.special-method\",\"keyword.other.new\",\"keyword.other.debugger\",\"keyword.control\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Support Function\",\"scope\":[\"support.function\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Invalid Broken\",\"scope\":[\"invalid.broken\"],\"settings\":{\"foreground\":\"#989da0\",\"background\":\"#F78C6C\"}},{\"name\":\"Invalid Unimplemented\",\"scope\":[\"invalid.unimplemented\"],\"settings\":{\"background\":\"#8BD649\",\"foreground\":\"#ffffff\"}},{\"name\":\"Invalid Illegal\",\"scope\":[\"invalid.illegal\"],\"settings\":{\"foreground\":\"#ffffff\",\"background\":\"#ec5f67\"}},{\"name\":\"Language Variable\",\"scope\":[\"variable.language\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Support Variable Property\",\"scope\":[\"support.variable.property\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Variable Function\",\"scope\":[\"variable.function\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Variable Interpolation\",\"scope\":[\"variable.interpolation\"],\"settings\":{\"foreground\":\"#ef787f\"}},{\"name\":\"Meta Function Call\",\"scope\":[\"meta.function-call\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Punctuation Section Embedded\",\"scope\":[\"punctuation.section.embedded\"],\"settings\":{\"foreground\":\"#e2817f\"}},{\"name\":\"Punctuation Tweaks\",\"scope\":[\"punctuation.terminator.expression\",\"punctuation.definition.arguments\",\"punctuation.definition.array\",\"punctuation.section.array\",\"meta.array\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"More Punctuation Tweaks\",\"scope\":[\"punctuation.definition.list.begin\",\"punctuation.definition.list.end\",\"punctuation.separator.arguments\",\"punctuation.definition.list\"],\"settings\":{\"foreground\":\"#d9f5dd\"}},{\"name\":\"Template Strings\",\"scope\":[\"string.template meta.template.expression\"],\"settings\":{\"foreground\":\"#e2817f\"}},{\"name\":\"Backtics(``) in Template Strings\",\"scope\":[\"string.template punctuation.definition.string\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Italics\",\"scope\":[\"italic\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"italic\"}},{\"name\":\"Bold\",\"scope\":[\"bold\"],\"settings\":{\"foreground\":\"#c5e478\",\"fontStyle\":\"bold\"}},{\"name\":\"Quote\",\"scope\":[\"quote\"],\"settings\":{\"foreground\":\"#969bb7\",\"fontStyle\":\"\"}},{\"name\":\"Raw Code\",\"scope\":[\"raw\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"CoffeScript Variable Assignment\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#31e1eb\"}},{\"name\":\"CoffeScript Parameter Function\",\"scope\":[\"variable.parameter.function.coffee\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"CoffeeScript Assignments\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"C# Readwrite Variables\",\"scope\":[\"variable.other.readwrite.cs\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"C# Classes & Storage types\",\"scope\":[\"entity.name.type.class.cs\",\"storage.type.cs\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"C# Namespaces\",\"scope\":[\"entity.name.type.namespace.cs\"],\"settings\":{\"foreground\":\"#b2ccd6\"}},{\"name\":\"C# Unquoted String Zone\",\"scope\":[\"string.unquoted.preprocessor.message.cs\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"C# Region\",\"scope\":[\"punctuation.separator.hash.cs\",\"keyword.preprocessor.region.cs\",\"keyword.preprocessor.endregion.cs\"],\"settings\":{\"foreground\":\"#ffcb8b\",\"fontStyle\":\"bold\"}},{\"name\":\"C# Other Variables\",\"scope\":[\"variable.other.object.cs\"],\"settings\":{\"foreground\":\"#b2ccd6\"}},{\"name\":\"C# Enum\",\"scope\":[\"entity.name.type.enum.cs\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Dart String\",\"scope\":[\"string.interpolated.single.dart\",\"string.interpolated.double.dart\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Dart Class\",\"scope\":[\"support.class.dart\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Tag names in Stylesheets\",\"scope\":[\"entity.name.tag.css\",\"entity.name.tag.less\",\"entity.name.tag.custom.css\",\"support.constant.property-value.css\"],\"settings\":{\"foreground\":\"#ff6d6d\",\"fontStyle\":\"\"}},{\"name\":\"Wildcard(*) selector in Stylesheets\",\"scope\":[\"entity.name.tag.wildcard.css\",\"entity.name.tag.wildcard.less\",\"entity.name.tag.wildcard.scss\",\"entity.name.tag.wildcard.sass\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"CSS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Attribute Name for CSS\",\"scope\":[\"meta.attribute-selector.css entity.other.attribute-name.attribute\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Elixir Classes\",\"scope\":[\"source.elixir support.type.elixir\",\"source.elixir meta.module.elixir entity.name.class.elixir\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Elixir Functions\",\"scope\":[\"source.elixir entity.name.function\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Elixir Constants\",\"scope\":[\"source.elixir constant.other.symbol.elixir\",\"source.elixir constant.other.keywords.elixir\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Elixir String Punctuations\",\"scope\":[\"source.elixir punctuation.definition.string\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Elixir\",\"scope\":[\"source.elixir variable.other.readwrite.module.elixir\",\"source.elixir variable.other.readwrite.module.elixir punctuation.definition.variable.elixir\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Elixir Binary Punctuations\",\"scope\":[\"source.elixir .punctuation.binary.elixir\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Closure Constant Keyword\",\"scope\":[\"constant.keyword.clojure\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Go Function Calls\",\"scope\":[\"source.go meta.function-call.go\"],\"settings\":{\"foreground\":\"#dddddd\"}},{\"name\":\"Go Keywords\",\"scope\":[\"source.go keyword.package.go\",\"source.go keyword.import.go\",\"source.go keyword.function.go\",\"source.go keyword.type.go\",\"source.go keyword.struct.go\",\"source.go keyword.interface.go\",\"source.go keyword.const.go\",\"source.go keyword.var.go\",\"source.go keyword.map.go\",\"source.go keyword.channel.go\",\"source.go keyword.control.go\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Go Constants e.g. nil, string format (%s, %d, etc.)\",\"scope\":[\"source.go constant.language.go\",\"source.go constant.other.placeholder.go\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"C++ Functions\",\"scope\":[\"entity.name.function.preprocessor.cpp\",\"entity.scope.name.cpp\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"C++ Meta Namespace\",\"scope\":[\"meta.namespace-block.cpp\"],\"settings\":{\"foreground\":\"#e0dec6\"}},{\"name\":\"C++ Language Primitive Storage\",\"scope\":[\"storage.type.language.primitive.cpp\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"C++ Preprocessor Macro\",\"scope\":[\"meta.preprocessor.macro.cpp\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"C++ Variable Parameter\",\"scope\":[\"variable.parameter\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Powershell Variables\",\"scope\":[\"variable.other.readwrite.powershell\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Powershell Function\",\"scope\":[\"support.function.powershell\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"ID Attribute Name in HTML\",\"scope\":[\"entity.other.attribute-name.id.html\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"HTML Punctuation Definition Tag\",\"scope\":[\"punctuation.definition.tag.html\"],\"settings\":{\"foreground\":\"#6ae9f0\"}},{\"name\":\"HTML Doctype\",\"scope\":[\"meta.tag.sgml.doctype.html\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"JavaScript Classes\",\"scope\":[\"meta.class entity.name.type.class.js\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"JavaScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.js\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"JavaScript Terminator\",\"scope\":[\"terminator.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Meta Punctuation Definition\",\"scope\":[\"meta.js punctuation.definition.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Entity Names in Code Documentations\",\"scope\":[\"entity.name.type.instance.jsdoc\",\"entity.name.type.instance.phpdoc\"],\"settings\":{\"foreground\":\"#889fb2\"}},{\"name\":\"Other Variables in Code Documentations\",\"scope\":[\"variable.other.jsdoc\",\"variable.other.phpdoc\"],\"settings\":{\"foreground\":\"#78ccf0\"}},{\"name\":\"JavaScript module imports and exports\",\"scope\":[\"variable.other.meta.import.js\",\"meta.import.js variable.other\",\"variable.other.meta.export.js\",\"meta.export.js variable.other\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Variable Parameter Function\",\"scope\":[\"variable.parameter.function.js\"],\"settings\":{\"foreground\":\"#8b96ea\"}},{\"name\":\"JavaScript[React] Variable Other Object\",\"scope\":[\"variable.other.object.js\",\"variable.other.object.jsx\",\"variable.object.property.js\",\"variable.object.property.jsx\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Variables\",\"scope\":[\"variable.js\",\"variable.other.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Entity Name Type\",\"scope\":[\"entity.name.type.js\",\"entity.name.type.module.js\"],\"settings\":{\"foreground\":\"#ffcb8b\",\"fontStyle\":\"\"}},{\"name\":\"JavaScript Support Classes\",\"scope\":[\"support.class.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JSON Property Names\",\"scope\":[\"support.type.property-name.json\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"JSON Support Constants\",\"scope\":[\"support.constant.json\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"JSON Property values (string)\",\"scope\":[\"meta.structure.dictionary.value.json string.quoted.double\"],\"settings\":{\"foreground\":\"#c789d6\"}},{\"name\":\"Strings in JSON values\",\"scope\":[\"string.quoted.double.json punctuation.definition.string.json\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"Specific JSON Property values like null\",\"scope\":[\"meta.structure.dictionary.json meta.structure.dictionary.value constant.language\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"JavaScript Other Variable\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Ruby Variables\",\"scope\":[\"variable.other.ruby\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Ruby Class\",\"scope\":[\"entity.name.type.class.ruby\"],\"settings\":{\"foreground\":\"#ecc48d\"}},{\"name\":\"Ruby Hashkeys\",\"scope\":[\"constant.language.symbol.hashkey.ruby\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"LESS Tag names\",\"scope\":[\"entity.name.tag.less\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"LESS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Attribute Name for LESS\",\"scope\":[\"meta.attribute-selector.less entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Markdown Headings\",\"scope\":[\"markup.heading.markdown\",\"markup.heading.setext.1.markdown\",\"markup.heading.setext.2.markdown\"],\"settings\":{\"foreground\":\"#82b1ff\"}},{\"name\":\"Markdown Italics\",\"scope\":[\"markup.italic.markdown\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"italic\"}},{\"name\":\"Markdown Bold\",\"scope\":[\"markup.bold.markdown\"],\"settings\":{\"foreground\":\"#c5e478\",\"fontStyle\":\"bold\"}},{\"name\":\"Markdown Quote + others\",\"scope\":[\"markup.quote.markdown\"],\"settings\":{\"foreground\":\"#969bb7\",\"fontStyle\":\"\"}},{\"name\":\"Markdown Raw Code + others\",\"scope\":[\"markup.inline.raw.markdown\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"Markdown Links\",\"scope\":[\"markup.underline.link.markdown\",\"markup.underline.link.image.markdown\"],\"settings\":{\"foreground\":\"#ff869a\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Link Title and Description\",\"scope\":[\"string.other.link.title.markdown\",\"string.other.link.description.markdown\"],\"settings\":{\"foreground\":\"#d6deeb\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Punctuation\",\"scope\":[\"punctuation.definition.string.markdown\",\"punctuation.definition.string.begin.markdown\",\"punctuation.definition.string.end.markdown\",\"meta.link.inline.markdown punctuation.definition.string\"],\"settings\":{\"foreground\":\"#82b1ff\"}},{\"name\":\"Markdown MetaData Punctuation\",\"scope\":[\"punctuation.definition.metadata.markdown\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Markdown List Punctuation\",\"scope\":[\"beginning.punctuation.definition.list.markdown\"],\"settings\":{\"foreground\":\"#82b1ff\"}},{\"name\":\"Markdown Inline Raw String\",\"scope\":[\"markup.inline.raw.string.markdown\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"PHP Variables\",\"scope\":[\"variable.other.php\"],\"settings\":{\"foreground\":\"#bec5d4\"}},{\"name\":\"Support Classes in PHP\",\"scope\":[\"support.class.php\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Punctuations in PHP function calls\",\"scope\":[\"meta.function-call.php punctuation\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"PHP Global Variables\",\"scope\":[\"variable.other.global.php\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Declaration Punctuation in PHP Global Variables\",\"scope\":[\"variable.other.global.php punctuation.definition.variable\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Language Constants in Python\",\"scope\":[\"constant.language.python\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Python Function Parameter and Arguments\",\"scope\":[\"variable.parameter.function.python\",\"meta.function-call.arguments.python\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Python Function Call\",\"scope\":[\"meta.function-call.python\",\"meta.function-call.generic.python\"],\"settings\":{\"foreground\":\"#b2ccd6\"}},{\"name\":\"Punctuations in Python\",\"scope\":[\"punctuation.python\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Decorator Functions in Python\",\"scope\":[\"entity.name.function.decorator.python\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Python Language Variable\",\"scope\":[\"source.python variable.language.special\"],\"settings\":{\"foreground\":\"#8eace3\"}},{\"name\":\"Python import control keyword\",\"scope\":[\"keyword.control\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"SCSS Variable\",\"scope\":[\"variable.scss\",\"variable.sass\",\"variable.parameter.url.scss\",\"variable.parameter.url.sass\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#bec5d4\"}},{\"name\":\"Attribute Name for SASS\",\"scope\":[\"meta.attribute-selector.scss entity.other.attribute-name.attribute\",\"meta.attribute-selector.sass entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Tag names in SASS\",\"scope\":[\"entity.name.tag.scss\",\"entity.name.tag.sass\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"SASS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.scss\",\"keyword.other.unit.sass\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"TypeScript[React] Variables and Object Properties\",\"scope\":[\"variable.other.readwrite.alias.ts\",\"variable.other.readwrite.alias.tsx\",\"variable.other.readwrite.ts\",\"variable.other.readwrite.tsx\",\"variable.other.object.ts\",\"variable.other.object.tsx\",\"variable.object.property.ts\",\"variable.object.property.tsx\",\"variable.other.ts\",\"variable.other.tsx\",\"variable.tsx\",\"variable.ts\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"TypeScript[React] Entity Name Types\",\"scope\":[\"entity.name.type.ts\",\"entity.name.type.tsx\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"TypeScript[React] Node Classes\",\"scope\":[\"support.class.node.ts\",\"support.class.node.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"TypeScript[React] Entity Name Types as Parameters\",\"scope\":[\"meta.type.parameters.ts entity.name.type\",\"meta.type.parameters.tsx entity.name.type\"],\"settings\":{\"foreground\":\"#889fb2\"}},{\"name\":\"TypeScript[React] Import/Export Punctuations\",\"scope\":[\"meta.import.ts punctuation.definition.block\",\"meta.import.tsx punctuation.definition.block\",\"meta.export.ts punctuation.definition.block\",\"meta.export.tsx punctuation.definition.block\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.decorator punctuation.decorator.ts\",\"meta.decorator punctuation.decorator.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.tag.js meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"YAML Entity Name Tags\",\"scope\":[\"entity.name.tag.yaml\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"JavaScript Variable Other ReadWrite\",\"scope\":[\"variable.other.readwrite.js\",\"variable.parameter\"],\"settings\":{\"foreground\":\"#d7dbe0\"}},{\"name\":\"Support Class Component\",\"scope\":[\"support.class.component.js\",\"support.class.component.tsx\"],\"settings\":{\"foreground\":\"#f78c6c\",\"fontStyle\":\"\"}},{\"name\":\"Text nested in React tags\",\"scope\":[\"meta.jsx.children\",\"meta.jsx.children.js\",\"meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"TypeScript Classes\",\"scope\":[\"meta.class entity.name.type.class.tsx\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"TypeScript Entity Name Type\",\"scope\":[\"entity.name.type.tsx\",\"entity.name.type.module.tsx\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"TypeScript Class Variable Keyword\",\"scope\":[\"meta.class.ts meta.var.expr.ts storage.type.ts\",\"meta.class.tsx meta.var.expr.tsx storage.type.tsx\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"TypeScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.ts\",\"meta.method.declaration storage.type.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"normalize font style of certain components\",\"scope\":[\"meta.property-list.css meta.property-value.css variable.other.less\",\"meta.property-list.scss variable.scss\",\"meta.property-list.sass variable.sass\",\"meta.brace\",\"keyword.operator.operator\",\"keyword.operator.or.regexp\",\"keyword.operator.expression.in\",\"keyword.operator.relational\",\"keyword.operator.assignment\",\"keyword.operator.comparison\",\"keyword.operator.type\",\"keyword.operator\",\"keyword\",\"punctuation.definintion.string\",\"punctuation\",\"variable.other.readwrite.js\",\"storage.type\",\"source.css\",\"string.quoted\"],\"settings\":{\"fontStyle\":\"\"}}],\"styleOverrides\":{\"frames\":{\"editorBackground\":\"var(--sl-color-gray-6)\",\"terminalBackground\":\"var(--sl-color-gray-6)\",\"editorActiveTabBackground\":\"var(--sl-color-gray-6)\",\"terminalTitlebarDotsForeground\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"terminalTitlebarDotsOpacity\":\"0.75\",\"inlineButtonForeground\":\"var(--sl-color-text)\",\"frameBoxShadowCssValue\":\"none\"},\"textMarkers\":{\"markBackground\":\"#ffffff17\",\"markBorderColor\":\"#ffffff40\"}}},{\"name\":\"Night Owl Light\",\"type\":\"light\",\"colors\":{\"focusBorder\":\"#93a1a1\",\"foreground\":\"#403f53\",\"disabledForeground\":\"#61616180\",\"descriptionForeground\":\"#403f53\",\"errorForeground\":\"#403f53\",\"icon.foreground\":\"#424242\",\"contrastActiveBorder\":null,\"contrastBorder\":null,\"textBlockQuote.background\":\"#7f7f7f1a\",\"textBlockQuote.border\":\"#007acc80\",\"textCodeBlock.background\":\"#dcdcdc66\",\"textLink.activeForeground\":\"#006ab1\",\"textLink.foreground\":\"#006ab1\",\"textPreformat.foreground\":\"#a31515\",\"textSeparator.foreground\":\"#0000002e\",\"editor.background\":\"#f6f7f9\",\"editor.foreground\":\"#403f53\",\"editorLineNumber.foreground\":\"#90a7b2\",\"editorLineNumber.activeForeground\":\"#403f53\",\"editorActiveLineNumber.foreground\":\"#0b216f\",\"editor.selectionBackground\":\"#e0e0e0\",\"editor.inactiveSelectionBackground\":\"#e0e0e080\",\"editor.selectionHighlightBackground\":\"#339cec33\",\"editorError.foreground\":\"#e64d49\",\"editorWarning.foreground\":\"#daaa01\",\"editorInfo.foreground\":\"#1a85ff\",\"editorHint.foreground\":\"#6c6c6c\",\"problemsErrorIcon.foreground\":\"#e64d49\",\"problemsWarningIcon.foreground\":\"#daaa01\",\"problemsInfoIcon.foreground\":\"#1a85ff\",\"editor.findMatchBackground\":\"#93a1a16c\",\"editor.findMatchHighlightBackground\":\"#93a1a16c\",\"editor.findRangeHighlightBackground\":\"#7497a633\",\"editorLink.activeForeground\":\"#0000ff\",\"editorLightBulb.foreground\":\"#ddb100\",\"editorLightBulbAutoFix.foreground\":\"#007acc\",\"diffEditor.insertedTextBackground\":\"#9ccc2c40\",\"diffEditor.insertedTextBorder\":null,\"diffEditor.removedTextBackground\":\"#ff000033\",\"diffEditor.removedTextBorder\":null,\"diffEditor.insertedLineBackground\":\"#9bb95533\",\"diffEditor.removedLineBackground\":\"#ff000033\",\"editorStickyScroll.background\":\"#fbfbfb\",\"editorStickyScrollHover.background\":\"#f0f0f0\",\"editorInlayHint.background\":\"#2aa29899\",\"editorInlayHint.foreground\":\"#f0f0f0\",\"editorInlayHint.typeBackground\":\"#2aa29899\",\"editorInlayHint.typeForeground\":\"#f0f0f0\",\"editorInlayHint.parameterBackground\":\"#2aa29899\",\"editorInlayHint.parameterForeground\":\"#f0f0f0\",\"editorPane.background\":\"#fbfbfb\",\"editorGroup.emptyBackground\":null,\"editorGroup.focusedEmptyBorder\":null,\"editorGroupHeader.tabsBackground\":\"var(--sl-color-gray-6)\",\"editorGroupHeader.tabsBorder\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"editorGroupHeader.noTabsBackground\":\"#f0f0f0\",\"editorGroupHeader.border\":null,\"editorGroup.border\":\"#f0f0f0\",\"editorGroup.dropBackground\":\"#2677cb2d\",\"editorGroup.dropIntoPromptForeground\":\"#403f53\",\"editorGroup.dropIntoPromptBackground\":\"#f0f0f0\",\"editorGroup.dropIntoPromptBorder\":null,\"sideBySideEditor.horizontalBorder\":\"#f0f0f0\",\"sideBySideEditor.verticalBorder\":\"#f0f0f0\",\"scrollbar.shadow\":\"#cccccc\",\"scrollbarSlider.background\":\"#0000001a\",\"scrollbarSlider.hoverBackground\":\"#00000055\",\"scrollbarSlider.activeBackground\":\"#00000099\",\"panel.background\":\"#f0f0f0\",\"panel.border\":\"#d9d9d9\",\"panelTitle.activeBorder\":\"#424242\",\"panelTitle.activeForeground\":\"#424242\",\"panelTitle.inactiveForeground\":\"#424242bf\",\"panelSectionHeader.background\":\"#80808051\",\"terminal.background\":\"#f6f6f6\",\"widget.shadow\":\"#d9d9d9\",\"editorWidget.background\":\"#f0f0f0\",\"editorWidget.foreground\":\"#403f53\",\"editorWidget.border\":\"#d9d9d9\",\"quickInput.background\":\"#f0f0f0\",\"quickInput.foreground\":\"#403f53\",\"quickInputTitle.background\":\"#0000000f\",\"pickerGroup.foreground\":\"#403f53\",\"pickerGroup.border\":\"#d9d9d9\",\"editor.hoverHighlightBackground\":\"#339cec33\",\"editorHoverWidget.background\":\"#f0f0f0\",\"editorHoverWidget.foreground\":\"#403f53\",\"editorHoverWidget.border\":\"#d9d9d9\",\"editorHoverWidget.statusBarBackground\":\"#e4e4e4\",\"titleBar.activeBackground\":\"var(--sl-color-gray-6)\",\"titleBar.activeForeground\":\"var(--sl-color-text)\",\"titleBar.inactiveBackground\":\"#f0f0f099\",\"titleBar.inactiveForeground\":\"#33333399\",\"titleBar.border\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"toolbar.hoverBackground\":\"#b8b8b850\",\"toolbar.activeBackground\":\"#a6a6a650\",\"tab.activeBackground\":\"#f6f6f6\",\"tab.unfocusedActiveBackground\":\"#f6f6f6\",\"tab.inactiveBackground\":\"#f0f0f0\",\"tab.unfocusedInactiveBackground\":\"#f0f0f0\",\"tab.activeForeground\":\"var(--sl-color-text)\",\"tab.inactiveForeground\":\"#403f53\",\"tab.unfocusedActiveForeground\":\"#403f53b3\",\"tab.unfocusedInactiveForeground\":\"#403f5380\",\"tab.hoverBackground\":null,\"tab.unfocusedHoverBackground\":null,\"tab.hoverForeground\":null,\"tab.unfocusedHoverForeground\":null,\"tab.border\":\"#f0f0f0\",\"tab.lastPinnedBorder\":\"#a9a9a9\",\"tab.activeBorder\":\"transparent\",\"tab.unfocusedActiveBorder\":null,\"tab.activeBorderTop\":\"var(--sl-color-accent)\",\"tab.unfocusedActiveBorderTop\":null,\"tab.hoverBorder\":null,\"tab.unfocusedHoverBorder\":null,\"tab.activeModifiedBorder\":\"#2aa298\",\"tab.inactiveModifiedBorder\":\"#93a1a1\",\"tab.unfocusedActiveModifiedBorder\":\"#93a1a1\",\"tab.unfocusedInactiveModifiedBorder\":\"#93a1a1\",\"badge.background\":\"#2aa298\",\"badge.foreground\":\"#f0f0f0\",\"button.background\":\"#2aa298\",\"button.foreground\":\"#f0f0f0\",\"button.border\":null,\"button.separator\":\"#f0f0f066\",\"button.hoverBackground\":\"#22827a\",\"button.secondaryBackground\":\"#5f6a79\",\"button.secondaryForeground\":\"#ffffff\",\"button.secondaryHoverBackground\":\"#4c5561\",\"dropdown.background\":\"#f0f0f0\",\"dropdown.foreground\":\"#403f53\",\"dropdown.border\":\"#d9d9d9\",\"list.activeSelectionBackground\":\"#d3e8f8\",\"list.activeSelectionForeground\":\"#403f53\",\"tree.indentGuidesStroke\":\"#a9a9a9\",\"input.background\":\"#f0f0f0\",\"input.foreground\":\"#403f53\",\"input.placeholderForeground\":\"#93a1a1\",\"inputOption.activeBorder\":\"#2aa298\",\"inputOption.hoverBackground\":\"#b8b8b850\",\"inputOption.activeBackground\":\"#93a1a133\",\"inputOption.activeForeground\":\"#000000\",\"inputValidation.infoBackground\":\"#f0f0f0\",\"inputValidation.infoBorder\":\"#d0d0d0\",\"inputValidation.warningBackground\":\"#daaa01\",\"inputValidation.warningBorder\":\"#e0af02\",\"inputValidation.errorBackground\":\"#f76e6e\",\"inputValidation.errorBorder\":\"#de3d3b\",\"keybindingLabel.background\":\"#dddddd66\",\"keybindingLabel.foreground\":\"#555555\",\"keybindingLabel.border\":\"#cccccc66\",\"keybindingLabel.bottomBorder\":\"#bbbbbb66\",\"menu.foreground\":\"#403f53\",\"menu.background\":\"#f0f0f0\",\"menu.selectionForeground\":\"#403f53\",\"menu.selectionBackground\":\"#d3e8f8\",\"menu.separatorBackground\":\"#d4d4d4\",\"editor.snippetTabstopHighlightBackground\":\"#0a326433\",\"editor.snippetFinalTabstopHighlightBorder\":\"#0a326480\",\"terminal.ansiBlack\":\"#403f53\",\"terminal.ansiRed\":\"#de3d3b\",\"terminal.ansiGreen\":\"#08916a\",\"terminal.ansiYellow\":\"#e0af02\",\"terminal.ansiBlue\":\"#288ed7\",\"terminal.ansiMagenta\":\"#d6438a\",\"terminal.ansiCyan\":\"#2aa298\",\"terminal.ansiWhite\":\"#f0f0f0\",\"terminal.ansiBrightBlack\":\"#403f53\",\"terminal.ansiBrightRed\":\"#de3d3b\",\"terminal.ansiBrightGreen\":\"#08916a\",\"terminal.ansiBrightYellow\":\"#daaa01\",\"terminal.ansiBrightBlue\":\"#288ed7\",\"terminal.ansiBrightMagenta\":\"#d6438a\",\"terminal.ansiBrightCyan\":\"#2aa298\",\"terminal.ansiBrightWhite\":\"#f0f0f0\",\"selection.background\":\"#7a8181ad\",\"notifications.background\":\"#f0f0f0\",\"notifications.foreground\":\"#403f53\",\"notificationLink.foreground\":\"#994cc3\",\"notifications.border\":\"#cccccc\",\"notificationCenter.border\":\"#cccccc\",\"notificationToast.border\":\"#cccccc\",\"notificationCenterHeader.foreground\":\"#403f53\",\"notificationCenterHeader.background\":\"#f0f0f0\",\"input.border\":\"#d9d9d9\",\"progressBar.background\":\"#2aa298\",\"list.inactiveSelectionBackground\":\"#e0e7ea\",\"list.inactiveSelectionForeground\":\"#403f53\",\"list.focusBackground\":\"#d3e8f8\",\"list.hoverBackground\":\"#d3e8f8\",\"list.focusForeground\":\"#403f53\",\"list.hoverForeground\":\"#403f53\",\"list.highlightForeground\":\"#403f53\",\"list.errorForeground\":\"#e64d49\",\"list.warningForeground\":\"#daaa01\",\"activityBar.background\":\"#f0f0f0\",\"activityBar.foreground\":\"#403f53\",\"activityBar.dropBackground\":\"#d0d0d0\",\"activityBarBadge.background\":\"#403f53\",\"activityBarBadge.foreground\":\"#f0f0f0\",\"activityBar.border\":\"#f0f0f0\",\"sideBar.background\":\"#f0f0f0\",\"sideBar.foreground\":\"#403f53\",\"sideBarTitle.foreground\":\"#403f53\",\"sideBar.border\":\"#f0f0f0\",\"editorGroup.background\":\"#f6f6f6\",\"editorCursor.foreground\":\"#90a7b2\",\"editor.wordHighlightBackground\":\"#339cec33\",\"editor.wordHighlightStrongBackground\":\"#007dd659\",\"editor.lineHighlightBackground\":\"#f0f0f0\",\"editor.rangeHighlightBackground\":\"#7497a633\",\"editorWhitespace.foreground\":\"#d9d9d9\",\"editorIndentGuide.background\":\"#d9d9d9\",\"editorCodeLens.foreground\":\"#403f53\",\"editorBracketMatch.background\":\"#d3e8f8\",\"editorBracketMatch.border\":\"#2aa298\",\"editorError.border\":\"#fbfbfb\",\"editorWarning.border\":\"#daaa01\",\"editorGutter.addedBackground\":\"#49d0c5\",\"editorGutter.modifiedBackground\":\"#6fbef6\",\"editorGutter.deletedBackground\":\"#f76e6e\",\"editorRuler.foreground\":\"#d9d9d9\",\"editorOverviewRuler.errorForeground\":\"#e64d49\",\"editorOverviewRuler.warningForeground\":\"#daaa01\",\"editorSuggestWidget.background\":\"#f0f0f0\",\"editorSuggestWidget.foreground\":\"#403f53\",\"editorSuggestWidget.highlightForeground\":\"#403f53\",\"editorSuggestWidget.selectedBackground\":\"#d3e8f8\",\"editorSuggestWidget.border\":\"#d9d9d9\",\"debugExceptionWidget.background\":\"#f0f0f0\",\"debugExceptionWidget.border\":\"#d9d9d9\",\"editorMarkerNavigation.background\":\"#d0d0d0\",\"editorMarkerNavigationError.background\":\"#f76e6e\",\"editorMarkerNavigationWarning.background\":\"#daaa01\",\"debugToolBar.background\":\"#f0f0f0\",\"extensionButton.prominentBackground\":\"#2aa298\",\"extensionButton.prominentForeground\":\"#f0f0f0\",\"statusBar.background\":\"#f0f0f0\",\"statusBar.border\":\"#f0f0f0\",\"statusBar.debuggingBackground\":\"#f0f0f0\",\"statusBar.debuggingForeground\":\"#403f53\",\"statusBar.foreground\":\"#403f53\",\"statusBar.noFolderBackground\":\"#f0f0f0\",\"statusBar.noFolderForeground\":\"#403f53\",\"peekView.border\":\"#d9d9d9\",\"peekViewEditor.background\":\"#f6f6f6\",\"peekViewEditorGutter.background\":\"#f6f6f6\",\"peekViewEditor.matchHighlightBackground\":\"#49d0c5\",\"peekViewResult.background\":\"#f0f0f0\",\"peekViewResult.fileForeground\":\"#403f53\",\"peekViewResult.lineForeground\":\"#403f53\",\"peekViewResult.matchHighlightBackground\":\"#49d0c5\",\"peekViewResult.selectionBackground\":\"#e0e7ea\",\"peekViewResult.selectionForeground\":\"#403f53\",\"peekViewTitle.background\":\"#f0f0f0\",\"peekViewTitleLabel.foreground\":\"#403f53\",\"peekViewTitleDescription.foreground\":\"#403f53\",\"terminal.foreground\":\"#403f53\"},\"fg\":\"#403f53\",\"bg\":\"#f6f7f9\",\"semanticHighlighting\":false,\"settings\":[{\"name\":\"Changed\",\"scope\":[\"markup.changed\",\"meta.diff.header.git\",\"meta.diff.header.from-file\",\"meta.diff.header.to-file\"],\"settings\":{\"foreground\":\"#556484\"}},{\"name\":\"Deleted\",\"scope\":[\"markup.deleted.diff\"],\"settings\":{\"foreground\":\"#ae3c3afd\"}},{\"name\":\"Inserted\",\"scope\":[\"markup.inserted.diff\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Global settings\",\"settings\":{\"background\":\"#011627\",\"foreground\":\"#403f53\"}},{\"name\":\"Comment\",\"scope\":[\"comment\"],\"settings\":{\"foreground\":\"#5f636f\"}},{\"name\":\"String\",\"scope\":[\"string\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"String Quoted\",\"scope\":[\"string.quoted\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#984e4d\"}},{\"name\":\"Support Constant Math\",\"scope\":[\"support.constant.math\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Number\",\"scope\":[\"constant.numeric\",\"constant.character.numeric\"],\"settings\":{\"foreground\":\"#aa0982\",\"fontStyle\":\"\"}},{\"name\":\"Built-in constant\",\"scope\":[\"constant.language\",\"punctuation.definition.constant\",\"variable.other.constant\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"User-defined constant\",\"scope\":[\"constant.character\",\"constant.other\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Constant Character Escape\",\"scope\":[\"constant.character.escape\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"RegExp String\",\"scope\":[\"string.regexp\",\"string.regexp keyword.other\"],\"settings\":{\"foreground\":\"#3a688f\"}},{\"name\":\"Comma in functions\",\"scope\":[\"meta.function punctuation.separator.comma\"],\"settings\":{\"foreground\":\"#4d667b\"}},{\"name\":\"Variable\",\"scope\":[\"variable\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Keyword\",\"scope\":[\"punctuation.accessor\",\"keyword\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Storage\",\"scope\":[\"storage\",\"meta.var.expr\",\"meta.class meta.method.declaration meta.var.expr storage.type.js\",\"storage.type.property.js\",\"storage.type.property.ts\",\"storage.type.property.tsx\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type.function.arrow.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Class name\",\"scope\":[\"entity.name.class\",\"meta.class entity.name.type.class\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Inherited class\",\"scope\":[\"entity.other.inherited-class\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Function name\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Meta Tag\",\"scope\":[\"punctuation.definition.tag\",\"meta.tag\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"HTML Tag names\",\"scope\":[\"entity.name.tag\",\"meta.tag.other.html\",\"meta.tag.other.js\",\"meta.tag.other.tsx\",\"entity.name.tag.tsx\",\"entity.name.tag.js\",\"entity.name.tag\",\"meta.tag.js\",\"meta.tag.tsx\",\"meta.tag.html\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Tag attribute\",\"scope\":[\"entity.other.attribute-name\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Entity Name Tag Custom\",\"scope\":[\"entity.name.tag.custom\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Library (function & constant)\",\"scope\":[\"support.function\",\"support.constant\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Support Constant Property Value meta\",\"scope\":[\"support.constant.meta.property-value\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Library class/type\",\"scope\":[\"support.type\",\"support.class\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Support Variable DOM\",\"scope\":[\"support.variable.dom\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Invalid\",\"scope\":[\"invalid\"],\"settings\":{\"foreground\":\"#bb2060\"}},{\"name\":\"Invalid deprecated\",\"scope\":[\"invalid.deprecated\"],\"settings\":{\"foreground\":\"#b23834\"}},{\"name\":\"Keyword Operator\",\"scope\":[\"keyword.operator\"],\"settings\":{\"foreground\":\"#096e72\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Relational\",\"scope\":[\"keyword.operator.relational\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Assignment\",\"scope\":[\"keyword.operator.assignment\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Arithmetic\",\"scope\":[\"keyword.operator.arithmetic\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Bitwise\",\"scope\":[\"keyword.operator.bitwise\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Increment\",\"scope\":[\"keyword.operator.increment\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Ternary\",\"scope\":[\"keyword.operator.ternary\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Double-Slashed Comment\",\"scope\":[\"comment.line.double-slash\"],\"settings\":{\"foreground\":\"#5d6376\"}},{\"name\":\"Object\",\"scope\":[\"object\"],\"settings\":{\"foreground\":\"#58656a\"}},{\"name\":\"Null\",\"scope\":[\"constant.language.null\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Meta Brace\",\"scope\":[\"meta.brace\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Meta Delimiter Period\",\"scope\":[\"meta.delimiter.period\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Punctuation Definition String\",\"scope\":[\"punctuation.definition.string\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Punctuation Definition String Markdown\",\"scope\":[\"punctuation.definition.string.begin.markdown\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Boolean\",\"scope\":[\"constant.language.boolean\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Object Comma\",\"scope\":[\"object.comma\"],\"settings\":{\"foreground\":\"#646464\"}},{\"name\":\"Variable Parameter Function\",\"scope\":[\"variable.parameter.function\"],\"settings\":{\"foreground\":\"#096e72\",\"fontStyle\":\"\"}},{\"name\":\"Support Type Property Name & entity name tags\",\"scope\":[\"support.type.vendor.property-name\",\"support.constant.vendor.property-value\",\"support.type.property-name\",\"meta.property-list entity.name.tag\"],\"settings\":{\"foreground\":\"#096e72\",\"fontStyle\":\"\"}},{\"name\":\"Entity Name tag reference in stylesheets\",\"scope\":[\"meta.property-list entity.name.tag.reference\"],\"settings\":{\"foreground\":\"#286d70\"}},{\"name\":\"Constant Other Color RGB Value Punctuation Definition Constant\",\"scope\":[\"constant.other.color.rgb-value punctuation.definition.constant\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Constant Other Color\",\"scope\":[\"constant.other.color\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Keyword Other Unit\",\"scope\":[\"keyword.other.unit\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Meta Selector\",\"scope\":[\"meta.selector\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Entity Other Attribute Name Id\",\"scope\":[\"entity.other.attribute-name.id\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Meta Property Name\",\"scope\":[\"meta.property-name\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Doctypes\",\"scope\":[\"entity.name.tag.doctype\",\"meta.tag.sgml.doctype\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Punctuation Definition Parameters\",\"scope\":[\"punctuation.definition.parameters\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Keyword Control Operator\",\"scope\":[\"keyword.control.operator\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Keyword Operator Logical\",\"scope\":[\"keyword.operator.logical\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"\"}},{\"name\":\"Variable Instances\",\"scope\":[\"variable.instance\",\"variable.other.instance\",\"variable.readwrite.instance\",\"variable.other.readwrite.instance\",\"variable.other.property\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Variable Property Other object property\",\"scope\":[\"variable.other.object.property\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Variable Property Other object\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Entity Name Function\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Keyword Operator Comparison, imports, returns and Keyword Operator Ruby\",\"scope\":[\"keyword.operator.comparison\",\"keyword.control.flow.js\",\"keyword.control.flow.ts\",\"keyword.control.flow.tsx\",\"keyword.control.ruby\",\"keyword.control.module.ruby\",\"keyword.control.class.ruby\",\"keyword.control.def.ruby\",\"keyword.control.loop.js\",\"keyword.control.loop.ts\",\"keyword.control.import.js\",\"keyword.control.import.ts\",\"keyword.control.import.tsx\",\"keyword.control.from.js\",\"keyword.control.from.ts\",\"keyword.control.from.tsx\",\"keyword.operator.instanceof.js\",\"keyword.operator.expression.instanceof.ts\",\"keyword.operator.expression.instanceof.tsx\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Control Conditional\",\"scope\":[\"keyword.control.conditional.js\",\"keyword.control.conditional.ts\",\"keyword.control.switch.js\",\"keyword.control.switch.ts\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"\"}},{\"name\":\"Support Constant, `new` keyword, Special Method Keyword, `debugger`, other keywords\",\"scope\":[\"support.constant\",\"keyword.other.special-method\",\"keyword.other.new\",\"keyword.other.debugger\",\"keyword.control\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Support Function\",\"scope\":[\"support.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Invalid Broken\",\"scope\":[\"invalid.broken\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Invalid Unimplemented\",\"scope\":[\"invalid.unimplemented\"],\"settings\":{\"foreground\":\"#486e26\"}},{\"name\":\"Invalid Illegal\",\"scope\":[\"invalid.illegal\"],\"settings\":{\"foreground\":\"#984e4d\"}},{\"name\":\"Language Variable\",\"scope\":[\"variable.language\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Support Variable Property\",\"scope\":[\"support.variable.property\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Variable Function\",\"scope\":[\"variable.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Variable Interpolation\",\"scope\":[\"variable.interpolation\"],\"settings\":{\"foreground\":\"#a64348\"}},{\"name\":\"Meta Function Call\",\"scope\":[\"meta.function-call\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Punctuation Section Embedded\",\"scope\":[\"punctuation.section.embedded\"],\"settings\":{\"foreground\":\"#b23834\"}},{\"name\":\"Punctuation Tweaks\",\"scope\":[\"punctuation.terminator.expression\",\"punctuation.definition.arguments\",\"punctuation.definition.array\",\"punctuation.section.array\",\"meta.array\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"More Punctuation Tweaks\",\"scope\":[\"punctuation.definition.list.begin\",\"punctuation.definition.list.end\",\"punctuation.separator.arguments\",\"punctuation.definition.list\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Template Strings\",\"scope\":[\"string.template meta.template.expression\"],\"settings\":{\"foreground\":\"#b23834\"}},{\"name\":\"Backtics(``) in Template Strings\",\"scope\":[\"string.template punctuation.definition.string\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Italics\",\"scope\":[\"italic\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"italic\"}},{\"name\":\"Bold\",\"scope\":[\"bold\"],\"settings\":{\"foreground\":\"#3b61b0\",\"fontStyle\":\"bold\"}},{\"name\":\"Quote\",\"scope\":[\"quote\"],\"settings\":{\"foreground\":\"#5c6285\"}},{\"name\":\"Raw Code\",\"scope\":[\"raw\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"CoffeScript Variable Assignment\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#186e73\"}},{\"name\":\"CoffeScript Parameter Function\",\"scope\":[\"variable.parameter.function.coffee\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"CoffeeScript Assignments\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"C# Readwrite Variables\",\"scope\":[\"variable.other.readwrite.cs\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"C# Classes & Storage types\",\"scope\":[\"entity.name.type.class.cs\",\"storage.type.cs\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"C# Namespaces\",\"scope\":[\"entity.name.type.namespace.cs\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Tag names in Stylesheets\",\"scope\":[\"entity.name.tag.css\",\"entity.name.tag.less\",\"entity.name.tag.custom.css\",\"support.constant.property-value.css\"],\"settings\":{\"foreground\":\"#984e4d\",\"fontStyle\":\"\"}},{\"name\":\"Wildcard(*) selector in Stylesheets\",\"scope\":[\"entity.name.tag.wildcard.css\",\"entity.name.tag.wildcard.less\",\"entity.name.tag.wildcard.scss\",\"entity.name.tag.wildcard.sass\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"CSS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Attribute Name for CSS\",\"scope\":[\"meta.attribute-selector.css entity.other.attribute-name.attribute\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Elixir Classes\",\"scope\":[\"source.elixir support.type.elixir\",\"source.elixir meta.module.elixir entity.name.class.elixir\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir Functions\",\"scope\":[\"source.elixir entity.name.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir Constants\",\"scope\":[\"source.elixir constant.other.symbol.elixir\",\"source.elixir constant.other.keywords.elixir\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir String Punctuations\",\"scope\":[\"source.elixir punctuation.definition.string\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir\",\"scope\":[\"source.elixir variable.other.readwrite.module.elixir\",\"source.elixir variable.other.readwrite.module.elixir punctuation.definition.variable.elixir\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir Binary Punctuations\",\"scope\":[\"source.elixir .punctuation.binary.elixir\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Closure Constant Keyword\",\"scope\":[\"constant.keyword.clojure\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Go Function Calls\",\"scope\":[\"source.go meta.function-call.go\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Go Keywords\",\"scope\":[\"source.go keyword.package.go\",\"source.go keyword.import.go\",\"source.go keyword.function.go\",\"source.go keyword.type.go\",\"source.go keyword.struct.go\",\"source.go keyword.interface.go\",\"source.go keyword.const.go\",\"source.go keyword.var.go\",\"source.go keyword.map.go\",\"source.go keyword.channel.go\",\"source.go keyword.control.go\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Go Constants e.g. nil, string format (%s, %d, etc.)\",\"scope\":[\"source.go constant.language.go\",\"source.go constant.other.placeholder.go\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"C++ Functions\",\"scope\":[\"entity.name.function.preprocessor.cpp\",\"entity.scope.name.cpp\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"C++ Meta Namespace\",\"scope\":[\"meta.namespace-block.cpp\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"C++ Language Primitive Storage\",\"scope\":[\"storage.type.language.primitive.cpp\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"C++ Preprocessor Macro\",\"scope\":[\"meta.preprocessor.macro.cpp\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"C++ Variable Parameter\",\"scope\":[\"variable.parameter\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Powershell Variables\",\"scope\":[\"variable.other.readwrite.powershell\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Powershell Function\",\"scope\":[\"support.function.powershell\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"ID Attribute Name in HTML\",\"scope\":[\"entity.other.attribute-name.id.html\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"HTML Punctuation Definition Tag\",\"scope\":[\"punctuation.definition.tag.html\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"HTML Doctype\",\"scope\":[\"meta.tag.sgml.doctype.html\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"JavaScript Classes\",\"scope\":[\"meta.class entity.name.type.class.js\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"JavaScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.js\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"JavaScript Terminator\",\"scope\":[\"terminator.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Meta Punctuation Definition\",\"scope\":[\"meta.js punctuation.definition.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Entity Names in Code Documentations\",\"scope\":[\"entity.name.type.instance.jsdoc\",\"entity.name.type.instance.phpdoc\"],\"settings\":{\"foreground\":\"#4d667b\"}},{\"name\":\"Other Variables in Code Documentations\",\"scope\":[\"variable.other.jsdoc\",\"variable.other.phpdoc\"],\"settings\":{\"foreground\":\"#3e697c\"}},{\"name\":\"JavaScript module imports and exports\",\"scope\":[\"variable.other.meta.import.js\",\"meta.import.js variable.other\",\"variable.other.meta.export.js\",\"meta.export.js variable.other\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Variable Parameter Function\",\"scope\":[\"variable.parameter.function.js\"],\"settings\":{\"foreground\":\"#555ea2\"}},{\"name\":\"JavaScript[React] Variable Other Object\",\"scope\":[\"variable.other.object.js\",\"variable.other.object.jsx\",\"variable.object.property.js\",\"variable.object.property.jsx\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Variables\",\"scope\":[\"variable.js\",\"variable.other.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Entity Name Type\",\"scope\":[\"entity.name.type.js\",\"entity.name.type.module.js\"],\"settings\":{\"foreground\":\"#111111\",\"fontStyle\":\"\"}},{\"name\":\"JavaScript Support Classes\",\"scope\":[\"support.class.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JSON Property Names\",\"scope\":[\"support.type.property-name.json\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"JSON Support Constants\",\"scope\":[\"support.constant.json\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"JSON Property values (string)\",\"scope\":[\"meta.structure.dictionary.value.json string.quoted.double\"],\"settings\":{\"foreground\":\"#7c5686\"}},{\"name\":\"Strings in JSON values\",\"scope\":[\"string.quoted.double.json punctuation.definition.string.json\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Specific JSON Property values like null\",\"scope\":[\"meta.structure.dictionary.json meta.structure.dictionary.value constant.language\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"JavaScript Other Variable\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Ruby Variables\",\"scope\":[\"variable.other.ruby\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Ruby Class\",\"scope\":[\"entity.name.type.class.ruby\"],\"settings\":{\"foreground\":\"#984e4d\"}},{\"name\":\"Ruby Hashkeys\",\"scope\":[\"constant.language.symbol.hashkey.ruby\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Ruby Symbols\",\"scope\":[\"constant.language.symbol.ruby\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"LESS Tag names\",\"scope\":[\"entity.name.tag.less\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"LESS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Attribute Name for LESS\",\"scope\":[\"meta.attribute-selector.less entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Markdown Headings\",\"scope\":[\"markup.heading.markdown\",\"markup.heading.setext.1.markdown\",\"markup.heading.setext.2.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Markdown Italics\",\"scope\":[\"markup.italic.markdown\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"italic\"}},{\"name\":\"Markdown Bold\",\"scope\":[\"markup.bold.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\",\"fontStyle\":\"bold\"}},{\"name\":\"Markdown Quote + others\",\"scope\":[\"markup.quote.markdown\"],\"settings\":{\"foreground\":\"#5c6285\"}},{\"name\":\"Markdown Raw Code + others\",\"scope\":[\"markup.inline.raw.markdown\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Markdown Links\",\"scope\":[\"markup.underline.link.markdown\",\"markup.underline.link.image.markdown\"],\"settings\":{\"foreground\":\"#954f5a\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Link Title and Description\",\"scope\":[\"string.other.link.title.markdown\",\"string.other.link.description.markdown\"],\"settings\":{\"foreground\":\"#403f53\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Punctuation\",\"scope\":[\"punctuation.definition.string.markdown\",\"punctuation.definition.string.begin.markdown\",\"punctuation.definition.string.end.markdown\",\"meta.link.inline.markdown punctuation.definition.string\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Markdown MetaData Punctuation\",\"scope\":[\"punctuation.definition.metadata.markdown\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Markdown List Punctuation\",\"scope\":[\"beginning.punctuation.definition.list.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Markdown Inline Raw String\",\"scope\":[\"markup.inline.raw.string.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"PHP Variables\",\"scope\":[\"variable.other.php\",\"variable.other.property.php\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Support Classes in PHP\",\"scope\":[\"support.class.php\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Punctuations in PHP function calls\",\"scope\":[\"meta.function-call.php punctuation\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"PHP Global Variables\",\"scope\":[\"variable.other.global.php\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Declaration Punctuation in PHP Global Variables\",\"scope\":[\"variable.other.global.php punctuation.definition.variable\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Language Constants in Python\",\"scope\":[\"constant.language.python\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Python Function Parameter and Arguments\",\"scope\":[\"variable.parameter.function.python\",\"meta.function-call.arguments.python\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Python Function Call\",\"scope\":[\"meta.function-call.python\",\"meta.function-call.generic.python\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Punctuations in Python\",\"scope\":[\"punctuation.python\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Decorator Functions in Python\",\"scope\":[\"entity.name.function.decorator.python\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Python Language Variable\",\"scope\":[\"source.python variable.language.special\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Python import control keyword\",\"scope\":[\"keyword.control\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"SCSS Variable\",\"scope\":[\"variable.scss\",\"variable.sass\",\"variable.parameter.url.scss\",\"variable.parameter.url.sass\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Attribute Name for SASS\",\"scope\":[\"meta.attribute-selector.scss entity.other.attribute-name.attribute\",\"meta.attribute-selector.sass entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Tag names in SASS\",\"scope\":[\"entity.name.tag.scss\",\"entity.name.tag.sass\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"SASS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.scss\",\"keyword.other.unit.sass\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"TypeScript[React] Variables and Object Properties\",\"scope\":[\"variable.other.readwrite.alias.ts\",\"variable.other.readwrite.alias.tsx\",\"variable.other.readwrite.ts\",\"variable.other.readwrite.tsx\",\"variable.other.object.ts\",\"variable.other.object.tsx\",\"variable.object.property.ts\",\"variable.object.property.tsx\",\"variable.other.ts\",\"variable.other.tsx\",\"variable.tsx\",\"variable.ts\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"TypeScript[React] Entity Name Types\",\"scope\":[\"entity.name.type.ts\",\"entity.name.type.tsx\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"TypeScript[React] Node Classes\",\"scope\":[\"support.class.node.ts\",\"support.class.node.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"TypeScript[React] Entity Name Types as Parameters\",\"scope\":[\"meta.type.parameters.ts entity.name.type\",\"meta.type.parameters.tsx entity.name.type\"],\"settings\":{\"foreground\":\"#4d667b\"}},{\"name\":\"TypeScript[React] Import/Export Punctuations\",\"scope\":[\"meta.import.ts punctuation.definition.block\",\"meta.import.tsx punctuation.definition.block\",\"meta.export.ts punctuation.definition.block\",\"meta.export.tsx punctuation.definition.block\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.decorator punctuation.decorator.ts\",\"meta.decorator punctuation.decorator.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.tag.js meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"YAML Entity Name Tags\",\"scope\":[\"entity.name.tag.yaml\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"JavaScript Variable Other ReadWrite\",\"scope\":[\"variable.other.readwrite.js\",\"variable.parameter\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Support Class Component\",\"scope\":[\"support.class.component.js\",\"support.class.component.tsx\"],\"settings\":{\"foreground\":\"#aa0982\",\"fontStyle\":\"\"}},{\"name\":\"Text nested in React tags\",\"scope\":[\"meta.jsx.children\",\"meta.jsx.children.js\",\"meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"TypeScript Classes\",\"scope\":[\"meta.class entity.name.type.class.tsx\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"TypeScript Entity Name Type\",\"scope\":[\"entity.name.type.tsx\",\"entity.name.type.module.tsx\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"TypeScript Class Variable Keyword\",\"scope\":[\"meta.class.ts meta.var.expr.ts storage.type.ts\",\"meta.class.tsx meta.var.expr.tsx storage.type.tsx\"],\"settings\":{\"foreground\":\"#76578b\"}},{\"name\":\"TypeScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.ts\",\"meta.method.declaration storage.type.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"normalize font style of certain components\",\"scope\":[\"meta.property-list.css meta.property-value.css variable.other.less\",\"meta.property-list.scss variable.scss\",\"meta.property-list.sass variable.sass\",\"meta.brace\",\"keyword.operator.operator\",\"keyword.operator.or.regexp\",\"keyword.operator.expression.in\",\"keyword.operator.relational\",\"keyword.operator.assignment\",\"keyword.operator.comparison\",\"keyword.operator.type\",\"keyword.operator\",\"keyword\",\"punctuation.definintion.string\",\"punctuation\",\"variable.other.readwrite.js\",\"storage.type\",\"source.css\",\"string.quoted\"],\"settings\":{\"fontStyle\":\"\"}}],\"styleOverrides\":{\"frames\":{\"editorBackground\":\"var(--sl-color-gray-7)\",\"terminalBackground\":\"var(--sl-color-gray-7)\",\"editorActiveTabBackground\":\"var(--sl-color-gray-7)\",\"terminalTitlebarDotsForeground\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"terminalTitlebarDotsOpacity\":\"0.75\",\"inlineButtonForeground\":\"var(--sl-color-text)\",\"frameBoxShadowCssValue\":\"none\"},\"textMarkers\":{\"markBackground\":\"#0000001a\",\"markBorderColor\":\"#00000055\"}}}],\"defaultLocale\":\"en\",\"cascadeLayer\":\"starlight.components\",\"styleOverrides\":{\"borderRadius\":\"0px\",\"borderWidth\":\"1px\",\"codePaddingBlock\":\"0.75rem\",\"codePaddingInline\":\"1rem\",\"codeFontFamily\":\"var(--__sl-font-mono)\",\"codeFontSize\":\"var(--sl-text-code)\",\"codeLineHeight\":\"var(--sl-line-height)\",\"uiFontFamily\":\"var(--__sl-font)\",\"textMarkers\":{\"lineDiffIndicatorMarginLeft\":\"0.25rem\",\"defaultChroma\":\"45\",\"backgroundOpacity\":\"60%\"}},\"plugins\":[{\"name\":\"Starlight Plugin\",\"hooks\":{}},{\"name\":\"astro-expressive-code\",\"hooks\":{}}]}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false},\"prefetch\":{\"prefetchAll\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"en\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}}}","docs",["Map",11,12,28,29,59,60,72,73,85,86,98,99,111,112,124,125,137,138,148,149,160,161,172,173,185,186,197,198,209,210,221,222,234,235,246,247,258,259,269,270,281,282,293,294,305,306,317,318,329,330,341,342,353,354,364,365,377,378,389,390,401,402,413,414,424,425,436,437,448,449,460,461,472,473,484,485,496,497,507,508,518,519,530,531,542,543,554,555,566,567,578,579,590,591,602,603,614,615,626,627,638,639,649,650,661,662,673,674,685,686,696,697,708,709],"how-to-use",{"id":11,"data":13,"body":25,"filePath":26,"digest":27,"deferredRender":16},{"title":14,"description":15,"editUrl":16,"head":17,"template":18,"sidebar":19,"pagefind":16,"draft":20,"sitemap":22},"How to Use","Guide for using executable code blocks and Typst rendering",true,[],"doc",{"hidden":20,"attrs":21},false,{},{"linkInclusionRules":23},[24],"**/*","import ExecutableCode from '../../components/ExecutableCode.astro';\n\n# How to Use\n\nThis guide explains how to use executable code blocks and Typst rendering in your MDX notes.\n\n# Executable Code Blocks\n\n## Basic Syntax\n\nThere are two ways to write executable code blocks:\n\n### Method 1: Using the Component Directly\n\n```jsx\n\u003CExecutableCode\n  language=\"python\"\n  id=\"my-block\"\n  code={`print(\"Hello, World!\")`}\n/>\n```\n\n### Method 2: Using ```code Syntax (Simplified)\n\nYou can also use a simpler fence syntax that gets automatically converted:\n\n````\n\u003CExecutableCode\n  language=\"python\"\n  id=\"my-block\"\n  code={`print(\"Hello, World!\")`}\n/>\n````\n\nThen run `npm run convert-code-syntax` to convert it to the ExecutableCode component.\n\n### Required Props/Attributes\n\n- **`language`**: The programming language (`python`, `lean4`, or `rust`)\n- **`id`**: A unique identifier for the block (within the file)\n- **`code`**: The code to execute (wrapped in template literals)\n\n### Optional Props\n\n- **`session`**: Session name to share state between blocks\n- **`output`**: Manual output (if you don't want auto-execution)\n- **`showOutput`**: Set to `false` to hide the output section\n\n## Session Handling\n\nUse sessions to persist variables between code blocks.\n\n**Component syntax:**\n\n```jsx\n\u003CExecutableCode\n  language=\"python\"\n  id=\"block-1\"\n  session=\"my-session\"\n  code={`x = 10\ny = 20`}\n/>\n\n\u003CExecutableCode\n  language=\"python\"\n  id=\"block-2\"\n  session=\"my-session\"\n  code={`print(f\"x + y = {x + y}\")`}\n/>\n```\n\n**```code syntax:**\n\n````\n\u003CExecutableCode\n  language=\"python\"\n  id=\"block-1\"\n  session=\"my-session\"\n  code={`x = 10\ny = 20`}\n/>\n\n\u003CExecutableCode\n  language=\"python\"\n  id=\"block-2\"\n  session=\"my-session\"\n  code={`print(f\"x + y = {x + y}\")`}\n/>\n````\n\nAll blocks with the same `session` name will share their state.\n\n## Supported Languages\n\n### Python\n\n**Component syntax:**\n```jsx\n\u003CExecutableCode\n  language=\"python\"\n  id=\"python-example\"\n  code={`def factorial(n):\n    if n \u003C= 1:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(5))`}\n/>\n```\n\n**```code syntax:**\n````\n\u003CExecutableCode\n  language=\"python\"\n  id=\"python-example\"\n  code={`def factorial(n):\n    if n \u003C= 1:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(5))`}\n/>\n````\n\n### Lean4\n\n**Component syntax:**\n```jsx\n\u003CExecutableCode\n  language=\"lean4\"\n  id=\"lean-example\"\n  code={`def double (x : Nat) : Nat := x + x\n\n#eval double 21`}\n/>\n```\n\n**```code syntax:**\n````\n\u003CExecutableCode\n  language=\"lean4\"\n  id=\"lean-example\"\n  code={`def double (x : Nat) : Nat := x + x\n\n#eval double 21`}\n/>\n````\n\n## Workflow\n\n### If Using Component Syntax Directly\n\n1. **Write your MDX file** with ExecutableCode components\n2. **Import the component** at the top of your file:\n   ```jsx\n   import ExecutableCode from '../../../components/ExecutableCode.astro';\n   ```\n3. **Run the execution script**:\n   ```bash\n   npm run execute-code\n   ```\n4. **View your notes** with `npm run dev`\n\n### If Using ```code Syntax\n\n1. **Write your MDX file** using ````code` fences with attributes\n2. **Run the processing script**:\n   ```bash\n   npm run process-all\n   ```\n\n   This runs three scripts in sequence:\n   - Converts LaTeX in headings to Unicode\n   - Converts ````code` syntax to ExecutableCode components (adds import automatically)\n   - Executes all code blocks and generates outputs\n\n3. **View your notes** with `npm run dev`\n\n## Important Notes\n\n### Unique IDs\n\nIDs only need to be unique **within each file**. The system automatically prefixes IDs with the filename to prevent collisions:\n\n```\ndependiente.mdx:  id=\"example-1\"    dependiente::example-1\nexample.mdx:      id=\"example-1\"    example::example-1\n```\n\nSo you can use simple IDs like \"1\", \"2\", \"example-1\", etc. in each file without worrying about conflicts.\n\n### Import Statement\n\nAlways add this import at the top of your MDX file (after the frontmatter):\n\n```jsx\n---\ntitle: Your Title\n---\n\nimport ExecutableCode from '../../../components/ExecutableCode.astro';\n```\n\nMake sure there's a blank line after the frontmatter (`---`) and before the import.\n\n### Manual Output\n\nIf you want to provide output manually without execution:\n\n```jsx\n\u003CExecutableCode\n  language=\"python\"\n  code={`print(\"Hello\")`}\n  output=\"Hello\"\n/>\n```\n\n### Hiding Output\n\nTo show only the code without output:\n\n```jsx\n\u003CExecutableCode\n  language=\"python\"\n  id=\"setup\"\n  code={`import numpy as np`}\n  showOutput={false}\n/>\n```\n\n## Scripts Reference\n\n- **`npm run convert-code-syntax`** - Convert code blocks to ExecutableCode components\n- **`npm run typst-to-unicode`** - Convert Typst math in headings to Unicode (e.g., `$NN$`  )\n- **`npm run execute-code`** - Execute all code blocks\n- **`npm run process-all`** - Run all scripts in sequence (code, unicode, execution)\n\n## Showcase Examples\n\n### Python: Fibonacci Sequence\n\n\u003CExecutableCode\n  language=\"python\"\n  id=\"showcase-fibonacci\"\n  code={`def fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        print(a, end=' ')\n        a, b = b, a + b\n\nfibonacci(10)`}\n/>\n\n### Lean4: Type Theory\n\n\u003CExecutableCode\n  language=\"lean4\"\n  id=\"showcase-lean\"\n  code={`def compose {   : Type} (g :   ) (f :   ) :    :=\n  fun x => g (f x)\n\ndef double (x : Nat) : Nat := x + x\ndef triple (x : Nat) : Nat := x + x + x\n\n#eval (compose triple double) 5`}\n/>\n\n### Rust: Pattern Matching\n\n\u003CExecutableCode\n  language=\"rust\"\n  id=\"showcase-rust\"\n  code={`fn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    let sum: i32 = numbers.iter().sum();\n    let doubled: Vec\u003Ci32> = numbers.iter().map(|x| x * 2).collect();\n\n    println!(\"Sum: {}\", sum);\n    println!(\"Doubled: {:?}\", doubled);\n}`}\n/>\n\n### Python with Sessions: Data Processing\n\n\u003CExecutableCode\n  language=\"python\"\n  id=\"showcase-data-1\"\n  session=\"data-demo\"\n  code={`import statistics\n\ndata = [23, 45, 12, 67, 34, 89, 56]\nprint(f\"Original data: {data}\")`}\n/>\n\n\u003CExecutableCode\n  language=\"python\"\n  id=\"showcase-data-2\"\n  session=\"data-demo\"\n  code={`mean = statistics.mean(data)\nmedian = statistics.median(data)\nprint(f\"Mean: {mean:.2f}\")\nprint(f\"Median: {median}\")`}\n/>\n\n\u003CExecutableCode\n  language=\"python\"\n  id=\"showcase-data-3\"\n  session=\"data-demo\"\n  code={`sorted_data = sorted(data)\nprint(f\"Sorted: {sorted_data}\")\nprint(f\"Min: {min(data)}, Max: {max(data)}\")`}\n/>\n\n## Tips\n\n1. Run `npm run execute-code` whenever you add or modify code blocks\n2. The outputs are cached in `src/code-outputs.json`\n3. Sessions are scoped per file and language\n4. Use descriptive IDs to make it easier to debug\n5. Supported languages: Python, Lean4, and Rust\n\n---\n\n# Typst Rendering\n\nRender Typst code blocks and inline math expressions with automatic SVG conversion.\n\n## Inline Math\n\nUse `$...$` for inline math and `$ ... $` (with spaces) for display math:\n\n**Inline math:** The natural numbers are denoted $NN$ and the integers $ZZ$.\n\n**Display math:** The quadratic formula is $ x = (-b plus.minus sqrt(b^2 - 4a c))/(2a) $\n\n## Code Blocks\n\nUse ` ```typst ` fenced code blocks to write full Typst code:\n\n```typst\n#import \"@preview/cetz:0.2.2\": canvas, draw\n\n#canvas({\n  draw.line((0, 0), (1, 1))\n  draw.circle((0.5, 0.5), radius: 0.3)\n})\n```\n\n### Disable Execution\n\nTo show Typst code without executing it, use `eval=false`:\n\n```typst eval=false\n#import \"@preview/curryst:0.5.1\": rule, prooftree\n\n#prooftree(\n  rule(\n    $Gamma tack.r f(a): B$,\n    $Gamma tack.r a: A$,\n    $Gamma tack.r f: A arrow.r B$\n  )\n)\n```\n\nThis will display the code with syntax highlighting but won't render it as SVG.\n\n### Frontmatter Imports\n\nTo avoid repeating imports in every code block, add them to your page frontmatter:\n\n```yaml\n---\ntitle: My Page\ntypstImports:\n  - '#import \"@preview/commute:0.3.0\": node, arr, commutative-diagram'\n  - '#import \"@preview/cetz:0.2.2\": canvas, draw'\n---\n```\n\nNow all Typst code blocks on that page will automatically have these imports available.\n\n**Note:** Frontmatter imports only apply to code blocks (` ```typst `), not to inline math expressions.\n\n## Examples\n\n### Commutative Diagram\n\n```typst\n#import \"@preview/commute:0.3.0\": node, arr, commutative-diagram\n\n#commutative-diagram(\n  node((0, 0), $A$),\n  node((0, 1), $B$),\n  node((1, 0), $C$),\n  arr((0, 0), (0, 1), $f$),\n  arr((0, 0), (1, 0), $g$),\n  arr((0, 1), (1, 0), $h$)\n)\n```\n\n### Proof Tree\n\n```typst\n#import \"@preview/curryst:0.5.1\": rule, prooftree\n\n#prooftree(\n  rule(\n    $Gamma tack.r f(a): B$,\n    $Gamma tack.r a: A$,\n    $Gamma tack.r f: A arrow.r B$\n  )\n)\n```\n\n### Chemical Formulas\n\nChemical formula with subscripts: $H_2 O$ is water.\n\nComplex molecule: $C_6 H_(12) O_6$ is glucose.\n\n## Plugin Architecture\n\nThe Typst integration uses two custom plugins:\n\n1. **`remark-typst.js`** - Processes markdown and identifies Typst code\n2. **`rehype-typst.js`** - Compiles Typst to SVG using `@myriaddreamin/typst-ts-node-compiler`\n\nThese plugins are configured in `astro.config.mjs`:\n\n```js\nmarkdown: {\n  remarkPlugins: [remarkTypst],\n  rehypePlugins: [rehypeTypst],\n}\n```","src/content/docs/how-to-use.mdx","d2e5a9be380aad88","index",{"id":28,"data":30,"filePath":55,"assetImports":56,"digest":58,"deferredRender":16},{"title":31,"description":32,"editUrl":16,"head":33,"template":34,"hero":35,"sidebar":51,"pagefind":16,"draft":20,"sitemap":53},"Bienvenido a mi pgina","En esta pgina puedes encontrar cosas que hago.",[],"splash",{"tagline":32,"image":36,"actions":39},{"alt":37,"file":38},"","__ASTRO_IMAGE_../../assets/houston.webp",[40,47],{"text":41,"link":42,"variant":43,"icon":44},"Teora de tipos","/tipos/","primary",{"type":45,"name":46},"icon","right-arrow",{"text":48,"link":49,"variant":43,"icon":50},"Teora de categoras","/categorias/",{"type":45,"name":46},{"hidden":20,"attrs":52},{},{"linkInclusionRules":54},[24],"src/content/docs/index.mdx",[57],"../../assets/houston.webp","ad24c290809e0311","nix/basicos-nix",{"id":59,"data":61,"body":69,"filePath":70,"digest":71,"deferredRender":16},{"title":62,"editUrl":16,"head":63,"template":18,"sidebar":64,"pagefind":16,"draft":20,"sitemap":67},"Bsicos del lenguaje Nix",[],{"order":65,"hidden":20,"attrs":66},3,{},{"linkInclusionRules":68},[24],"import { Aside } from '@astrojs/starlight/components';\n\n## Cmo correr los ejemplos?\n\n### Evaluacin interactiva\n\nPodemos usar el `nix repl` para evaluar expresiones de Nix de forma interactiva\n\n```code :language bash :eval false\n$ nix repl\nWelcome to Nix 2.13.3. Type :? for help.\n\nnix-repl> 1 + 2\n3\n```\n\u003CAside type=\"note\">\nEl lenguaje Nix usa lazy evaluation y `nix repl` slo computa los valores cuando se\nnecesitan.\n\u003C/Aside>\n\n### Evaluando archivos Nix\n\nPodemos usar `nix-instantiate --eval` para evaluar las expresiones en un \narchivo Nix.\n\n```code :language bash :eval false\n$ echo 1 + 2 > file.nix\n$ nix-instantiate --eval file.nix\n3\n```\n\u003CAside text=\"note\">\n`nix-instantiate --eval` intenta leer desde el archivo `default.nix` si no se le \nespecifica ninguno.\n\u003C/Aside>\n\n## Nombres y valores\n\nLos valores en el lenguaje Nix pueden ser tipos de datos primitivos, listas, conjuntos\nde atributos y funciones.\n\nLos `attribute sets` y las expresiones `let` son usados para asignar nombres a las \nvariables. Las asignaciones se denotan con un slo signo de igual `=`.\n\nSiempre que encontramos un signo de igual en Nix:\n\n- Del lado izquierdo hay un nombre.\n- Del lado derecho hay un valor delimitado por `;`.\n\n### Attribute set `{ ... }`\n\nUn attribute set es una coleccin de parejas nombre-valor, donde los nombres deben \nser nicos.\n\n ```code :language nix :eval false\n{\n  string = \"hello\";\n  integer = 1;\n  float = 3.1415;\n  bool = true;\n  null = null;\n  list = [1 \"dos\" false];\n  attribute-set = {\n    a = \"hello\";\n    b = 2;\n    c = 2.718;\n    d = false;\n  };\n}\n ```\n#### Attribute set recursivo `rec { ... }`\nEl prefijo `rec` en un attribute set permite acceder a los atributos dentro del mismo.}\n\n```code :language nix :eval false\nrec {\n  one = 1;\n  two = one + 1;\n  three = two + 1;\n}\n```\n### `let ... in ...`\nTambin conocido como \"expresin `let`\". Las expresiones `let` permiten asignarles\nnombres a los valores para usarlos repetidamente.\n\n\u003CExecutableCode\n  language=\"nix\"\n  id=\"uno\"\n  code={`let \n  a = 1;\nin \n\na + a`}\n/>\n\nlos nombres se pueden asignar en cualquier orden y las expresiones del lado derecho\npueden referirse a otros nombres asignados.\n\n\u003CExecutableCode\n  language=\"nix\"\n  id=\"dos\"\n  code={`let \n  b = a + 1;\n  a = 1;\nin\n\na + b`}\n/>\n## Acceso a atributos\n\nPodemos acceder a los atributos en un conjunto mediante un `.` y el nombre del\natributo.\n\n\u003CExecutableCode\n  language=\"nix\"\n  id=\"tres\"\n  code={`let\n  attrset = { x = 1; };\nin \n  attrset.x`}\n/>\n\nLa notacin `.` puede usarse tambin para asignar valores\n\n```code :language nix :eval false\n{ a.b.c = 1; }\n```\nEs lo mismo que \n\n```code :language nix :eval false\n{ a = { b = { c = 1; }; }; }\n```\n\n### `with ...; ...`\n\nLa expresin `with` permite acceder a los atributos sin referenciar repetidamente \na su attribute set.\n\n\u003CExecutableCode\n  language=\"nix\"\n  id=\"cuatro\"\n  code={`let \n    a = {\n      x = 1;\n      y = 2;\n      z = 3;\n    };\nin \nwith a; [ x y z ]`}\n/>\n\n\nLa expresin \n```code :language nix :eval false\nwith a; [ x y z ]\n```\nes equivalente a \n```code :language nix :eval false\n[ a.x a.y a.z ]\n```\nLas atributos que se hacen disponibles con `with` slo estn en el scope siguiendo\nal `;`.\n\n## `inherit ...`\n`inherit` es una abreviacin para asignar el valor de un nombre de un alcance\nexistente al mismo nombre en un alcance anidado. Es por conveniencia, para evitar\nrepetir el mismo nombre mltiples veces.\n\n```code :language nix :eval false \nlet \n  x = 1;\n  y = 2;\nin \n{\n  inherit x y;\n}\n```\n\nEl fragmento \n```code :language nix :eval false\ninherit x y;\n```\nes equivalente a \n```code :language nix :eval false\nx = x; y = y;\n```\nEs tambin posible hacer `inherit` no nombres de un attribute set especfico con \nparntesis (`inherit (...) ...`)\n\n```code :language nix :eval false\nlet\n  a = { x = 1; y = 2; };\nin \n{\n  inherit (a) x y; \n}\n```\nEl fragmento \n```code :language nix :eval false\ninherit (a) x y;\n```\nes equivalente a \n\n```code :language nix :eval false\nx = a.x; y = a.y;\n```\n`inherit` tambin funciona dentro de expresiones `let`.\n\n```code :language nix :eval false\nlet \n  inherit ({ x = 1; y = 2; }) x y;\nin [x y]\n```","src/content/docs/nix/basicos-nix.mdx","5974b548fa607c2f","nix/existente",{"id":72,"data":74,"body":82,"filePath":83,"digest":84,"deferredRender":16},{"title":75,"editUrl":16,"head":76,"template":18,"sidebar":77,"pagefind":16,"draft":20,"sitemap":80},"Empacando software existente",[],{"order":78,"hidden":20,"attrs":79},4,{},{"linkInclusionRules":81},[24],"Para empezar, consideremos este esqueleto de una derivacin \n\n```code :language nix :eval false \n{stdenv}:\n\nstdenv.mkDerivation { }\n```\nEsta es una funcin que toma como entrada un conjunto de atributos que contiene \n`stdenv` y produce una derivacin (que actualmente no hace nada).","src/content/docs/nix/existente.mdx","e00416156244c679","nix/flakes",{"id":85,"data":87,"body":95,"filePath":96,"digest":97,"deferredRender":16},{"title":88,"editUrl":16,"head":89,"template":18,"sidebar":90,"pagefind":16,"draft":20,"sitemap":93},"Flakes",[],{"order":91,"hidden":20,"attrs":92},6,{},{"linkInclusionRules":94},[24],"Un flake es un rbol de archivos de sistema que contiene un archivo llamado ^flake.nix^ en el \nroot del directorio. ^flake.nix^ especifica algunos metadatos del flake como dependencias \n(llamadas *inputs*) al igual que *outputs* (los valores de Nix como paquetes o mdulos \nque da el flake).\n\n## Representacin como conjunto de atributos\n### Ejemplo \n\n```nix \n{\n  type = \"github\";\n  owner = \"NixOS\";\n  repo = \"nixpkgs\";\n}\n```\nEl nico atributo requerido es `type`. Los tipos soportados se enlistan abajo.\n\n## Sintaxis de URL \n### Ejemplo \n\n```code :language nix :eval false\ngithub:NixOS/nixpkgs\n```\nEstos se usan en la lnea de comandos como una alternativa conveniente para la representacin\ncomo conjunto de atributos. Por ejemplo, en el comando \n\n```bash\nnix build github:NixOS/nixpgs#hello\n```\n`github:NixOS/nixpkgs` es una referencia de flake (mientras que `hello` es un atributo de \noutput). Tambine se permiten en el atributo  `inputs` de un flake:\n\n```code :language nix :eval false\ninputs.nixpkgs.url = \"github:NixOS/nixpgs\";\n```\nesto equivale a \n\n```code :language nix :eval false\ninputs.nixpkgs {\n  type = \"github\";\n  owner = \"NixOS\";\n  repo = \"nixpkgs\";\n};\n```\n## Sintaxis path\n\nLos flakes que corresponden a un path local se pueden referenciar por referencia directa al\npath, ya sea de forma absoluta o relativa. Para paths relativos, se tiene que empezar el path \ncon `./`.\n\n## Formato de flake \nComo un ejemplo, aqu hay un `flake.nix` simple que depende del flake Nixpkgs y devuelve \nun paquete \n\n```nix \n{\n  description = \"A flake for building Hello World\";\n\n  inputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixos-20.03\";\n\n  outpust = { self, nixpkgs }: {\n    packages.x86_64-linux.default = \n    with import nixpkgs { system = \"x86_64-linux\"; };\n    stdenv.mkDerivation {\n      name = \"hello\";\n      src = self;\n      buildPhase = \"gcc -o hello ./hello.c\";\n      installPhase = \"mkdir -p $out/bin; install -t $out/bin hello$\"; \n    };\n  }\n}\n```","src/content/docs/nix/flakes.mdx","2696ef165b503e78","nix",{"id":98,"data":100,"body":108,"filePath":109,"digest":110,"deferredRender":16},{"title":101,"editUrl":16,"head":102,"template":18,"sidebar":103,"pagefind":16,"draft":20,"sitemap":106},"Nix",[],{"order":104,"hidden":20,"attrs":105},1,{},{"linkInclusionRules":107},[24],"Estas son mis notas sobre el lenguaje de programacin Nix.","src/content/docs/nix/index.mdx","4684179a5d7abf91","nix/modulos",{"id":111,"data":113,"body":121,"filePath":122,"digest":123,"deferredRender":16},{"title":114,"editUrl":16,"head":115,"template":18,"sidebar":116,"pagefind":16,"draft":20,"sitemap":119},"Mdulos",[],{"order":117,"hidden":20,"attrs":118},5,{},{"linkInclusionRules":120},[24],"Qu es un mdulo?\n- Un mdulo es una funcin que toma un conjunto de atributos y devuelve un conjunto de \n  atributos.\n- Puede declarar opeionces, que dicen qu atributos se aceptan el el outcome.\n- Puede definir valores, para opicones declaradas por s mismo u otros mdulos.\n- Cuando se evala por el sistema de mdulos, produce un conjunto de atributos.\n\n## Declarando opciones \nLas opciones se declaran bajo el atributo `options` con `lib.mkOption`.\n\n```code :language nix :eval false\n{ lib, ... }: \n{\n  options = {\n    name = lib.mkOption { type = lib.types.str; };\n  };\n}\n``` \nEl atributo `type` en el arugmento a `lib.mkOption` especifica qu valorees son vlidos para \nla opcin. Hay varios tipos disponibles bajo\n[`lib.types`](https://nixos.org/manual/nixos/stable/#sec-option-types-basic) \nAqu, hemos declarado una opcion `name` de tipo `str`: El sistema de mdulos espera \nun string cuando un valor es definido.\nAhora le queremos dar un valor.\n\n## Definiendo valores \nLas opciones son configuradas o definidas bajo el atributo `config`\n\n```code :language nix :eval false\n{ ... }: \n{\n  config = {\n    name = \"Emilio\";\n  };\n}\n```\nEn nuestra declaracin de opciones, creamos una opcin `name` de tipo `string`. Aqu le hemos \ndado un valor a esta misma opcin.\n\nLas opciones y declaraciones no necesitan estar en el mismo archivo. \n\n## Evaluando mdulos","src/content/docs/nix/modulos.mdx","a5fed787bf3de010","nix/shells-declarativos",{"id":124,"data":126,"body":134,"filePath":135,"digest":136,"deferredRender":16},{"title":127,"editUrl":16,"head":128,"template":18,"sidebar":129,"pagefind":16,"draft":20,"sitemap":132},"Shells declarativos",[],{"order":130,"hidden":20,"attrs":131},2,{},{"linkInclusionRules":133},[24],"import { Aside } from '@astrojs/starlight/components';\n\n## Entrando a un shell temporal\n\nSupongamos que queremos un ambiente donde `cowsay` y `lolcat` estn disponibles. \nLa manera ms simple es hacerlo mediante el comando `nix-shell -p`:\n\n```bash\n$ nix-shell -p cowsay lolcat\n```\nEste comando funciona, pero tiene algunas desventajas:\n\n- Tenemos que escribir `-p cowsay lolcat` cada vez que entramos a la shell. \n- No permite ms personalizacin del ambiente de shell\n\nUna mejor solucin es crear nuestro ambiente mediante un archivo `shell.nix`.\n\n## Un archivo `shell.nix` bsico\n\nCreemos un archivo llamado `shell.nix` con este contenido:\n\n```code :language nix :filename shell.nix :eval false\nlet\n  nixpkgs = fetchTarball \"https://github.com/NixOS/nixpkgs/tarball/nixos-24.05\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n\npkgs.mkShellNoCC {\n  packages = with pkgs; [\n    cowsay\n    lolcat\n  ];\n}\n```\n\u003CAside title=\"Explicacin\">\nPusimos explcitamente `config` y `overlays` para prevenir que sean sobre-escritos por \nconfiguracin global.\n\n`mkShellNoCC` es un a funcin que toma un conjunto de atributos. Aqu le dimos el\natributo `packages` con una lista que contiene dos items del conjunto de atributos \n`pkgs`. \n\u003C/Aside>\n\nPodemos entrar al ambiente corriendo `nix-shell` en el mismo directorio que \n`shell.nix`:\n\n```bash \n$ nix-shell\n[nix-shell]$ cowsay hello | lolcat\n```\n`nix-shell` por defecto busca un archivo llamado `shell.nix` en el directorio actual\ny crea un ambiente de shell a partir de la expresin de Nix en este archivo.\nLos paquetes definidos en el atributo `packages` estarn disponibles en el `$PATH`..\n\n## Variables de entorno\n\nPuede que queramos exportar ciertas variables de ambiente al entrar a un ambiente de\nshell.\nPodemos definir `GREETING` para que se pueda usar en ambiente de shell:\n\n```code :language nix :eval false :filename shell.nix\nlet\n  nixpkgs = fetchTarball \"https://github.com/NixOS/nixpkgs/tarball/nixos-24.05\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n\npkgs.mkShellNoCC {\n  packages = with pkgs; [\n    cowsay\n    lolcat\n  ];\n  \n  GREETING = \"Hello, Nix!\";\n}\n```\nCualquier nombre de atributo que se pase a `mkShellNoCC` que no est reservado y que \ntenga un valor que se puede coercionar a un string se vuelve una variable en entorno.\n\n## Comandos de arranque\nPuede que queramos correr ciertos comandos antes de entrar al entorno. Estos comandos\nse pueden colocar en el atributo `shellHook` de `mkShellNoCC`.\n\n```code :language nix :eval false :filename shell.nix\nlet\n  nixpkgs = fetchTarball \"https://github.com/NixOS/nixpkgs/tarball/nixos-24.05\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n\npkgs.mkShellNoCC {\n  packages = with pkgs; [\n    cowsay\n    lolcat\n  ];\n  \n  GREETING = \"Hello, Nix!\";\n  \n  shellHook = ''\n    echo $GREETING | cowsay | lolcat \n  '';\n}\n```","src/content/docs/nix/shells-declarativos.mdx","2123fa651db280bf","tipos",{"id":137,"data":139,"body":145,"filePath":146,"digest":147,"deferredRender":16},{"title":41,"editUrl":16,"head":140,"template":18,"sidebar":141,"pagefind":16,"draft":20,"sitemap":143},[],{"order":104,"hidden":20,"attrs":142},{},{"linkInclusionRules":144},[24],"import { LinkButton } from '@astrojs/starlight/components';\n\n## Notas\nAqu puedes encontrar mis notas sobre teora de tipos, por ahora contienen los siguientes sub-temas:\n\n\u003CLinkButton href=\"/tipos/rijke/\" icon=\"right-arrow\">Introduccin a la teora de tipos (Rijke)\u003C/LinkButton>","src/content/docs/tipos/index.mdx","1a54e5fa724f46c8","tipos/rijke/dependiente",{"id":148,"data":150,"body":157,"filePath":158,"digest":159,"deferredRender":16},{"title":151,"editUrl":16,"head":152,"template":18,"sidebar":153,"pagefind":16,"draft":20,"sitemap":155},"Teora de tipos dependiente",[],{"order":130,"hidden":20,"attrs":154},{},{"linkInclusionRules":156},[24],"import { Aside } from '@astrojs/starlight/components';\n\nLa teora de tipos dependiente es un conjunto de reglas de inferencia que se pueden \ncombinar para crear *derivaciones*. El objetivo de estas derivaciones es \nfrecuentemente construir un elemento de un cierto tipo. En cierto sentido, un tipo \nno es ms que una coleccin de objetos matemticos y construir elementos de un cierto \ntipo es el desafo matemtico del da a da. y construir elementos de un cierto \ntipo es el desafo matemtico del da a da.\n\n## Juicios y contextos\nUn argumento matemtico consiste de una sucesin de pasos, cada uno con una cantidad \nfinita de premisas para llegar a la siguiente etapa de la demostracin o construccin.\nEstos pasos se pueden representar mediante **reglas de inferencia**, que se escriben \nen la forma \n$ (cal(H)_1 space    cal(H)_2 space dots space cal(H)_n)/(cal(C)) $ \nArriba de la lnea horizontal hay una lista finita de juicios como las **premisas** y,\ndebajo, un slo juicio llamado la **conclusin**. El sistema de la teora de tipos \nest descrito por una serie de reglas de inferencias.\n\nUn ejemplo de regla de inferencia lo obtenemos con los tipos funcin:\n\n```typst\n#prooftree(\n  rule(\n    $Gamma tack.r f(a): B$,\n    $Gamma tack.r a: A$,\n    $Gamma tack.r f: A arrow.r B$\n  )\n) \n  ```\nEsta regla afirma que en un contexto $Gamma$ podemos usar un elemento $a: A$ y una \nfuncin $f: A arrow.r B$ para obtener un elemento $f(a): B$. Cada una de las expresiones \n\n- $Gamma tack.r a: A$\n- $Gamma tack.r f: A arrow.r B$\n- $Gamma tack.r f(a): B$\n\nson ejemplos de juicios.\n\n\u003Cdiv id=\"def-1-1-1\">\n\u003CAside type=\"tip\" title=\"Definicin 1.1.1\">\nHay cuatro tipos de **juicios** en la teora de tipos de Marrtin-Lf:\n\n1. $A$ es un **tipo** (bien formado) en un contexto $Gamma$. Expresamos este juicio \n  como $ Gamma tack.r A     \"type\". $ \n2. $A$ y $B$ son **tipos juiciosamente iguales** en un contexto $Gamma$. Expresamos \n    este juicio como $ A equiv B     \"type\" $ \n3. $a$ es un **elemento** de tipo $A$ en un contexto $Gamma$. Expresamos este juicio\n  como $ Gamma tack.r a: A. $ \n4. $a$ y $b$ son **elementos juiciosamente iguales** de tipo $A$ en un contexto \n  $Gamma$. Expresamos este juicio como $ Gamma tack.r a equiv b: A. $ \n\u003C/Aside>\n\u003C/div>\n\nObservemos que cualquier juicio es de la forma $Gamma tack.r cal(J)$, donde \n$Gamma$ es un contexto y $cal(J)$ es una *tesis de juicio* con una de las formas\nque mencionamos antes. El rol del contexto es declarar los **elementos hipotticos** que \nson asumidos junto con sus tipos. Los elementos hipotticos tambin son llamados \n**variables**.\n\n\u003Cdiv id=\"def-1-1-2\">\n\u003CAside type=\"tip\" title=\"Definicin 1.1.2\">\nUn **contexto** es una lista finita de **declaraciones de variables**\n$ x_1: A_1, x_2: A_2(x_1), dots, x_n: A_n (x_1, dots, x_(n-1)) $\nque satisface la condicin de que para cada $1 lt.eq k lt.eq n$ podemos derivar el juicio\n$ x_1: A_1, dots, x_(k-1): A_(k-1)(x_1, dots, x_(k-2)) tack.r A_k (x_1, dots, x_(k-1))     \"type\" $ \nusando las reglas de inferencia de la teora de tipos.\n\u003C/Aside>\n\u003C/div>\n\nLa condicin en la definicin [1.1.2](#def-1-1-2) de que cada elemento hipottico tiene un \ntipo asignado, se verifica recursivamente. \n\n## Familias de tipos\n\u003Cdiv id=\"def-1-2-1\">\n\u003CAside type=\"tip\" title=\"Definicin 1.2.1\">\nConsideremos un tipo $A$ en un contexto $Gamma$. Una **famlia**\nde tipos sobre $A$ en el contexto $Gamma$ es un tipo $B(x)$ en el contexto \n$Gamma, x: A$. En otras palabras, en la situacin en la que \n$Gamma, x: A tack.r B(x)     \"type\"$, decimos que $B$ es una familia de tipos \nsobre $A$ en el contexto $Gamma$. Alternativamente, decimos que $B(x)$ es un tipo\nindizado por $x: A$ en el contexto $Gamma$.\n\u003C/Aside>\n\u003C/div>\n\nUn ejemplo bsico de familia de tipos ocurrir cuando introduzcamos los *tipos identidad*.\nSe introducen como sigue:\n\n```typst\n#prooftree(\n  rule(\n    name: \".\",\n    $Gamma, x: A tack.r a = x \"type\"$,\n    $Gamma tack.r a: A$\n  )\n)\n```\nEsta regla asegura que dado un elemento $a: A$ en un contexto $Gamma$, podemos formar\nel tipo $a = x$ en el contexto $Gamma, x: A$. El tipo $a = x$ en el contexto \n$Gamma, x: A$ es un ejemplo de una familia de tipos sobre $A$ en el contexto \n$Gamma$. \n\n\u003Cdiv id=\"def-1-2-2\">\n\u003CAside type=\"tip\" title=\"Definicin 1.2.2\">\nConsideremos una familia de tipos $B$ sobre $A$ en un contexto $Gamma$. Una **seccin** de la familia $B$ sobre $A$ en el contexto $Gamma$ es un elemento de tipo $B(x)$ en el contexto $Gamma, x: A$, es decir, en el juicio \n$ Gamma, x: A tack.r b(x): B(x). $ \nDecimos que $b$ es una seccin de la familia $B$ sobre $A$ en el contexto $Gamma$.\nAlternativamente, decimos que $b(x)$ es un elemento de tipo $B(x)$ indizado por \n$x: A$ en el contexto $Gamma$.\n\u003C/Aside>\n\u003C/div>\n\n## Reglas de inferencia\nAhora estamos listos para presentar el sistema de reglas de inferencia que conforman la \nteora de tipos. Estas reglas son conocidas como **reglas estructurales** de la teora de\ntipos. Hay seis conjuntos de reglas de inferencia:\n\n1. Reglas sobre la formacin de contextos, tipos y sus elementos.\n2. Reglas que postulan que la igualdad juiciosa es una relacin de equivalencia.\n3. Reglas de conversin de variables.\n4. Reglas de substitucin.\n5. Reglas de debilitamiento.\n6. El elemento genrico.\n\n### Reglas sobre formacin de contextos, tipos y sus elementos\nLas siguientes reglas se siguen de las suposiciones sobre contextos, tipos y sus elementos\ny pueden usarse libremente en las derivaciones:\n\n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  align: center,\n  prooftree(\n    rule(\n      $Gamma tack.r A \"type\"$,\n      $Gamma, x: A tack.r B(x) \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r A \"type\"$,\n      $Gamma tack.r A equiv B \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r B \"type\"$,\n      $Gamma tack.r A equiv B \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r A \"type\"$,\n      $Gamma tack.r a: A$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r a: A$,\n      $Gamma tack.r a equiv b$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r b: A$,\n      $Gamma tack.r a equiv b$\n    )\n  )\n)\n```\n\n\n### La igualdad juiciosa es una regla de equivalencia\nLas reglas que postulan que la igualdad juiciosa en tipos y elementos es una relacin \nde equivalencia son las siguientes:\n\n\n```typst\n\n#table(\n  stroke: none,\n  columns: 3,\n  align: center,\n  prooftree(\n    rule(\n      $Gamma tack.r A equiv A \"type\"$,\n      $Gamma tack.r A \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r B equiv A \"type\"$,\n      $Gamma tack.r A equiv B \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r A equiv C \"type\"$,\n      $Gamma tack.r A equiv B \"type\"$,\n      $Gamma tack.r B equiv C \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r a equiv a: A$,\n      $Gamma tack.r a: A$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r b equiv a: A$,\n      $Gamma tack.r a equiv b: A$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r a equiv c: A$,\n      $Gamma tack.r a equiv b: A$,\n      $Gamma tack.r b equiv c: A$\n    )\n  )\n)\n```\n\n### Reglas de conversin de variables\nLas **reglas de conversin de variables** son reglas que postulan que podemos convertir\nel tipo de una variable por un tipo juiciosamente igual.\n\n```typst\n#prooftree(\n  rule(\n    name: \".\",\n    $Gamma, x: A', Delta tack.r B(x) \"type\"$,\n    $Gamma tack.r A equiv A' \"type\"$,\n    $Gamma, x: A, Delta tack.r B(x) \"type\"$\n  )\n)\n```\nEn esta regla de conversin, el contexto $Gamma, x: A, Delta$ es cualquier extensin \ndel contexto $Gamma, x: A$.\n\nSimilarmente, hay reglas de conversin de variables para la igualdad juiciosa de tipos, \npara elementos y para igualdad juiciosa de elementos. Podemos enunciar todas en una \nusando una **tesis de juicio genrica** $cal(J)$, que pueden ser cualquiera de las \ndefinidas en la definicin [1.1.1](#def-1-1-1):\n\n\n```typst\n#prooftree(\n  rule(\n    name: \".\",\n    $Gamma, x: A', Delta tack.r cal(J)$,\n    $Gamma tack.r A equiv A' \"type\"$,\n    $Gamma, x: A, Delta tack.r cal(J)$\n  )\n)\n```\n\nUna regla anloga de **conversin de elementos** convierte el tipo de un elemento a un tipo\njuiciosamente igual.\n\n### Substitucin\nSupongamos que tenemos un tipo \n$ Gamma, x: A, y_1: B_1, dots, y_n: B_n tack.r C     \"type\" $ \ny un elemento $a: A$ en el contexto $Gamma$. Entonces podemos substituir\nsimultneamente $a$ por todas las ocurrencias de $x$ en los tipos \n$B_1, dots, B_n$ y $C$ para obtener \n\n$ Gamma, y_1: B_1[a slash x], dots, y_n: B_n [a slash x] tack.r C[a slash x] \"type\". $ \n\nSimilarmente, podemos substituir $a$ por $x$ en un elemento $c: C$ para obtener un \nelemento $c[a slash x]: C[a slash x]$. As, la **regla de substitucin** se enuncia para \nuna tesis de juicio genrica $cal(J)$:\n$ (Gamma tack.r a: A quad Gamma, x: A, Delta tack.r cal(J))/(Gamma, Delta[a slash x] tack.r cal(J)[a slash x])S. $ \n\nAadimos dos \"reglas de congruencia\" para la substitucin, postulando que la substitucin \npor elementos juiciosamente iguales resulta en tipos y elementos juiciosamente iguales:\n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  row-gutter: 1em,\n  prooftree(\n    rule(\n      $Gamma, Delta[a slash x] tack.r B[a slash x] equiv B[a' slash x] \"type\"$,\n      $Gamma tack.r a equiv a': A$,\n      $Gamma, x: A, Delta tack.r B \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma, Delta[a slash x] tack.r b[a slash x] equiv b'[a slash x]: B[a slash x]$,\n      $Gamma tack.r a equiv a': A$, \n      $Gamma, x: A, Delta tack.r b: B$\n    )\n  )\n)\n\n```\n\n\u003Cdiv id=\"def-1-3-1\">\n\u003CAside type=\"tip\" title=\"Definicin 1.3.1\">\nCuando $B$ es una familia de tipos osbre $A$ en un contexto \n$Gamma$ y si tenemos $a: A$, entonces tambin decimos que $B[a slash x]$ es la **fibra**\nde $B$ en $a$ y escribimos $B(a)$ para referirnos a esta fibra.\nCuando $b$ es una seccin de la familia $B$ sobre $A$ en el contexto $Gamma$, \nllamamos al elemento $b[a slash x]$ el **valor** de $b$ en $a$ y escribimos $b(a)$.\n\u003C/Aside>\n\u003C/div>\n\n### Debilitamiento\nSi se nos da un tipo $A$ en un contexto $Gamma$, entonces cualquier juicio hecho \nen un contexto ms largo $Gamma, Delta$ tambin se puede hacer en el contexto \n$Gamma, x: A, Delta$ para una nueva variable $x$. La **regla de debilitamiento**\nafirma que el debilitamiento por un tipo $A$ en un contexto preserva la buena formacin \ny la igualdad juiciosa de tipos y elementos.\n\n\n```typst\n#prooftree(\n  rule(\n    name: $W.$,\n    $Gamma, x: A, Delta tack.r cal(J)$,\n    $Gamma tack.r A \"type\"$,\n    $Gamma, Delta tack.r cal(J)$\n  )\n)\n```\nEste proceso de expandir el contexto por una variable de tipo $A$ se llama \n**debilitamiento** por $A$.\n\nEn la situacin ms simple, tenemos dos tipos $A$ y $B$ en un contexto $Gamma$.\nEntonces podemos debilitar a $B$ por $A$ como sigue:\n\n```typst\n#prooftree(\n  rule(\n    $Gamma, x: A tack.r B \"type\"$,\n    $Gamma tack.r A \"type\"$,\n    $Gamma tack.r B \"type\"$\n  )\n)\n\n```\nEl tipo $B$ en el contexto $Gamma, x: A$ es llamado la **familia constante** $B$ o \nla **familia trivial** $B$.\n\n### Los elementos genricos\nSi tenemos un tipo $A$ en un contexto $Gamma$, podemos debilitar a $A$ por s mismo \npara obtener que $A$ es un tipo en el contexto $Gamma, x: A$. La regla del \n**elemento genrico** afirma que cualquier elemento hipottico $x: A$ en el contexto \n$Gamma, x: A$ es tambin un elemento de tipo $A$ en el contexto $Gamma, x: A$.\n\n```typst\n#prooftree(\n  rule(\n    name: $delta.$,\n    $Gamma, x: A tack.r x: A$,\n    $Gamma tack.r A \"type\"$\n  )\n)\n```\n\nEsta regla tambin es conocida como la **regla de la variable**, nos da una \n*funcin identidad* sobre el tipo $A$ en el contexto $Gamma.$\n\n## Derivaciones\nUna **derivacin** en la teora de tipos es un rbol finito en el que cada nodo es una \nregla de inferencia vlida.","src/content/docs/tipos/Rijke/dependiente.mdx","9c214e10ae79de2b","tipos/rijke/funciones-dependientes",{"id":160,"data":162,"body":169,"filePath":170,"digest":171,"deferredRender":16},{"title":163,"editUrl":16,"head":164,"template":18,"sidebar":165,"pagefind":16,"draft":20,"sitemap":167},"Funciones dependientes",[],{"order":78,"hidden":20,"attrs":166},{},{"linkInclusionRules":168},[24],"import { Aside } from '@astrojs/starlight/components';\n\nConsideremos una seccin $b$ sobre $A$ en un contexto $Gamma$, es decir, consideremos\n$ Gamma, x: A tack.r b(x): B(x). $\nVemos que $b$ es una eleccin de un elemento de cada $B(x)$, el tipo de la salida\ndepende de $x: A$. La asignacin $x arrow.r.bar b(x)$ es, en este sentido, una\n*funcin dependiente*. El tipo de todas estas funciones es llamado\n**tipo funcin dependiente**, y lo escribimos como\n$ Pi_((x: A)) B(x). $\nHay cuatro reglas principales para los $Pi$-tipos:\n\n1. La *regla de formacin*, que nos dice como formar tipos funcin dependiente.\n2. La *regla de introduccin*, que nos dice como introducir trminos del tipo funcin\n  dependiente.\n3. La *regla de eliminacin*, que nos dice como usar trminos arbitrarios del tipo funcin\n  dependiente.\n4. Las *reglas de computacin*, que nos dicen como interactan las reglas de introduccin\n  y de eliminacin.\n\nEn los casos de las reglas de formacin, introduccin y eliminacin, tambin necesitamos\nreglas que afirmen que estas construcciones preservar la igualdad juiciosa. Estas reglas\nson llamadas **reglas de congruencia**.\n\n## La regla de -formacin\nLa regla de $Pi$-formacin nos dice cmo se construyen los $Pi$-tipos. La idea es que\n$Pi_((x: A)) B(x)$ es un tipo **funcin dependiente**, para cada familia de tipos $B$\nsobre $A$, de modo que la regla de $Pi$-formacin dice:\n\n```typst\n#prooftree(\n  rule(\n    name: $Pi.$,\n    $Gamma tack.r Pi_((x: A)) B(x) \"type\"$,\n    $Gamma, x: A tack.r B(x) \"type\"$\n  )\n)\n\n```\nEsta regla simplemente dice que para formar el tipo $Pi_((x: A)) B(x)$ en el contexto\n$Gamma$, debemos tener una familia de tipos $B$ sobre $A$ en el contexto $Gamma$.\n\nTambin requerimos que la regla de formacin de tipos funcin dependiente preserva la\nigualdad juiciosa. Es decir, tenemos la **regla de congruencia** para $Pi$-tipos:\n\n```typst\n#prooftree(\n  rule(\n    name: $Pi\"-eq.\"$,\n    $Gamma tack.r Pi_((x: A)) B(x) equiv Pi_((x: A')) B'(x) \"type\"$,\n    $Gamma tack.r A equiv A' \"type\"$,\n    $Gamma, x: A tack.r B(x) equiv B'(x) \"type\"$\n  )\n)\n```\n\n\n## La regla de -introduccin\nLa regla de introduccin para funciones dependientes nos dice cmo podemos construir\nfunciones dependientes del tipo $Pi_((x: A)) B(x)$. La idea es que una funcin\ndependiente $f: Pi_((x: A)) B(x)$ es una operacin que lleva a  $x: A$ en\n$f(x): B(x)$. As, la regla de introduccin de tipos dependientes postula que para\nconstruir una funcin dependiente debemos construir un trmino $b(x): B(x)$ indizado\npor $x: A$ en un contexto $Gamma$:\n\n```typst\n#prooftree(\n  rule(\n    name: $lambda.$,\n    $Gamma tack.r lambda x. b(x) : Pi_((x: A)) B(x)$,\n    $Gamma, x: A tack.r b(x): B(x)$\n  )\n)\n```\n\nEsta regla de introduccin para funciones dependientes tambin es llamada la\n**regla de $lambda$-abstraccin** y decimos que la $lambda$-abstraccin\n$lambda x. b(x)$ **liga** la variable $x$ en $b$.\nTambin requerimos que la $lambda$-abstraccin preserve la igualdad juiciosa. As que\npostulamos la **regla de congruencia** para la $lambda$-abstraccin, que dice\n\n```typst\n#prooftree(\n  rule(\n    name: $lambda\"-eq.\"$,\n    $Gamma tack.r lambda x. b(x) equiv lambda x. b'(x): Pi_((x: A)) B(x)$,\n    $Gamma, x: A tack.r b(x) equiv b'(x): B(x)$\n  )\n)\n```\n\n\n### La regla de -eliminacin\n\nLa regla de eliminacin para tipos funcin dependiente nos da una manera de *usar*\nfunciones dependientes. La forma de usar funciones dependientes es evaluarlas en un\nargumento del tipo del dominio. La regla de $Pi$-eliminacin es tambin llamada la\n**regla de evaluacin**:\n\n\n```typst\n#prooftree(\n  rule(\n    name: \"ev.\",\n    $Gamma, x: A tack.r f(x): B(x)$,\n    $Gamma tack.r f: Pi_((x: A)) B(x)$\n  )\n)\n```\n\nEsta regla afirma que, dada una funcin dependiente $f: Pi_((x: A)) B(x)$ en un contexto\n$Gamma$ obtenemos un trmino $f(x)$ de tipo $B(x)$ indizado por $x: A$ en un\ncontexto $Gamma$. De nuevo, pedimos que la evaluacin preserve la igualdad juiciosa:\n\n  ```typst\n#prooftree(\n  rule(\n    name: \"ev-eq.\",\n    $Gamma, x: A tack.r f(x) equiv f'(x): B(x)$,\n    $Gamma tack.r f equiv f': Pi_((x: A)) B(x)$\n  )\n)\n```\n\n### Las reglas de -computacin\n\nAhora postulamos las reglas que especifican el comportamiento de las funciones. Primero,\ntenemos una regla que afirma que una funcin de la forma $lambda x. b(x)$ se comporta\ncomo esperamos: cuando la evaluamos en $x: A$, obtenemos un valor $b(x): B(x)$. Esta\nregla es llamada la *regla-$beta$*.\n\n```typst\n#prooftree(\n  rule(\n    name: $beta.$,\n    $Gamma, x: A tack.r (lambda y. b(y))(x) equiv b(x): B(x)$,\n    $Gamma, x: A tack.r b(x): B(x)$\n  )\n)\n```\n\nTambin postulamos una regla que afirma que todos los elementos de un $Pi$-tipo son\nfunciones dependientes. Esta es llamada la **$eta$-regla**\n\n```typst\n#prooftree(\n  rule(\n    name: $eta.$,\n    $Gamma tack.r lambda x. f(x) equiv f: Pi_((x: A)) B(x)$,\n    $Gamma tack.r f: Pi_((x: A)) B(x)$\n  )\n)\n```\n\nEn otras palabras, las reglas de computacin ($beta$ y $eta$) para tipos funcin\ndependiente postulan que la regla de $lambda$-abstraccin y la regla de evaluacin son\nmutuamente inversas.\n\n## Tipos funcin ordinarios\n\nUn caso especial de los $Pi$-tipos es cuando $A$ y $B$ son tipos en un contexto $Gamma$.\nEn este caso podemos primero debilitar a $B$ por $A$ y luego aplicar la $Pi$-regla de\nformacin para obtener el tipo $A arrow.r B$ de funciones *ordinarias* de $A$ a $B$, como lo\nmuestra la siguiente derivacin:\n\n```typst\n#prooftree(\n  rule(\n    name: $Pi.$,\n    $Gamma tack.r Pi_((x: A)) B \"type\"$,\n    rule(\n      name: $W$,\n      $Gamma, x: A tack.r B \"type\"$,\n      $Gamma tack.r A \"type\"$,\n      $Gamma tack.r B \"type\"$\n    )\n  )\n)\n```\n\nUn trmino $f: Pi_(x: A) B$ es una funcin que toma un argumento $x: A$ y regresa\n$f(x): B$. As, definimos el tipo $A arrow.r B$ de **funciones (ordinarias)** de $A$ a $B$ por\n$ A arrow.r B := Pi_(x: A) B. $\nSi $f: A arrow.r B$ es una funcin, entonces el tipo $A$ es llamado el **dominio** de $f$ y\nel tipo $B$ es llamado el **co-dominio** de $f$.\n\nA veces tambin escribiremos $B^A$ para el tipo $A arrow.r B$ (haciendo alusin a las\ncategoras). Formalmente, hacemos estas definiciones aadiendo una lnea extra a la\nderivacin de antes:\n\n\n```typst\n#prooftree(\n  rule(\n    name: \".\",\n    $Gamma tack.r A arrow.r B := Pi_((x: A)) B \"type\"$,\n    rule(\n      name: $Pi$,\n      $Gamma tack.r Pi_((x: A)) B \"type\"$,\n      rule(\n        name: \"W\",\n        $Gamma, x: A tack.r B \"type\"$,\n        $Gamma tack.r A \"type\"$,\n        $Gamma tack.r B \"type\"$\n      )\n    )\n  )\n)\n```\n\n\n\u003Cdiv id=\"observacion-2-2-1\">\n\u003CAside type=\"note\" title=\"Observacin 2.2.1\">\nPodemos hacer definiciones al final de una derivacin si la conclusin es un cierto tipo\nen un contexto o si la conclusin es un cierto trmino de un tipo en un contexto.\nSupongamos, por ejemplo, que tenemos la derivacin\n\n```typst\n#prooftree(\n  rule(\n    name: \".\",\n    $Gamma tack.r a: A$,\n    $cal(D)$\n  )\n)\n```\nen la que la derivacin $cal(D)$ hace uso de las premisas $cal(H)_1, dots, cal(H)_n$. Si queremos hacer una definicin $c := a$, entonces podemos extender el\nrbol de derivacin con:\n\n```typst\n#prooftree(\n  rule(\n    name: \".\",\n    $Gamma tack.r c:= a: A$,\n    rule(\n      $Gamma tack.r a: A$,\n      $cal(D)$\n    )\n  )\n)\n```\nEl efecto de una definicin de este tipo es que hemos extendido la teora de tipos con\nuna nueva constante $c$, para la cual las siguientes reglas de inferencia son vlidas\n\n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  prooftree(\n    rule(\n      $Gamma tack.r c: A$,\n      $cal(H)_1$,\n      $cal(H)_2$,\n      $dots$,\n      $cal(H)_n$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r c equiv a: A$,\n      $cal(H)_1$,\n      $cal(H)_2$,\n      $dots$,\n      $cal(H)_n$\n    )\n  )\n)\n```\n\nEn nuestro ejemplo de la definicin del tipo funcin ordinario $A arrow.r B$, tenemos, por\ndefinicin, las siguientes reglas de inferencia vlidas\n\n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  prooftree(\n    rule(\n      $Gamma tack.r A arrow.r B \"type\"$,\n      $Gamma tack.r A \"type\"$,\n      $Gamma tack.r B \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      $Gamma tack.r A arrow.r B equiv Pi_((x: A)) B \"type\"$,\n      $Gamma tack.r A \"type\"$,\n      $Gamma tack.r B \"type\"$\n    )\n  )\n)\n```\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-2-2-2\">\n\u003CAside type=\"note\" title=\"Observacin 2.2.2\">\nAhora podemos dar reglas para el tipo $A arrow.r B$:\n\n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  prooftree(\n    rule(\n      name: $arrow.r$,\n      $Gamma tack.r A arrow.r B \"type\"$,\n      $Gamma tack.r A \"type\"$,\n      $Gamma tack.r B \"type\"$\n    )\n  ),\n  prooftree(\n    rule(\n      name: $lambda$,\n      $Gamma tack.r lambda x. b(x) : A arrow.r B$,\n      $Gamma tack.r B \"type\"$,\n      $Gamma, x: A tack.r b(x): B$\n    )\n  ),\n  prooftree(\n    rule(\n      name: \"ev\",\n      $Gamma, x: A tack.r f(x): B$,\n      $Gamma tack.r f: A arrow.r B$\n    )\n  ),\n  prooftree(\n    rule(\n      name: $beta$,\n      $Gamma, x: A tack.r (lambda y. b(y))(x) equiv b(x)$,\n      $Gamma tack.r B \"type\"$,\n      $Gamma, x: A tack.r b(x): B$\n    )\n  ),\n  prooftree(\n    rule(\n      name: $eta$,\n      $Gamma tack.r lambda x. f(x) equiv f: A arrow.r B$,\n      $Gamma tack.r f: A arrow.r B$\n    )\n  )\n)\n```\n\n\u003C/Aside>\n\u003C/div>\n\nAhora podemos usar estas reglas para construir algunas funciones que nos son familiares\ncomo la funcin identidad $\"id\": A arrow.r A$ sobre un tipo arbitrario $A$ y la composicin\n$g compose f: A arrow.r C$ para cualesquiera dos funciones $f$ y $g$ con dominios y co-dominios\nadecuados.\n\n\u003Cdiv id=\"definicion-2-2-3\">\n\u003CAside type=\"tip\" title=\"Definicin 2.2.3\">\nPara cualquier tipo $A$ en un contexto $Gamma$, definimos la **funcin identidad**\n$\"id\"_A: A arrow.r A$ usando el trmino genrico:\n\u003C/Aside>\n\u003C/div>","src/content/docs/tipos/Rijke/funciones-dependientes.mdx","03d3147b1d37cad6","tipos/rijke/identidad",{"id":172,"data":174,"body":182,"filePath":183,"digest":184,"deferredRender":16},{"title":175,"editUrl":16,"head":176,"template":18,"sidebar":177,"pagefind":16,"draft":20,"sitemap":180},"Tipos identidad",[],{"order":178,"hidden":20,"attrs":179},7,{},{"linkInclusionRules":181},[24],"import { Aside } from '@astrojs/starlight/components';\n    \nDesde la perspectiva de los tipos como proposiciones donde las demostraciones son relevantes, cmo deberamos pensar\nla *igualdad* en la teora de tipos? Dado un tipo $a$, y dos elementos $x,y: A$, la igualdad $x=y$ debe ser de nuevo\nun tipo. En efecto, queremos *usar* la teora de tipos para demostrar igualdades. La teora de tipos dependiente nos\nda un lugar adecuado para esto: el tipo identidad $x=y$ depende de $x, y: A$\n\nEntonces, si $x=y$ va a ser un tipo, cmo deberamos pensar sobre los elementos de $x=y$? Un elemento $p: x = y$\nes un observador de que $x$ y $y$ son elementos iguales de tipo $A$. En otras palabras, $p: x = y$ es una \n*identificacin* de $x$ y $y$. En el mundo donde las demostraciones son relevantes, podra haber muchos elementos \nde tipo $x = y$, es decir, muchas identificaciones de $x$ y $y$. Y como $x = y$ es un tipo, podemos formar el tipo \n$p = q$ para cualesquiera dos identificaciones $p, q: x = y$. Es decir, como $x = y$ es un tipo, en la teora de \ntipos tambin podemos probar cosas sobre las identificaciones y podemos usar la teora de tipos para realizar \nconstrucciones sobre ellas. Como veremos ms adelante, a cada tipo le podemos dar estructura de grupoide.\n\nClaramente, el tipo igualdad no debe ser un tipo cualquiera que dependa de $x, y: A$. Entonces, cmo formamos\nel tipo igualada y qu maneras hay de usar las identificaciones en la teora de tipos? La respuesta a ambas preguntas\nes que formaremos el tipo igualdad como un *tipo inductivo*, generado por un slo elemento reflexivo, que ser una \nidentificacin que identifica a $x$ consigo mismo. El principio de induccin nos dar una manera de realizar \nconstrucciones sobre estas identificaciones, como concatenarlas, invertirlas y dems. As, el tipo identidad \nest equipado con un elemento reflexivo y posee la estructura que se genera por el principio de induccin y la \nteora de tipos. Esta construccin es elegante, hermosamente simple y muy lejos de ser trivial.\n\nLa situacin en la que dos elementos se pueden identificar en ms de una manera es anloga a la situacin en la \nteora de *homotopia*, donde dos puntos de un espacio pueden conectares por ms de una trayectoria. En efecto, para \ncualesquiera dons puntos $x$ y $y$ en un espacio, hay un espacio de *homotopas* entre ellos.\n\n## La definicin inductiva de los tipos identidad\n\n\u003Cdiv id=\"definicion 5.1.1\">\n\u003CAside type=\"tip\" title=\"Definicin 5.1.1\">\nConsideremos un tipo $A$ y sea $a: A$. Entonces definimos el **tipo identidad**  de $A$ en $a$ como la familia \ninductiva de tipos $a attach(a, br: A) x$ indizada por $x: A$, de la cual el constructor es \n$ \"refl\"_a : a attach(=, br: A) a. $\nEl principio de induccin para el tipo identidad postula que para cualquier familia de tipos $P(x, p)$ indizada \npor $x: A$ y $p: a attach(=, br: A) x$, hay una funcin\n$ \"ind-eq\"_a : P(a, \"refl\"_a) arrow Pi_((x: A)) Pi_((p: a attach(=, br: A) x)) P(x, p) $\nque satisface $\"ind-eq\"_a (u, a, \"refl\"_a) equiv u$, dada $u: P(a, \"refl\"_a)$.\n\nUn elemento de tipo $a attach(=, br: A) x$ es tambin llamado una **identificacin** de $a$ con $x$ o una \n**trayectoria** de $a$ a $x$. El principio de induccin para los tipos identidad es a veces llamado \n**eliminacin de identificaciones** o **induccin de trayectorias**. Tambin escribimos $\"Id\"_A$ para el tipo \nidentidad en $A$ y escribimos $a = x$ para el tipo de identificaciones de $a$ con $x$, omitiendo la referencia al \nespacio ambiente $A$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion 5.1.2\">\n\u003CAside type=\"note\" title=\"Observacin 5.1.2\">\nVemos que el tipo identidad no es un tipo inductivo cualquiera, como $NN, emptyset$ y $bold(1)$ por ejemplo, sino \nuna *familia* inductiva de tipos. Aunque tenemos un tipo $a attach(=, br: A) x$ para cada $x: A$, el constructor slo\nnos da un elemento $\"refl\"_a: a attach(=, br: A) a$, que identifica a $a$ consigo mismo. El principio de induccin\nentonces dice que para probar algo sobre todas las identificaciones de $a$ con algn $x: A$, es suficiente probarlo \npara $\"refl\"_a$ solamente. Veremos ms adelante que este principio de induccin es suficientemente fuerte para \nderivar muchos hechos familiares sobre la igualdad, por ejemplo, que es una relacin de equivalencia y que todas \nlas funciones la preservan.\n\n\u003C/Aside>\n\u003C/div>\n\n\n\u003Cdiv id=\"observacion 5.1.3\">\n\u003CAside type=\"tip\" title=\"Observacn 5.1.3\">\nComo los tipos identidad requieren que nos acostumbremos a ellos, damos sus reglas formales. El tipo identidad es \nformado por la regla de formacin\n\n```typst\n#prooftree(\n    rule(\n       $Gamma, x: A tack.r a attach(=, br: A) x \"type\"$,\n       $Gamma tack.r a: A $\n    )\n)\n```\nEl constructor del tipo identidad est dado por la regla de introduccin:\n```typst\n#prooftree(\n    rule(\n       $Gamma tack.r \"refl\"_a : a attach(=, br: A) a$,\n       $Gamma tack.r a: A$\n    )\n)\n```\n\nEl principio de induccin est dado por al regla de eliminacin:\n\n```typst\n#prooftree(\n    rule(\n        $Gamma tack.r \"ind-eq\"_a : P(a, \"refl\"_a) arrow Pi_((x: A)) Pi_((p: a attach(=, br: A) x)) P(x, p)$,\n        $Gamma tack.r a: A$,\n        $Gamma, x: A, p: a attach(=, br: A) x tack.r P(x, p) \"type\"$,\n    )\n)\n```\nY finalmente, la regla de computacin es:\n\n```typst\n#prooftree(\n    rule(\n       $Gamma, u: P(a, \"refl\"_a) tack.r \"ind-eq\"_a (u, a, \"refl\"_a) equiv u: P(a, \"refl\"_a)$,\n       $Gamma tack.r a: A$,\n       $Gamma, x: A, p: a attach(=, br: A) x tack.r P(x, p) \"type\"$\n    )\n)\n```\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion 5.1.4\">\n\u003CAside type=\"note\" title=\"Observacin 5.1.4\">\n\nUno podra preguntarse si es posible formar el tipo identidad en un tipo *variable* de tipo $A$, en lugar de un \nelemento. Esto es ciertamente posible: como podemos formar el tipo identidad en cualquier contexto, podemos \nformar el tipo identidad en una variable $x: A$ como sigue:\n\n```typst \n#prooftree(\n    rule(\n       $Gamma, x: A, y: A tack.r x attach(=, br: A) y \"type\"$,\n       $Gamma, x: A tack.r x: A$\n    )\n)\n```\nDe esta manera, obtenemos el tipo identidad \"binario\". Su constructor es tambin indizado por $x: A$. Tenemos \nla siguiente regla de introduccin \n```typst\n#prooftree(\n    rule(\n       $Gamma, x: A tack.r \"refl\"_x : x attach(=, br: A) x$,\n       $Gamma, x: A tack.r x: A$\n    )\n)\n```\ny similarmente tenemos reglas de eliminacin y computacin.\n\u003C/Aside>\n\u003C/div>\n\n\n## La estructura de grupoide de los tipos\n\nMostraremos que las identificaciones pueden ser *concatenadas* e *invertidas*, lo que corresponde a la transitividad\ny simetra del tipo identidad.\n\n\u003Cdiv id=\"definicion 5.2.1\">\n\u003CAside type=\"note\" title=\"Definicin 5.2.1\">\nSea $A$ un tipo. Definimos la operacin de **concatenacin**\n$ \"concat\": Pi_((x, y, z: A)) (x = y) arrow ((y = z) arrow (x = z)) $\nEscribiremos $p dot q$ para $\"concat\"(p, q)$.\n\n*Construccin* Primero construimos una funcin\n$ f(x) : Pi_((y: A)) (x = y) arrow Pi_((z: A)) (y = z) arrow (x = z) $\npara cada $x: A$. Por el principio de induccin para tipos identidad, basta construir \n$ f(x, x, \"refl\"_x): Pi_((z: A)) (x = z) arrow (z = z). $\nAqu, tenemos la funcin $lambda z. \"id\"_ ((x = Z))$. La funcin $f(x)$ que obtenemos va eliminacin de identidades \nest explcitamente definida como \n$ f(x) := \"ind-eq\"_(x) (lambda z. \"id\") : Pi_((y: A)) (x = y) arrow Pi_((z: A)) (y = z) arrow (x = z). $\n\nPara terminar la construccin de concat, usamos el ejercicio 4.2 para cambiar el orden de la tercera y cuarta variable\nde $f$, es decir, definimos \n$ \"concat\"_ (x, y, z) (p, q) := f(x, y, p, z, q) $ \n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-5-2-2\">\n\u003CAside type=\"tip\" title=\"Definicin 5.2.2\">\nSea $A$ un tipo. Definimos la **operacin de inversin**\n$ \"inv\": Pi_((x, y: A)) (x = y) arrow (y = x) $\n\nLa mayora de las veces escribimos $p^(-1)$ en lugar de $\"inv\"(p)$.\n\n*Construccin* Por el principio de induccin para tipos identidad, es suficiente construir \n$ \"inv\" (\"refl\" _x): x = x $\npara cada $x: A$. As, tomamos $\"inv\"(\"refl\") _x := \"refl\" _x$.\n\u003C/Aside>\n\u003C/div>\n\nLa siguiente pregunta es si las operaciones de concatenacin e inversin sobre identificaciones se comportan como \nesperamos. Ms concretamente: es la concatenacin de identificaciones asociativa?, satisface las leyes de \nunidad?, es el inverso de una identificacin inverso por ambos lados?\n\nPor ejemplo, en el caso de la asociatividad, estamos comparando las identificaciones \n$ (p dot q) dot r \" y \" p dot (q dot r) $\npara cualesquiera $p: x = y$, $q: y = z$ y $r: z = w$ en un tipo $A$. Las reglas de computacin para el tipo \nidentidad no son lo suficientemente fuertes para probar que $(p dot q) dot r$ y $p dot (q dot r)$ son juiciosamente\niguales. Sin embargo, $(p dot q) dot r$ y $p dot (q dot r)$ son elementos del mismo tipo, ambos son identificaciones \nde tipo $x = w$. Como el tipo identidad es un tipo como cualquier otro, podemos preguntarnos si hay una \n*identificacin*\n$ (p dot q) dot r = p dot (q dot r). $\nEsta es una idea muy til: aunque a veces es imposible mostrar que dos elementos del mismo tipo son iguales en juicio,\npuede ser posible que esos elementos puedan ser *identificados*. En efecto, identificamos dos elementos construyendo\nun elemento del tipo identidad y podemos usar toda la teora de tipos a nuestra disposicin para construir dicho \nelemento. De esta manera, podemos mostrar, por ejemplo, que la adicin en los nmeros naturales o en los enteros\nes asociativa y satisface las leyes de la unidad. Aqu mostraremos que la concatenacin de identificaciones es \nasociativa y satisface las leyes de la unidad.\n\n\u003Cdiv id=\"definicion-5-2-3\">\n\u003CAside type=\"tip\" title=\"Definicin 5.2.3\">\nSea $A$ un tipo y consideremos tres identificaciones consecutivas \n$ x =^p y =^q z =^r w $\nen $A$. Definimos el *asociador* \n$ \"assoc(p, q, r)\": (p dot q) dot r = p dot (q dot r) $\n\n*Construccin* Por el principio de induccin para tipos identidad, es suficiente probar que\n$ Pi_((z: A)) Pi_((q: x = z)) Pi_((w: A)) Pi_((r: z=w)) (\"refl\" _x dot q) dot r  = \"refl\" _x dot (q dot r) $\nSea $q: x = z$ y $r: z = w$. Notemos que por la regla de computacin para tipos identidad, tenemos una igualdad \njuiciosa $\"refl\" _x dot q equiv q$. Entonces concluimos que \n$ (\"refl\" _x dot q) dot r equiv q dot r $\nSimilarmente, tenemos la igualdad juiciosa $\"refl\" _x dot (q dot r) equiv q dot r$. As, vemos que el lado \nizquierdo y el lado derecho en \n$ (\"refl\" _x dot q) dot r = \"refl\" _x dot (q dot r) $\nson juiciosamente iguales, de modo que simplemente podemos definir $\"assoc\"(\"refl\" _x, q, r) := \"refl\" _(q dot r)$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-5-2-4\">\n\u003CAside type=\"tip\" title=\"Definicin 5.2.4\">\nSea $A$ un tipo. Definimos las operaciones de *leyes de unidad* derecha e izquierda, que asignan a cada $p: x = y$\nlas identificaciones\n$ \"left-unit\"(p) : \"refl\" _x dot p = p $\n$ \"right-unit\"(p) : p dot \"refl\" _x. $\nrespectivamente.\n\n*Construccin* Por eliminacin de identificaciones, es suficiente construir \n$ \"left-unit\"(\"refl\" _x): \"refl\" _x dot \"refl\" _x = \"refl\" _x $\n$ \"right-unit\"(\"refl\" _x): \"refl\" _x dot \"refl\" _x = \"refl\" _x. $\nen ambos casos, tomamos $\"refl\" _(\"refl\" _x)$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-5-2-5\">\n\u003CAside type=\"tip\" title=\"Definicin 5.2.5\">\nSea $A$ un tipo. Definimos las *leyes de inversin* derechas e izquierdas \n$ \"left-inv\"(p): p^(-1) dot p = \"refl\" _y $\n$ \"right-inv\"(p): p dot p^(-1) = \"refl\" _x $\n\n*Construccin* Por eliminacin de identificaciones, es suficiente probar \n$ \"left-inv\"(\"refl\" _x): \"refl\"^(-1) _(x) dot \"refl\" _x = \"refl\" _x $\n$ \"right-inv\"(\"refl\" _x): \"refl\" _x dot \"refl\"^(-1) _x = \"refl\" _x $\nUsando las reglas de computacin vemos que \n$ \"refl\"^(-1) _x dot \"refl\" _x equiv \"refl\" _x dot \"refl\" _x equiv \"refl\" _x, $\nde modo que definimos $\"left-inv\" (\"refl\" _x) := \"refl\" _(\"refl\" _x)$. Similarmente, se sigue de las reglas de \ncomputacin que \n$ \"refl\" _x dot \"refl\"^(-1) _x equiv \"refl\"^(-1) _x equiv \"refl\" _x $\nAs que definimos $\"right-inv\" (\"refl\" _x) := \"refl\" _(\"refl\" _x)$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-5-2-6\">\n\u003CAside type=\"note\" title=\"Observacin 5.2.6\">\nHemos visto que el asociador, las leyes de la unidad y las leyes de la inversin todas se demuestran \nconstruyendo una identificacin de identificaciones. Y, por supuesto, no hay nada que nos detenga de considerar\nidentificaciones de esas identificaciones. Podemos ir tan arriba como queramos en la torre de los *tipos identidad*,\nque se obtiene tomando tipos identidad de forma iterada.\nLos tipos identidad iterados dan tipos en la teora homotpica de tipos que tienen una estructura muy intricada.\nUna forma importante de estudiar esta estructura es mediante los grupos de homotopa de los tipos, algo que poco a \npoco iremos construyendo.\n\u003C/Aside>\n\u003C/div>\n\n## La accin de las funciones sobre las identificaciones\nUsando el principio de induccin de los tipos identidad, podemos mostrar que toda funcin preserva las \nidentificaciones. En otras palabras, toda funcin manda elementos identificados a objetos identificados. Notemos\nque esta es una forma de continuidad para funciones en la teora de tipos: si hay una identificacin que \nidentifica dos puntos $x$ y $y$ de un tipo $A$, entonces tambin hay una identificacin entre los valores \n$f(x)$ y $f(y)$ en el co-dominio de $f$.\n\n\u003Cdiv id =\"definicion-5-3-1\">\n\u003CAside type=\"tip\" title=\"Defincin 5.3.1\">\nSea $f: A arrow B$ una funcin. Definimos la **accin sobre trayectorias** de $f$ como una \noperacin \n$ \"ap\"_f : Pi_((x, y: A)) (x = y) arrow (f(x) = f(y)). $\n\nAdems, hay operaciones \n\n$ \"ap-id\"_A : Pi_((x, y: A)) Pi_((p: x = y)) \"ap\"_(\"id\"_A) (p) $\n\n$ \"ap-comp\" (f, g) : Pi_((x, y: A)) Pi_((p: x = y)) \"ap\" _g (\"ap\" _f (p)) = \"ap\" _(g compose f) (p) $\n\n*Construccin* Primero definimos $\"ap\"_f$ por el principio de induccin para tipos identidad,\ntomando \n$ \"ap_f\" (\"refl\"_x) := \"refl\"_(f(x)). $\n\nLuego, construimos $\"ap-id\"_A$ por el principio de induccin para tipos identidad, tomando \n$ \"ap-id\"_A (\"refl\"_x) := \"refl\"_(\"refl\"_x). $\n\nFinalmente, construimos $\"ap-comp\" (f, g)$ por el principio de induccin para tipos \nidentidad, tomando \n$ \"ap-comp\" (f, g, \"refl\"_x) := \"refl\"_(\"refl\"_(g(f(x)))) $\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-5-3-2\">\n\u003CAside type=\"tip\" title=\"Defincin 5.3.2\">\nSea $f: A arrow B$ una funcin. Entonces hay identificaciones\n$ \"ap-refl\" (f, x) : \"ap\"_f (\"refl\"_x) = \"refl\"_(f(x)) $\n$ \"ap-inv\" (f, p): \"ap\"_f (p^(-1)) = \"ap\"_f (p)^(-1) $\n$ \"ap-concat\" (f, p, q): \"ap\"_f (p dot q) = \"ap\"_f (p) dot \"ap\"_f (q) $\npara cada $p: x = y$ y $q: x = y$.\n\n*Construccin* Para construir $\"ap-refl\" (f, x)$ simplemente observamos que \n$\"ap\"_f (\"refl\"_x) equiv \"refl\"_(f(x))$, as que tomamos \n\n$ \"ap-refl\" (f, x) := \"refl\"_(\"refl\"_(f(x))). $\n\nConstruimos $\"ap-inv (f, p)\"$ por eliminacin de identificaciones sobre $p$, tomando \n$ \"ap-inv\" (f, \"refl\"_x) := \"refl\"_(\"ap\"_f (\"refl\")) $\n\nFinalmente, construimos $\"ap-concat\" (f, p, q)$ por eliminacin de identificaciones sobre \n$p$, tomando \n\n$ \"ap-concat\" (f, \"refl\"_x, q) := \"refl\"_(\"ap\"_f (q)). $\n\u003C/Aside>\n\u003C/div>\n\n## Transporte\n\nLos tipos dependientes tamben bienen con una accin sobre las identificaciones, las\nfunciones de *transporte*. Dada una identificacin $p: x = y$ en el tipo base $A$, podemos \ntransportar cualquier elemento $b: B(x)$ a la fibra $B(y)$.\n\n\u003Cdiv id=\"definicion-5-4-1\">\n\u003CAside type=\"tip\" title=\"Definicin 5.4.1\">\nSea $A$ un tipo y $B$ una familia de tipos sobre $A$. Construiremos una operacin de \n*transporte* \n\n$ \"tr\"_B: Pi_((x, y: A)) (x = y) arrow (B(x) arrow B(y)) $\n\n*Construccin* Construimos $\"tr\"_B (p)$ por induccin sobre $p: x attach(=, br: A) y$, \ntomando $ \"tr\"_B (\"refl\"_x):= \"id\"_(B(x)). $\n\u003C/Aside>\n\u003C/div>\n\nAs, vemos que la teora de tipos no puede distinguir entre elementos identificados $x$ y \n$y,$ pues para cada familia de tipos $B$ sobre $A$, se obtiene un elemento de $B(y)$ a \npartir de los elementos de $B(x)$.\n\nComo una aplicacin de la funcin de transporte, podemos construir la accin *dependiente*\nsobre trayectorias de una funcin dependiente $f: Pi_((x: A)) B(x)$. Notemos que para\nuna funcin dependiente $f$ de este tipo y una identificacin $p: x attach(=, br: A) y$, \nno hace sentido comparar directamente a $f(x)$ y $f(y)$, pues el tipo de $f(x)$ es $B(x)$,\nmientras que el tipo de $f(y)$ es $B(y)$, que puede no ser el mismo tipo. Sin embargo, \npodemos primero *transportar* $f(x)$ a lo largo de $p$, de modo que obtengamos el elemento\n$\"tr\"_B (p, f(x))$ que es de tipo $B(y)$. Ahora podemos preguntarnos si sucede que \n$\"tr\"_B (p, f(x)) = f(y)$. La accin dependiente sobre trayectorias de $f$ establece esta \nidentificacin.\n\n\u003Cdiv id=\"definicion-5-4-2\">\n\u003CAside type=\"tip\" title=\"Definicin 5.4.2\">\nDada una funcin dependiente $f: Pi_((a: A)) B(a)$ y una identificacin $p: x = y$ en $A$,\npodemos construir una identificacin \n\n$ \"apd\"_f (p): \"tr\"_B (p, f(x)) = f(y). $\n\n*Construccin* La identificacin $\"apd\"_f (p)$ se construye por el principio de induccin \npara tipos identidad. As, es suficiente construir una identificacin \n\n$ \"apd\"_f (\"refl\"_x): \"tr\"_B (\"refl\"_x, f(x)) = f(x). $\n\nComo transportar a lo largo de $\"refl\"_x$ es la funcin identidad en $B(x)$, simplemente \n  tomamos $\"apd\"_f (\"refl\"_x) := \"refl\"_(f(x))$.\n\u003C/Aside>\n\u003C/div>\n\n## La unicidad de refl\n\nEl tipo indentidad es una *familia* inductiva de tipos. Esto tiene unas implicaciones\nsutiles pero importantes. Por ejemplo, mientras que el tipo $a = x$ indizado por $x: A$\nes indutivamente generado por $\"refl\"_a$, el tipo #$a = a$ *no* est inductivamente \ngenerado por $\"refl\"_a$. As que no podemos usar el ptincipio de de induccin de los tipos \nidentidad para mostrar que $p = \"refl\"_a$ para cualquier $p: a = a$. El obstculo que \nno nos permite aplicar el principio de induccin para tipos identidad en este caso es que \nel extremo $p: a = a$ no es libre.\n\nSin embargo, el tipo $a = x$ est genereado por un solo elemento $\"refl\"_a : a = a$, as que \nes natural preguantarse en qu sentido es la identificacin $\"refl\"$ nica. Una\nidentificacin con un elemento $a$ est especificada dando primero el extremo $x$ con el que \nse busca identificar a $a$ y luego dando la identificacin $p: a = x$. Entonces lo que \nes nico es el par $(a, \"refl\"_a)$ en el tipo de todos los pares\n\n$ (x, p): Sigma_((x: A)) a = x $\n\nProbamos este hecho en la siguiente proposicin.\n\n\u003Cdiv id=\"proposicion-5-5-1\">\n\u003CAside type=\"tip\" title=\"Proposicin 5.5.1\">\nConsideremos un elemento $a: A$. Entonces hay una identificacin \n\n$ (a, \"refl\"_a) = y $\nen el tipo $Sigma_((x: A)) a = x$, para cualquier $y: Sigma_((x: A)) a = x$.\n\n*Demostracin* Por $Sigma$-induccin, basta probar que hay una identificacin \n\n$ (a, \"refl\"_a) = (x, p) $\n\npara cada $x: A$ y $p: a = x$. Procedemos mediante el principio de induccin para tipos \nidentidad. As, basta probar que \n\n$ (a, \"refl\"_a) = (a, \"refl\"_a) $\n\nlo cual se obtiene mediante reflexividad.\n\u003C/Aside>\n\u003C/div>\n\nLa proposicin [5.5.1](#proposicion-5-5-1) muestra que, salvo identificaciones, hay un slo \nelemento en el $Sigma$-tipo del tipo identidad. A estos tipos les llamamos contraibles.\n\n\n## Las leyes de adicin en \n\nAhora que hemos introducido el tipo indentidad, podemos empezar a probar ecuaciones.\nProbaremos que hay identificaciones \n\n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  $0 + n = n$,\n  $m + 0 = m$,\n  $\"succ\" _NN (m) + n = \"succ\" _NN (m + n)$,\n  $m + \"succ\" _NN (n) = \"succ\" _NN (m + n)$,\n  $(m + n) + k = m + (n + k)$,\n  $m + n = n + m$\n)\n```\nLas leyes de la unidad, asociatividad y conmutatividad son, por supuesto, familiares. Las \nleyes del sucesor sern tiles para probar la conmutatividad. En el ejecrcicio 5.5 se nos \npedir probar las leyes de la multiplicacin en $NN$. De nuevo, habr *leyes del sucesor*\ncomo parte del ejercicio, pues son pasos intermedios tiles en las leyes ms complicadas.\n\nRecordemos que la adicin en los nmeros naturales est definida de tal manera que \n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  $m + 0 equiv  m$,\n  $m + \"succ\" _NN (n) = \"succ\" _NN (m + n)$\n)\n```\n\nEstas dos igualdades juiciosas es todo lo que sabemos hasta ahora sobre la funcon \n$m, n mapsto m + n$ en $NN$. En consecuancia, tenemos que encontrar maneras de aplicar estas \ndos igualdades juiciosas en nuestras pruebas de las leyes de la adicin. Por supuesto, las \nigualdades juiciosas coinciden con dos de las leyes de la adicin. Para las leyes restantes, \nnecesitaremos proceder por induccin en $NN$.\n\n\u003Cdiv id=\"proposicion-5-6-1\">\n\u003CAside type=\"tip\" title=\"Proposicin 5.6.1\">\n\nPara cada nmero natural $n$, hay identificaciones \n$ \"left-unit-law-add\" _NN (n): 0 + n = n $\n$ \"right-unit-law-add\" _NN (n): n + 0 = n. $\n\n*Demostracin* Podemos definir \n\n$ \"right-unit-law-add\" _NN (n) := \"refl\"_n, $\n\nPues la regla de computacin para la adicin nos da que $n + 0 equiv 0$.\nFalta definir la ley de unidad izquierda. Procedemos por induccin sobre $n$. En le caso \nbase, necesistamos probar que $0 + 0 = 0$, lo cual se sigue por reflexividad. Para el paso \ninductivo, asumimos que tenemos una identificacin $p: 0 + n = n$. Nuestra meta es mostrar \nque $0 + \"succ\" _NN (n) = \"succ\" _NN (n)$. Sin emabrgo, es suficient construir una \nidentificacin \n\n$ \"succ\" _NN (0 + n) = \"succ\" _NN (n), $\n\npues, por la regla de computacin para la adicin, tenemos que \n$0 + \"succ\" _NN (n) equiv \"succ\" _NN (0 + n)$. Ahora usamos la accin sobre trayectorias \nde $\"succ\" _NN: NN arrow NN$ para obtener \n\n$ \"ap\"_(\"succ\"_NN (p)): \"succ\" _NN (0 + n) = \"succ\" _NN (n). $\n\nDe este modo, la ley de unidad izquierda se define por \n\n$ \"left-unit-law-add\" _NN (n) := \"ind\" _NN (\"refl\" _0, lambda p.\"ap\" _(\"succ\" _NN) (p)) $\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"proposicion-5-6-2\">\n\u003CAside type=\"tip\" title=\"Porposicin 5.6.2\">\n\nPara cualesquiera nmeros naturales $m$ y $n$, hay identificaciones \n\n$ \"left-successor-law-add\" _NN (m, n): \"succ\" _NN (m) + n = \"succ\" _NN (m + n) $\n$ \"right-successor-law-add\" _NN (m, n): m + \"succ\" _NN (n) = \"succ\" _NN (m + n) $\n\n*Demostracin* Podemos definir \n\n$ \"right-successor-law-add\" _NN (m, n) := \"refl\" _(\"succ\" _NN (m + n)) $\n\npues tenemos la igualdad juiciosa $m + \"succ\" _NN (n) equiv \"succ\" _NN (m + n)$ por las \nreglas de computacin para $\"add\" _NN$.\n\nLa ley del sucesor izquierdo se construye por induccin sobre $n$. En el caso base, tenemos\nque construir una identificacin $\"succ\" _NN (m) + 0 = \"succ\" _NN (m + 0)$, que es obtenida \nmediante reflexividad. Para el paso inductivo, supongamos que tenemos una identificacin \n$p: \"succ\" _NN (m) + n = \"succ\" _NN (m + n)$. Nuestra meta es demostrar que \n\n$ \"succ\" _NN (m) + \"succ\" _NN (n) = \"succ\" _NN (m + \"succ\" _NN (n)). $\n\nNotemos que tenemos las igualdades juiciosas \n\n```typst \n#table(\n  stroke: none,\n  columns: 1,\n  $\"succ\" _NN (m) + \"succ\" _NN (n) equiv \"succ\" _NN (\"succ\" _NN (m) + n)$,\n  $\"succ\" _NN (m + \"succ\" _NN (n)) equiv \"succ\" _NN (\"succ\" _NN (m + n))$\n)\n```\nAs que basta construir una identificacin \n\n$ \"succ\" _NN (\"succ\" _NN (m) + n) = \"succ\" _NN (\"succ\" _NN (m + n)). $\n\nEsta identificacin est dada por $\"ap\"_(\"succ\"_ NN (p))$.\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"proposicion-5-6-3\">\n\u003CAside type=\"tip\" title=\"Proposicin 5.6.3\">\n\nLa adicin de los nmeros naturales es asociativa, es decir, para cualesquiera tres nmeros \nnaturales $m, n$ y $k$, hay una identificacin \n\n$ \"associative-add\" _NN (m, n, k) : (m + n) + k = m + (n + k). $\n\n*Demostracin* Construimos $\"associative-add\" _NN (m, n, k)$ por induccin sobre $k$. En el \ncaso base, tenemos las igualdades juiciosas \n\n$ (m + n) + 0 equiv m + n equiv m + (n + 0). $\n\nAs que definimos $\"associative-add\" _NN (m, n, 0) := \"refl\" _(m + n)$.\n\nPara el paso inductivo,j sea $p: (m + n) + k = m + (n + k)$. Nuestra meta es mostrar que \n\n$ (m + n) + \"succ\" _NN (k) = m + (n + \"succ\" _NN (k)). $\n\nNotemos que tenemos las igualdades juiciosas \n\n$ \n  (m  + n) + \"succ\" _NN (k) &equiv \"succ\" _NN ((m + n) + k) \\\\\n  m + (n + \"succ\" _NN (k))  &equiv  m + (\"succ\" _NN (n + k)) \\\\\n                            &equiv \"succ\" _NN (m + (n + k)) \n$ \n\nAs que es suficiente construir una identificacin \n\n$ \"succ\" _NN ((m + n) + k) = \"succ\" _NN (m + (n + k)),  $\n\nque ya tenemos por $\"ap\" _(\"succ\" _NN ) (p)$\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"proposicion-5-6-4\">\n\u003CAside type=\"tip\" title=\"Proposicin 5.6.4\">\n\nLa adicin sobre los nmeros naturales es conmutativa, es decir, para cualesquiera nmeros \nnaturales $n$ y $m$ hay una identificacin \n\n$ \"commutative-add\" _NN (m, n): m + n = n + m. $\n\n*Demostracin* Construimos $\"commutative-add\" _NN (m, n)$ por induccin sobre $m$. En el \ncaso base, tenemos que mostrar que $0 + n = n + 0$, lo cual es cierto por las leyes de la \nunidad para $n$ demostradas en la proposicin [5.6.1](#proposicion-5-6-1).\n\nPara el paso inductivo, sea $p: m + n = n + m$. Nuestra meta es construir una identificacin\n$\"succ\" _NN (m) + n = n + \"succ\" _NN (m)$. Ahora, es claro porqu probamos las leyes del \nsucesor primero:\n$ \n  \"succ\" _NN (m) + n &= \"succ\" _NN (m + n) \\\\\n                     &= \"succ\" _NN (n + m) \\\\\n                     &= n + \"succ\" _NN (m).\n$\n\nLa primera identificacin se obtuvo de la proposicin [5.6.2](#proposicion-5-6-2), y la \nsegunda identificacin es la identificacin $\"ap\" _(\"succ\" _NN) (p)$.\n\n\u003C/Aside>\n\u003C/div>","src/content/docs/tipos/Rijke/identidad.mdx","fc734d7ae85597a0","tipos/rijke",{"id":185,"data":187,"body":194,"filePath":195,"digest":196,"deferredRender":16},{"title":188,"editUrl":16,"head":189,"template":18,"sidebar":190,"pagefind":16,"draft":20,"sitemap":192},"Introduccin a la teora homotpica de tipos",[],{"order":130,"hidden":20,"attrs":191},{},{"linkInclusionRules":193},[24],"import { LinkButton } from '@astrojs/starlight/components';\n\n## Notas\nEstas son mis notas sobre el libro \"Introduccin a la teora de tipos\" de Rijke.\n\n\u003CLinkButton href=\"./dependiente\" icon=\"right-arrow\"> Teora de tipos dependiente \u003C/LinkButton>\n\u003CLinkButton href=\"./funciones-dependientes\" icon=\"right-arrow\"> Funciones dependientes \u003C/LinkButton>","src/content/docs/tipos/Rijke/index.mdx","210aa2959fc1630e","tipos/rijke/inductivo",{"id":197,"data":199,"body":206,"filePath":207,"digest":208,"deferredRender":16},{"title":200,"editUrl":16,"head":201,"template":18,"sidebar":202,"pagefind":16,"draft":20,"sitemap":204},"Ms tipos inductivos",[],{"order":91,"hidden":20,"attrs":203},{},{"linkInclusionRules":205},[24],"import { Aside } from '@astrojs/starlight/components';\n\n## La idea de los tipos inductivos\n\nLos tipos inductivos se especifican por sus _constructores_, un _principio de \ninduccin_ y sus _reglas de computacin_:\n\n1. Los constructores dicen qu estructura tiene el tipo inductivo. Puede haber una \n  cantidad finita de constructores, inclusive ninguno, en la especificacin de \n  un tipo inductivo.\n2. El principio de induccin especifica qu datos se deben dar para construir una \n  seccin de una familia de tipos arbitraria sobre el tipo inductivo. La idea es \n  siempre la misma: para definir una funcin dependiente $f: Pi_((x: A)) B(x)$ \n  necesitamos especificar el comportamiento de $f$ en los constructores de $A$.\n3. Las reglas de computacin afirman que la seccin definida inductivamente concuerda\n  en los constructores con los datos que se usaron para definir la seccin. As, \n  hay una regla de computacin para cada constructor.\n\n## El tipo unidad\n\nUn ejemplo sencillo de tipo inductivo es el _tipo unidad_ que tiene un slo \nconstructor. Su principio de induccin es anlogo a slo el caso base del principio \nde induccin para los naturales.\n\n\u003Cdiv id=\"definicion-4-2-1\">\n\u003CAside type=\"tip\" title=\"Definicin 4.2.1\">\nDefinimos el *tipo unidad* como un tipo *1* equipado con un trmino \n$ star : 1, $\nque satisface el principio de induccin que dice que para cada familia de tipos \n$P(x)$ indizada por $star: 1$, hay una funcin \n$ \"ind\"_1 : P(star) arrow.r Pi_((x: 1)) P(x) $\npara la cual, la regla de computacin \n$ \"ind\"_1 (p, star) equiv p $\n\nse cumple. De forma alternativa, una definicin de una funcin dependiente \n$f: Pi_((x: 1)) P(x)$ por induccin usando $p: P(star)$ puede presentarse va \npatrones como \n$ f(star) := p. $\n\u003C/Aside>\n\u003C/div>\n\nUn caso especial de principio de induccin es cuando $P$ no depende de *1*. Si nos dan\nun tipo $A$, podemos debilitarlo para obtener una familia constante sobre *1* con \nvalor $A$. Entonces el principio de induccin del tipo unidad nos da una funcin \n$ \"ind\"_1 : A arrow (1 arrow  A) $\nEn otras palabras, el principio de induccin para el tipo unidad nos da para cada \n$x: A$ una funcin $\"pt\"_x := \"ind\"_1(x): bold(1) arrow A$.\n\n## El tipo vaco\n\nEl tipo vaco es un caso degenerado de un tipo inductivo. No viene equipado con \nningn constructor, y por tanto, no tiene reglas de computacin. El principio de \ninduccin meramente dice que toda familia de tipos tiene una seccin. En otras\npalabras: si asumimos que el tipo vaco tiene un trmino, entonces podemos probar\ncualquier cosa.\n\n\u003Cdiv id=\"definicion-4-3-1\">\n\u003CAside type=\"tip\" title=\"Definicin 4.3.1\">\nDefinimos el *tipo vaco* como un tipo $emptyset$ que staisface el principio de \ninduccin que dice que para cada familia de tipos $P(x)$ indizada por $x: emptyset$,\nhay un trmino \n$ \"ind\"_emptyset : Pi_((x: emptyset)) P(x) $\nDe nuevo, es un caso especial del principio de induccin que tengamos una funcin \n$ \"ex-falso\":= \"ind\"_emptyset : emptyset arrow A $\npara cada tipo $A$. Para obtener esta funcin, primero debilitamos $A$ para obtener\nuna familia constante sobre $emptyset$ con valor $A$, y luego el principio de \ninduccin da la funcin deseseada. La funcin ex-falso puede usarse para derivar \ncualquier consclusin despus de derivar una contradiccin.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-4-3-2\">\n\u003CAside type=\"tip\" title=\"Definicin 4.3.2\">\nPra cada tipo $A$ definimos la *negacin* de $A$ como \n$ not A := A arrow emptyset. $\nTambin decimos que un tipo $A$ *est vaco* si viene equipado con un elemento\nde tipo $not A$. As, definimos \n$ \"is-empty\"(A) := A arrow emptyset. $\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-4-3-3\">\n\u003CAside type=\"note\" title=\"Observacin 4.3.3\">\nComo $not A$ es el tipo de funciones de $A$ en $emptyset$, una demostracin de \n$not A$ se da asumiendo que se cumple $A$ y luego construyendo un elemento del \ntipo vaco. En otras palabras, demostramos $not A$ asumiendo $A$ y derivando una \ncontradiccin. Este estilo de demostracin se llama *prueba de negacin*.\n\nLas pruebas de negacin no deben confundirse con las demostraciones por contradiccin.\nIncluso si una demostracin de negacin involucra llegar a una contradiccin, en \nlgica, una *demostracin por contradiccin* de una proposicin $P$ es un argumento \nen el que concluimos que $P$ se cumple despus de mostrar que $not P$ implica una \ncontradiccin. En otras palabras, una demostracin por contradiccin usa el paso \nlgico $not not P arrow.double P$, que tambin es llamado *eliminacin de la doble\nnegacin*.\nEn la teora de tipos, el tipo $not not A$ es el tipo de funciones \n$ (A arrow emptyset) arrow emptyset. $\nEste tipo es muy distinto del tipo $A$, y con las reglas de la teora de tipos no \nes posible construir una funcin $not not A arrow A$ a menos que sepamos ms cosas \nsobre $A$. \n\u003C/Aside>\n\u003C/div>\n\nEn la siguiente proposicin mostramos como trabajar con la definicin de la negacin.\n\n\u003Cdiv id=\"proposicion-4-3-4\"> \n\u003CAside type=\"tip\" title=\"Proposicin 4.3.4\" >\nPara cualesquiera dos tipos $P$ y $Q$, hay una funcin \n$ (P arrow Q) arrow (not Q arrow not P) $ \n\n_Demostracin._ La funcin deseada es definida por $lambda$-abstraccin, as que \nempezamos asumiendo que tenemos una funcin $f: P arrow Q$. Luego, tenemos que \nconstruir una funcin $not Q arrow not P$, que tambin es construida mediante \n$lambda$-abstraccin. Asumimos que tenemos $tilde(q): not Q$. Por nuestra definicin\nde $not Q$, $tilde(q)$ es una funcin $Q arrow emptyset$. Ahora debemos construir\nun trmino de tipo $not P$, que es el tipo de funciones $P arrow emptyset$.\nAplicamos $lambda$-abstraccin una vez ms, as que asumimos $p: P$. Ahora tenemos \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $f: P arrow Q$,\n  $tilde(q): Q arrow emptyset$,\n  $p: P,$\n)\n```\n\nComo tenemos $f: P arrow Q$ y $p: P$, obtenemos $f(p): Q$. Tambin, tenemos \n$tilde(q): Q arrow emptyset$, as obtenemos $tilde(q)(f(p)): emptyset$. Esto completa\nla prueba. La funcin que construimos es \n$ lambda f. lambda tilde(q). lambda p. tilde(q)(f(p)): (P arrow Q) arrow (not Q arrow not P) $\n\u003C/Aside>\n\u003C/div>\n\n## Co-productos\n\n\u003Cdiv id=\"definicion-4-4-1\">\n\u003CAside type=\"tip\" title=\"Definicin 4.4.1\">\nSean $A$ y $B$ tipos. Definimos el *co-producto+ $A + B$ como un tipo que viene \nequipado con \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $\"inl\": A arrow A + B$,\n  $\"inr\": B arrow A + B,$\n)\n```\nque satisface el principio de induccin que dice que para cada familia de \ntipos $P(x)$ indizada por $x: A + B$, existe un trmino \n\n$ \"ind\"_+ : (Pi_((x: A)) P(\"inl\"(x))) arrow ((Pi_((y: B)) P(\"inr\"(y))) arrow Pi_((z: A + B)) P(z))$\n\npara el cual las reglas de computacin \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $\"ind\"_+ (f, g, \"inl\"(x)) equiv f(x)$,\n  $\"ind\"_+ (f, g, \"inr\"(y)) equiv g(x)$\n)\n```\nse cumplen. Alternativamente, una definicin de una funcin dependiente \n$h: Pi_((x: A + B)) P(x)$ por induccin usando $f: Pi_((x: A)) P(\"inl\"(x))$ y \n$g: Pi_((y: B)) P(\"inr\"(y))$ puede presentarse va patrones como \n\n$ h(\"inl\"(x)) := f(x)  $\n$ h(\"inr\"(y)) := g(y). $\n\nA veces escribimos $[f, g]$ en lugar de la funcin $\"ind\"_+ (f, g)$. El co-producto de\ndos tipos es tambin llamado *suma disjunta*.\n\u003C/Aside>\n\u003C/div>\n\nPor el principio de induccin para co-productos, obtenemos una funcin \n\n$ \"ind\"_+ : (A arrow X) arrow ((B arrow X) arrow (A + B arrow X)) $\n\npara cualquier tipo $X$. Notemos que este caso especial del principio de induccin \npara co-productos es muy similar a la regla de eliminacin de la disyuncin en\nla lgica de primer orden: si $P$, $P'$ y $Q$ son proposiciones, entonces \n$ (P arrow Q) arrow ((P' arrow Q) arrow (P or P' arrow Q)) $\nEn efecto, podemos pensar en las _proposiciones como tipos_ y los trminos como \nsus demostraciones constructivas. Bajo esta interpretacin el co-producto es de hecho\nla disyuncin.\n\n\u003Cdiv id=\"observacion-4-4-2\">\n\u003CAside type=\"note\" title=\"Observacin 4.4.2\">\nUna aplicacin simple del principio de induccin para co-productos nos da un mapa \n$ f + g : A + B arrow A' + B' $\npara cada $f: A arrow A'$ y $g: B arrow B'$. En efecto, el mapa $f + g$ se define \ncomo\n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $(f + g)(\"inl\"(x)) := \"inl\"(f(x))$,\n  $(f + g)(\"inr\"(y)) := \"inr\"(g(x))$\n)\n```\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"proposicion-4-4-3\">\n\u003CAside title=\"Proposicin 4.4.3\">\nConsideremos dos tipos $A$ y $B$ y supongamos que $B$ es vaco. Entonces hay una \nfuncin \n$ (A + B) arrow A. $\n\n_Demostracin._ Construiremos la funcin $(A + B) arrow A$ con el principio de \ninduccin para el co-producto $A + B$. As, necesitamos construir dos funciones \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $f: A arrow A$,\n  $g: B arrow A$\n)\n```\nLa funcin $f$ es simplemente la identidad $id_A : A arrow A$ y, como asumimos que \n$B$ es vaco, entonces tenemos una funcin $tilde(b): B arrow emptyset$, adems,\nsiempre tenemos la funcin $\"ex-falso\": emptyset arrow A$. Entonces podemos definir\n$g = \"ex-falso\" compose tilde(b)$ para completar la prueba.\n\u003C/Aside>\n\u003C/div>\n\n## El tipo de los enteros\nEl conjunto de los enteros usualmente se define como un cociente sobre el conjunto \n$NN times NN$, por la relacin de equivalencia \n$ ((n, m) tilde (n', m')) := (n + m', n' +m). $\nEl problema es que no hay tipos cociente en la teora de tipos dependientes de \nMartin-Lf. \n\n\u003Cdiv id=\"definicion-4-5-1\">\n\u003CAside type=\"tip\" title=\"Definicin 4.5.1\">\nDefinimos a los *enteros* como el tipo $ZZ := NN + (bold(1) + NN)$. El tipo \nde los enteros viene equipado con las funciones inclusin de los enteros positivos \ny negativos.\n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $\"in-pos\":= \"inr\" compose \"inr\" : NN arrow ZZ$,\n  $\"in-neg\":= \"inl\" : NN arrow ZZ $\n)\n```\ny con las constantes\n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $-1_ZZ := \"in-neg\"(0_NN)$,\n  $0_ZZ := \"inr\"(\"inl\"(star))$,\n  $1_ZZ := \"in-pos\"(0_NN)$\n)\n```\n\u003C/Aside>\n\u003C/div>\n\nLa definicin de los enteros como el co-producto $NN + (bold(1) + NN)$ pude \nrepresentarse visualmente como sigue:\n\n```typst\n#import \"@preview/fletcher:0.5.8\" as fletcher: diagram, node, edge\n\n#diagram(\n  $ \n    & bold(1) edge(\"dr\", ->) & & NN edge(\"dl\", ->) \\\n    NN edge(\"dr\", ->) & & bold(1) + NN edge(\"dl\", ->) & \\\n    & ZZ & & \n  $\n)\n```\n\n\u003Cdiv id=\"observacion-4-5-2\">\n\u003CAside type=\"note\" title=\"Observacin 4.5.2\">\nEl tipo de los enteros es construido enteramente a partir de tipos inductivos, de \nmodo que es posible derivar un principio de induccin para l, que se puede usar \npara definir las operaciones bsicas sobre $ZZ$, como el mapa sucesor, adicin y \nmultipicacin. Este principio de induccin afirma que para cualquier familia de tipos\n$P$ sobre $ZZ$, podemos definir una funcin dependiente $f: Pi_((k: ZZ)) P(k)$\nrecursivamente por \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $f(-1_ZZ) := p_(-1)$,\n  $f(\"in-neg\"(\"succ\"_NN (n))) := p_(-S)(n, f(\"in-neg\"(n)))$,\n  $f(0_ZZ) := p_0$,\n  $f(1_ZZ) := p_1$,\n  $f(\"in-pos\"(\"succ\"_NN (n))) := p_S (n, f(\"in-pos\"(n))),$\n)\n```\ndonde los tipos de $p_(-1), p_(-S), p_0, p_1$ y $p_S$ son\n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $f(-1_ZZ) : P(-1_ZZ)$,\n  $f(\"in-neg\"(\"succ\"_NN (n))) : Pi_((n: NN)) P(\"in-neg\"(n)) arrow P(\"in-neg\"(\"succ\"_NN (n)))$,\n  $f(0_ZZ) : P(0_ZZ)$,\n  $f(1_ZZ) : P(1_ZZ)$,\n  $f(\"in-pos\"(\"succ\"_NN (n))) : Pi_((n: NN)) P(\"in-pos\"(n)) arrow P(\"in-pos\"(\"succ\"_NN (n))).$\n)\n```\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-4-5-3\">\n\u003CAside type=\"tip\" title=\"Definicin 4.5.3\">\nDefinimos la *funcin sucesor* en los enteros $\"succ\"_ZZ : ZZ arrow ZZ$ usando el \nprincipio de induccin de la observacin [4.5.2](#observacion-4-5-2), tomando \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $\"succ\"_ZZ (-1_ZZ) := 0_ZZ$,\n  $\"succ\"_ZZ (\"in-neg\"(\"succ\"_NN (n))) := \"in-neg\"(n)$,\n  $\"succ\"_ZZ (0_ZZ) := \"in-pos\"(1_NN)$,\n  $\"succ\"_ZZ (\"in-pos\"(\"succ\"_NN (n))) := \"in-pos\"(\"succ\"_NN (n)).$\n)\n```\n\u003C/Aside>\n\u003C/div>\n\n## Tipos par dependiente \n\nDada una familia de tipos $B$ sobre $A$, podemos considerar las parejas $(a,b)$ de \ntrminos, donde $a: A$ y $b: B(a)$. Notemos que el tipo de $b$ depende de el primer \ntrmino en el par. As, llamamos a un par as un *par dependiente* El tipo de este \ntipo de pares es el tipo inductivo generado por los pares dependientes.\n\n\u003Cdiv id=\"definicion-4-6-1\">\n\u003CAside type=\"tip\" title=\"Definicin 4.6.1\">\nConsideremos una familia de tipos $B$ sobre $A$. El *tipo par dependiente* o *$Sigma$-tipo* se define como el tipo inductivo $Sigma_((x: A)) B(x)$ equipado con una \n*funcin de emparejamiento*\n\n$ \"pair\" : Pi_((x: A)) ( B(x) arrow Sigma_((y: A)) B(y)). $\n\u003C/Aside>\n\u003C/div>\n\nEl principio de induccin para $Sigma_((x: A)) B(x)$ afirma que para cualquier \nfamilia de tipos $P(p)$ indizada por $p: Sigma_((x: A)) B(x)$, hay una funcin \n$ \"ind\"_Sigma : (Pi_((x: A)) Pi_((y: B(x))) P (\"pair\"(x,y))) arrow (Pi_((z: Sigma_((x: A))))  P(z) ) $\nque satisface la regla de computacin \n$ \"ind\"_Sigma (g, \"pair\"(x,y)) equiv g(x,y). $\nAlternativamente, una definicin de una funcin dependiente\n$f: Pi_((z: Sigma_((x: A)))) P(z) $ pude presentarse va patrones como \n$ f(\"pair\"(x,y)) := g(x,y). $\nusualmente escribimos $(x,y)$ en lugar de $\"pair\"(x,y)$.\n\nEl principio de induccin para $Sigma$-tipos puede usarse para definir las funciones\nproyeccin\n\n\u003Cdiv id=\"definicion-4-6-2\">\n\u003CAside type = \"tip\" title = \"Definicin 4.6.2\">\nConsideremos un tipo $A$ y una familia de tipos $B$ sobre $A$.\n\n1. La *funcin primera proyeccin* $ \"pr\"_1 : (Sigma_((x: A)) B(x)) arrow A $ se define\n  por induccin como $ \"pr\"_1 (x, y) := x. $\n2. La *funcin segunda proyeccin* es una funcin dependiente\n  $ \"pr\"_2 : Pi_((p: Sigma_((x: A)) B(x))) B(\"pr\"_1 (p)), $\n  se define por induccin como $ \"pr\"_2 (x, y) := y. $\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-4-6-3\">\n\u003CAside type = \"note\" title = \"Observacin 4.6.3\">\nSi queremos construir una funcin $ f: Pi_((z: Sigma_((x: A)) B(x))) P(z) $\npor $Sigma$-induccin, entonces debemos asumir un par $(x, y)$ consistente de $x: A$ y \n$y: B(x)$ y nuestra meta es construir un elemento de tipo $P(x, y)$. El principio de \ninduccin para $Sigma$-tipos es entonces el recproco de la *operacin de currying*,\nun concepto familiar de la teora de lenguajes de programacin, que est dado por la \nfuncin \n$ \"ev-pair\": ( Pi_((z: Sigma_((x: A)) B(x) )) P(z) ) arrow (Pi_((x: A)) Pi_((y: B(x))) P(x, y)) $\ndada por $f mapsto lambda x. lambda y. f(x,y)$. El principio de induccin $\"ind\"_Sigma$\nes entonces conocido como la operacin de *des-curryficacin*.\n\u003C/Aside>\n\u003C/div>\n\nUn caso especial muy comn de $Sigma$-tipo ocurre cunado $B$ es una familia constante \nsobre $A$, i.e., cuando $B$ es slo un tipo debilitado por $A$. En este caso, el tipo \n$Sigma_((x: A)) B$ es el tipo de _pares ordinarios_ $(x, y)$ donde $x: A$ y $y: B$, \naqu, el tipo de $y$ no depende de $x$. El tipo de pares ordinarios $(x, y)$ que \nconsiste de $x: A$ y $y: B$ es por supuesto el _producto_ de $A$ y $B$, as que \nlos tipos productos aparecen com un caso especial de los $Sigma$-tipos, de la misma \nmanera en la que los tipos funcin fueron definidos como un caso especial de los \n$Pi$-tipos.\n\n\u003Cdiv id=\"definicion-4-6-4\">\n\u003CAside type = \"tip\" title = \"Defincin 4.6.4\">\nConsideremos dos tipos $A$ y $B$. Entonces podemos definir el *producto cartesiano*\n$A times B$ de $A$ y $B$ como $ A times B := Sigma_((x: A)) B. $\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-4-6-5\">\n\u003CAside type = \"note\" title = \"Observacin 4.6.5\">\nComo $A times B$ es definido como un $Sigma$-tipo, se sigue el los productos\ncartesianos tambin satisfacen el principio de induccin para $Sigma$-tipos. En este \ncaso especial, el principio de induccin para $A times B$ deice que para cada familia \nde tipos $P$ sobre $A times B$ hay una funcin \n$ \"ind\"_times : (Pi_((x: A)) Pi_((y: B)) P(x,y)) arrow (Pi_((z: A times B)) P(z)) $\nque satisface la regla de computacin \n$ \"ind\"_times (g, (x, y)) equiv g(x, y). $\n\u003C/Aside>\n\u003C/div>\nLos mapas de proyeccin se definen de manera similar a los mapas de proyeccin para los\n$Sigma$-tipos. Cuando uno piensa en proposiciones, el tipo $A times B$ es interpretado \ncomo la conjuncin de $A$ y $B$.","src/content/docs/tipos/Rijke/inductivo.mdx","bbb8552da9efa86a","tipos/rijke/naturales",{"id":209,"data":211,"body":218,"filePath":219,"digest":220,"deferredRender":16},{"title":212,"editUrl":16,"head":213,"template":18,"sidebar":214,"pagefind":16,"draft":20,"sitemap":216},"Nmeros naturales",[],{"order":117,"hidden":20,"attrs":215},{},{"linkInclusionRules":217},[24],"import { Aside } from '@astrojs/starlight/components';\n\n## La especificacin formal\n\nEl tipo $NN$ de **nmeros naturales** es el ejemplo arquetpico de un tipo inductivo.\nLas reglas que postulamos para el tipo de los nmeros naturales vienen en cuatro conjuntos,\nal igual que las reglas para los $Pi$-tipos:\n\n1. La regla de formacin, que afirma que el tipo $NN$ pude ser formado.\n2. Las reglas de introduccin, que nos dan el elemento cero $0_NN$ y la funcin sucesor\n  $\"succ\"_NN$.\n3. La regla de eliminacin. Esta regla es la versin de la teora de tipos del principio \n  de induccin para $NN$.\n4. Las reglas de computacin, que afirman que cualquier aplicacin de la regla de \n  eliminacin se comporta como debera sobre los constructores $0_NN$ y $\"succ\"_NN$ de $NN$.\n\n### La regla de formacin de \n\nEl tipo $NN$ se forma mediante la regla de **$NN$-formacin**:\n\n```typst\n#prooftree(\n  rule(\n    name: $NN\"-form\"$,\n    $tack.r NN \"type\"$,\n    $space$\n  )\n)\n```\n\nEn otras palabras, se postula que $NN$ es un tipo en el contexto vaco.\n\n### Las reglas de introduccin de \n\nLas reglas de introduccin para $NN$ lo equipan con un **elemento cero** y una \n**funcin sucesor**:\n\n```typst\n#table(\n  stroke: none,\n  columns: 2,\n  prooftree(\n    rule(\n      $tack.r 0_NN: NN$\n    )\n  ),\n  prooftree(\n    rule(\n      $\"succ\"_NN: NN arrow.r NN$\n    )\n  )\n)\n```\n\u003Cdiv id=\"obsercacion-3-1-1\">\n\u003CAside type=\"note\" title=\"Observacin 3.1.1\">\n\nTodo elemento en la teora de tipos viene equipado con su tipo. As, es posible que en la \nteora de tipos todos los elementos tengan un *nico* tipo. En general, es buena prctica \nasegurarnos de que cada elemento tenga un nombre nico. Por ejemplo, el elemento $0_NN$ \ntiene tipo $NN$ y no tiene tambin el tipo $ZZ$.tipo $NN$ y no tiene tambin el tipoZZ$.\n\u003C/Aside>\n\u003C/div>\n\n### El principio de induccin de \n\nEl principio de induccin clsico de los nmeros naturales nos dice qu tenemos que hacer\npara mostrar que $forall_((n in NN)) P(n)$ se cumple, para un predicado $P$ sobre $NN$.\nRecordemos que un predicado $P$ sobre el conjunto $X$ es slo una proposicin $P(x)$\nsobre un $x in X$ asrbitrario. \nEn la teora de tipos dependiente podemos pensar a una familia de tipos $P$ sobre $NN$\ncomo un predicado sobre $NN$. As, el principio de induccin para $NN$ se postula \nusando una famlia de tipos $P$ sobre $NN$:\n\n```typst\n#prooftree(\n  rule(\n    name: $NN\"-ind\"$ ,\n    $Gamma tack.r \"ind\"_NN (p_0, p_S): Pi_((n: NN)) P(n)$,\n    table(\n      stroke: none,\n      columns: 1,\n      align: left,\n      $Gamma,n: NN tack.r P(n) \"type\"$,\n      $Gamma tack.r p_0: P(0_NN)$,\n      $Gamma tack.r p_S: Pi_((n: NN)) P(n) arrow.r P(\"succ\"_NN (n))$\n    )\n  )\n)\n```\nEn otras palabras, el principio de induccin de $NN$ de la teora de tipos nos deice qu \nnecesitamos para construir una funcin dependiente $Pi_((n: NN)) P(n)$.  \nComo en el principio de induccin clsico, tenemos que construir dos cosas dada una \nfamilia de tipos $P$ sobre $NN$: en el **caso base** necesitamos construir un elemento \nde tipo $p_0: P(0_NN)$ y, para el **paso inductivo** necesitamos construir una funcipon \nde tipo $P(n) arrow.r P(\"succ\"_NN (n))$ para cada $n: NN$.\n\n\u003Cdiv id=\"obsercacion-3-1-2\">\n\u003CAside type=\"note\" title=\"Observacin 3.1.2\">\nPodemos presentar el principio de induccin de forma distinta con la siguiente regla de \ninferencia\n\n```typst\n#prooftree(\n  rule(\n    $Gamma  tack.r \"ind\"_NN: P(0_NN) arrow.r ((  Pi_((n: NN)) P(n) arrow.r P(\"succ\"_NN(n))) arrow.r Pi_((n: NN)) P(n))$,\n    $Gamma, n: NN tack.r P(n) \"type\"$\n  )\n)\n```\n\u003C/Aside>\n\u003C/div>\n\nEn otras palabras, para cualquier familia de tipos $P$ sobre $NN$ hay una funcin \n$\"ind\"_NN$ que toma dos argumentos, uno para el caso base y otro para el paso inductivo y regresa una seccin de $P$. Afirmamos que esta regla es *inter-derivable* \ncon la regla $NN\"-ind\"$ que dimos antes.\n$ Gamma, p_0: P(0_NN) ,p_S:Pi_((n: NN)) P(n) arrow.r P(\"succ\"_NN (n)) $\n\nPor debilitamiento, obtenemos que \n\n```typst\n#table(\n  stroke: none,\n  columns: 1,\n  $Gamma', n:NN tack.r P(n) \"type\"$,\n  $Gamma' tack.r p_0: P(0_NN)$,\n  $Gamma' tack.r p_S: Pi_((n:NN)) P(n) arrow.r P(\"succ\"_NN (n))$\n)\n```\n\nAs, el principio de induccin de $NN$ nos da una funcin dependiente \n$ Gamma' tack.r \"ind\"_NN (p_0, p_S) : Pi_((n: NN)) $ \n\nAhora, procedemos por $lambda$-abstraccin dos veces para obtener una funcin\n$ \"ind\"_NN : P(0_NN) arrow.r (( Pi_((n: NN)) P(n) arrow.r P(\"succ\"_NN (n))) arrow.r Pi_((n: NN)) P(n)) $\n\nen el contexto original $Gamma$. Esto muestra que podemos definir la funcin \n$\"ind\"_NN$ a partir de la regla $NN\"-ind\"$. Recprocamente, podemos derivar la regla\n$NN-\"ind\"$ a partir de la regla que presenta $\"ind\"_NN$ como una funcin. Concluimos\nque la regla \"oficial\" $NN\"-ind\"$ y la que presenta a $\"ind\"_NN$ como una funcin \nson inter-derivables.\n\n### Las reglas de computacin para \n\nLas reglas de computacin para $NN$ postulan que la funcin dependiente \n$ \"ind\"_NN (p_0, p_S): Pi_((n: NN)) P(n) $\nse comporta como se espera cuando se aplica a $0_NN$ o a un sucesor. Hay una \nregla de computacin para cada paso del principio de induccin, cubriendo el \ncaso base y el paso inductivo.\n\nLa regla de computacin para el caso base es\n\n```typst\n  #prooftree(\n    rule(\n      $Gamma tack.r \"ind\"_NN (p_0, p_S, 0_NN) equiv p_0 : P(0_NN)$,\n      table(\n        stroke: none,\n        columns: 1,\n        $Gamma, n: NN tack.r P(n) \"type\"$,\n        $Gamma tack.r p_0: P(0_NN)$,\n        $Gamma tack.r p_S : Pi_((n: NN)) P(n) arrow.r P(\"succ\"_NN (n))$\n      )\n    )\n  )\n```\n\nLa regla de computacin para el paso inductivo tiene las mismas premisas que la del\ncaso base:\n\n```typst\n  #prooftree(\n    rule(\n      $Gamma tack.r \"ind\"_NN (p_0, p_S, \"succ\"_NN (n)) equiv p_S(n, \"ind\"_NN (p_0, p_S, n)): P(\"succ\"_NN (n))$,\n      table(\n        stroke: none,\n        columns: 1,\n        $Gamma, n: NN tack.r P(n) \"type\"$,\n        $Gamma tack.r p_0: P(0_NN)$,\n        $Gamma tack.r p_S : Pi_((n: NN)) P(n) arrow.r P(\"succ\"_NN (n))$\n      )\n    )\n  )\n```\n\n## Adicin en los nmeros naturales\n\nEl principio de induccin de la teora de tipos de $NN$ se puede usar para hacer \ntodas las construcciones usuales en $NN$, y para derivar todas las propiedades que \nnos son familiares. \n\n\u003Cdiv id=\"definicion-3-2-1\">\n\u003CAside type=\"tip\" title=\"Definicin 3.2.1\">\nDefinimos una funcin \n$ \"add\"_NN: NN arrow.r (NN arrow.r NN) $\nque satisface \n$ \"add\"_NN (m, 0_NN) equiv m $\n$ \"add\"_NN (m, \"succ\"_NN (n)) equiv \"succ\"_NN (m, n). $\n\n_Construccin._ Construiremos la operacin binaria $\"add\"_NN: NN arrow.r (NN arrow.r NN)$ por induccin sobre la segunda variable. En otras palabras, construiremos un \nelemento $ m: NN tack.r \"add\"_NN (m) : NN arrow.r NN. $\n\n\u003C/Aside>\n\u003C/div>","src/content/docs/tipos/Rijke/naturales.mdx","9b116762d1b629b0","tipos/rijke/universos",{"id":221,"data":223,"body":231,"filePath":232,"digest":233,"deferredRender":16},{"title":224,"editUrl":16,"head":225,"template":18,"sidebar":226,"pagefind":16,"draft":20,"sitemap":229},"Universos",[],{"order":227,"hidden":20,"attrs":228},8,{},{"linkInclusionRules":230},[24],"import { Aside } from '@astrojs/starlight/components';\n\nPara completar nuestra especificacin so la teora de tipos dependiente, introducimos los \nuniversos de la teora de tipos. Los universos se pueden pensar como tipos que consisten \nde tipos. En realidad, un universo consiste de un tipo $cal(U)$ equipado con una familia de \ntipos $cal(T)$ sobre $cal(U)$. Para cada $X: cal(U)$ pensamos a $X$ como una *codificacin*\ndel tipo $cal(T)(X)$. La familia de tipos $cal(T)$ es llamada una *familia universal de tipos.\nHay varias razones para equipar a la teora de tipos con universos. Una razn importante es \nque nos permite definir nuevas familias de tipos sobre tipos inductivos, usando su \nprincipio de induccin. Usamos esta manera de definir familias de tipos para definir muchas \nrelaciones familiares sobre $NN$, como las relaciones de orden $lt.eq$ y $lt$.\n\nTambin introducimos la relacin $\"Eq\" _NN$ llamada la *igualdad observacional* en $NN$.\nEsta relacin de equivalencia se puede usar para mostrar que $0_NN eq.not 1_NN$.\n\nLa idea de introducir la igualdad observacional para un tipo en particular es que nos \ndebe poder ayudar a pensar cobre el tipo identidad. El tipo identidad fue introducido \nde manera genrica y uniforme. Sin embargo, en casos especficos, tenemos una idea clara de \ncmo *debe ser* la relacin de igualdad. En el caso de los nmeros naturales, por ejemplo, \nusaremos la igualdad observacional $\"Eq\" _NN$ para caracterizar al tipo identidad de \n$NN$. Caracterizar tipos identidad es uno de los temas principales de la teora homotpica \nde tipos.\n\nUna segunda razn para introducir universos es que nos permite definir muchos tipos de tipos \nequipados con estructura. Uno de los ejemplos ms importantes es el tipo de los grupos, que \nes el tipo de tipos equipado con las operaciones de grupo que satisfacen las leyes de grupos \ny para los cuales el tipo subyacente es un conjunto.\n\n## especificacin de los universos de la teora de tipos \n\nUn universo consiste de un tipo $cal(U)$ cuyos elementos pueden pensarse como \"cdigos\" \npara tipos. Un universo tambin viene equipado con una familia de tipos $cal(T)$ indizada \npor $cal(U)$. Dado un elemento $X: cal(U)$, ,pensamos en el tipo $cal(T)(X)$ como \nel tipo de elementos de $X$. La familia $cal(T)$ es llamada la **familia universal de tipos**.\n\nUna de las caractersticas distintivas de los universos es que son cerrados bajo todos los \ntipos de constructores. Dado un universo $cal(U)$ con familia universal de tipos $cal(T)$, \ncmo expresamos que $cal(U)$ es cerrado bajo $Sigma$-tipos, por ejemplo? Recordemos que \nun $Sigma$-tipo se forma usando un tipo $A$ y una familia de tipos $B$ sobre $A$. As, \nsi $A$ es un tipo en $cal(U)$ y $B$ es una familia de tipos sobre $A$, quisiramos expresar \nque el $Sigma$-tipo es tambin un tipo en $cal(U)$. Sin embargo, no podemos simplemente \nafirmar que $Sigma_((x: A)) B(x)$ es un elemento del universo, pues la teora de tipos \nhace una distincin cuidados entre tipos y elementos.\n\nExpresamos que $cal(U)$ es cerrado bajo $Sigma$-tipos usando una nueva operacin \n$caron(Sigma)$, que toma dos argumentos. El primer argumento es un elemento $X: cal(U)$ y el \nsegundo argumento es una familia de tipos en $cal(U)$ indizada por los elementos de $X$, es \ndecir, una funcin $cal(T)(X) arrow cal(U)$. As, decimos que $cal(U)$ es cerrado bajo \n$Sigma$-tipos afirmando que $cal(U)$ viene equipado con una operacin \n\n$ caron(Sigma): Pi_((X: cal(U))) (cal(T)(X) arrow cal(U)) arrow cal(U)$\n\nMs an, pedimos que el elemento $caron(Sigma)(X, Y): cal(U)$ satisfaga la igualdad juiciosa \n\n$ cal(T)(caron(Sigma) (X, Y)) equiv Sigma_((x: cal(T)(X))) cal(T)(Y(x)). $\n\nEsta igualdad juiciosa afirma que el elemento $caron(Sigma)(X, Y)$ del universo $cal(U)$ \n*representa* el $Sigma$-tipo $Sigma_((x: cal(T)(X))) cal(T)(Y(X))$.\n\nSimilarmente asumiremos que los universos son cerrados bajo $Pi$-tipos y bajo las dems \nmaneras de formar tipos. Sin embargo, hay una restriccin importante: sera inconsistente \nasumir que un universo este contenido dentro de s mismo. Una forma de pensar en esto es que \nlos universos son de *tipos pequeos* y no puede ser el caso que el universo sea pequeo \ncon respecto a s mismo. En lugar de asumir que un universo se contiene a s mismo, asumimos \nque hay una gran cantidad de universos: los suficientes para que cada familia se pueda \nobtener sustituyendo dentro de la familia universal de algn tipo.\n\n\u003Cdiv id=\"definicion-6-1-1\">\n\u003CAside type=\"tip\" title=\"Definicin 6.1.1\">\n\nUn **universo** en la teora de tipos es un tipo $cal(U)$ en el contexto vaco, equipado con \nuna familia de tipos $cal(T)$ sobre $cal(U)$ llamada una **familia universal**, que es \ncerrada bajo las operaciones de formacin de tipos en el sentido de que viene equipada con \nla siguiente estructura \n\n1. $cal(U)$ es cerrada bajo $Pi$, en el sentido de que viene equipado con una funcin \n    $ caron(Pi): Pi_((X: cal(U))) (cal(T)(X) arrow cal(U)) arrow cal(U) $\n    para la cual la igualdad juiciosa \n    $ cal(T)(caron(Pi)(X, Y)) equiv Pi_((x : cal(T)(X))) cal(T)(Y(X)). $\n    se mantiene, para cada $X: cal(U)$ y $Y : cal(T)(X) arrow cal(U)$.\n\n2. $cal(U)$ es cerrado bajo $Sigma$ en el sentido de que viene equipado con una funcin \n    $ caron(Sigma) : Pi_((X : cal(U))) (cal(T)(X) arrow cal(U)) arrow cal(U) $\n    para la cual la igualdad juiciosa \n    $ cal(T)(caron(Sigma)(X, Y)) equiv Sigma_(x: cal(T)(X)) cal(T)(Y(X)) $\n    se mantiene para cada $X: cal(U)$ y $Y : cal(T)(X) arrow cal(U)$.\n\n3. $cal(U)$ es cerrado bajo tipos identidad, en el sentido de que viene equipado con una\n    funcin \n    $ caron(I) : Pi_((X: cal(U))) cal(T)(X) arrow (cal(T)(X) arrow cal(U)) $\n    para la cual la igualdad juiciosa \n    $ cal(T)(caron(I)(X, x, y)) equiv (x = y) $\n    se mantiene para cada $X: cal(U)$ y $x, y: cal(T)(X)$.\n\n4. $cal(U)$ es cerrado bajo co-productos, en el sentido de que viene equipado con una \n    funcin \n    $ caron(+): cal(U) arrow (cal(U) arrow cal(U)) $\n    que satisface $cal(T)(X caron(+) Y) equiv cal(T)(X) + cal(T)(Y)$.\n\n5. $cal(U)$ contiene elementos $caron(emptyset), caron(bold(1)), caron(NN): cal(U)$ que \n    satisfacen las igualdades juiciosas \n    ```typst \n    #table(\n      stroke: none,\n      columns: 1, \n      $cal(T)(caron(emptyset)) equiv emptyset$,\n      $cal(T)(caron(bold(1))) equiv bold(1)$,\n      $cal(T)(caron(NN)) equiv NN.$\n    )\n    ```\n\n\u003C/Aside>\n\u003C/div>\n\nConsideremos un universo $cal(U)$ y un tipo $A$ en un contexto $Gamma$. Decimos que \n$A$ es un tipo en $cal(U)$, o que el universo $cal(U)$ **contiene** a $A$, si $cal(U)$\nviene equipado con un elemento $caron(A) : cal(U)$ en el contexto $Gamma$, para el cual \nel juicio \n$ Gamma tack.r cal(T)(caron(A)) equiv A \"type\" $\nse mantiene. Si $A$ es un tipo en $cal(U)$, usualmente escribimos $A$ en lugar de $caron(A)$\ny $A$ en lugar de $cal(T)(caron(A))$.\n\n\u003Cdiv id=\"observacion-6-1-2\">\n\u003CAside type=\"note\" title=\"Observacin 6.1.2\">\nComo los tipos funcin ordinarios se definieron como un caso especial de funcin \ndependiente, no necesitamos tambin asumir que los universos son cerrados bajo tipos \nfunciones ordinarias. Similarmente, como los universos son cerrados bajo tipos pares \ndependientes, tambin lo son bajo productos cartesianos.\n\u003C/Aside>\n\u003C/div>\n\n## Asumiendo suficientes universos \nLa mayora del tiempo ser suficiente asumir un universo $cal(U)$ y de hecho recomendamos \nque se asuma en este texto que hay un universo $cal(U)$. Sin embargo, a veces quisiramos \nconsiderar al universo $cal(U)$ como un tipo en algn universo. En estas situaciones no \npodemos usar un slo universo, pues suponer que $cal(U)$ es elemento de s mismo nos lleva \na inconsistencias como al paradoja de Russell.\n\nLa paradoja de Russel es el argumento famoso de que no hay un conjunto de todos los \nconjuntos. Si hubiera un conjunto de todos los conjuntos $S$, entonces podramos considerar \nel subconjunto de Russell \n\n$ R := brace.l x in S | x in.not x brace.r. $\n\nRussell despus observ que $R in R$ si y slo si $R in.not R$, as que llegamos a una \ncontradiccin. Una variante del mismo argumento nos lleva a una conclusin similar si \nasumimos que existe un universo $cal(U)$ que contiene un elemento $caron(cal(U)) : cal(U)$\ntal que $cal(T)(caron(cal(U))) equiv cal(U)$. Para prevenir estas paradojas, Russell y \nWhitehead formularon la teora de tipos ramificada en su libro *Principia Mathematica*. \nLa teora de tipos ramificada es un precursor de la teora de tipos de Martin Lf que \nestamos estudiando.\nAunque un universo no es un elemento de s mismo, es an conveniente que cada tipo, \nincluyendo cada universo, sea un elemento de algn universo. As, asumiremos que hay \nsuficientes universos: \n\n\u003Cdiv id=\"postulado-6-2-1\">\n\u003CAside type=\"tip\" title=\"Postulado 6.2.1\">\nAsumimos que hay **suficientes universos**, es decir, que toda lista finita de tipos en un \ncontexto \n    \n$ Gamma_1 tack.r A_1 \"type\" dots Gamma_n tack.r A_n \"type\", $\n\nhay un universo $cal(U)$ que tiene como elementos a cada $A_i$ en el sentido de que $cal(U)$\nviene equipado con \n\n$ Gamma_i tack.r caron(A_i) : cal(U) $\n\npara el cual el juicio\n\n$ Gamma_i tack.r cal(T)(caron(A)_i) equiv A_i \"type\" $\nse mantiene.\n\u003C/Aside>\n\u003C/div>\n\nCon esta suposicin raramente necesitaremos trabajar con ms de un universo al mismo tiempo.\nUsando esta suposicin de que para cada lista finita de tipos en un contexto hay un universo \nque contiene a esos tipos, obtenemos muchos universos especficos.\n\n\u003Cdiv id=\"definicion-6-2-2\">\n\u003CAside type=\"tip\" title=\"Definicin 6.2.2\">\nEl **universo base** $cal(U)_0$ es el universo que obtenemos mediante el postulado \n[6.2.1](#postulado-6-2-1) con la lista vaca de tipos en un contexto.\n\u003C/Aside>\n\u003C/div>\n\nEn otras palabras, el universo base es un universo que es cerrado bajo todas las maneras de \nformar tipos, pero no tiene como elemento a ningn otro tipo especfico.\n\n\u003Cdiv id=\"definicioin-6-2-3\">\n\u003CAside type=\"tip\" title=\"Definicin 6.2.3\">\nEl **universo sucesor** de un universo $cal(U)$ es un universo $cal(U)^+$ que se obtiene \nutilizando el postulado [6.2.1](#postulado-6-2-1) con la lista finita \n\n```typst \n#table(\n    stroke:none,\n    columns: 1,\n    $tack.r cal(U) \"type\"$,\n    $X: cal(U) tack.r cal(T)(X) \"type\".$\n)\n```\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-6-2-4\">\n\u003CAside type=\"note\" title=\"Observacin 6.2.4\">\nEl universo sucesor $cal(U)^+$ de $cal(U)$ contiene un tipo $cal(U)$ al igual que cada tipo \nen $cal(U)$ en el siguiente sentido \n\n```typst \n#table(\n  stroke: none,\n  align: center,\n  columns: 2, \n  $tack.r caron(cal(U))$,\n  $tack.r cal(T)^+ (caron(cal(U))) equiv cal(U) \"type\"$,\n  $X: cal(U) tack.r caron(cal(T))(X): cal(U)+$,\n  $X: cal(U) tack.r cal(T)^+ (caron(cal(T))(X)) equiv cal(T)(X) \"type\".$\n)\n```\n\u003C/Aside>\n\u003C/div>\n\nEn particular, obtenemos una funcin $i : cal(U) arrow cal(U)^+$ que incluye los tipo de \n$cal(U)$ dentro de $cal(U)^+$, dada por \n\n$ i := lambda X. caron(T)(X). $\n\nUsando universos sucesores podemos crear una torre infinita \n\n$ cal(U), cal(U)^+, cal(U)^(++), dots $\n\nde universos, empezando con el universo $cal(U)$, en el que cada universo es elemento del \nsiguiente. Sin embargo, estas torres no son exhaustivas, en el sentido de que no todo tipo \nest contenido en un universo de esta torre.\n\n\u003Cdiv id=\"definicion-6-2-5\">\n\u003CAside type=\"tip\" title=\"Definicin 6.2.5\">\nLa **unin** de dos universos $cal(U)$ y $cal(V)$ es el universo $cal(U) union.sq cal(V)$\nque obtenemos al usar el postulado [6.2.1](#postulado-6-2-1) con los dos tipos \n$ X: cal(U) tack.r cal(T)_(cal(U)) (X) \"type\" $\n$ Y: cal(V) tack.r cal(T)_(cal(V)) (Y) \"type\". $\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-6-2-6\">\n\u003CAside type=\"note\" title=\"Observacin 6.2.6\">\nComo la unin $cal(U) union.sq cal(V)$ contiene todos los tipos en $cal(U)$ y $cal(V)$, hay \nfunciones \n$ i: cal(U) arrow cal(U) union.sq cal(V) $\n$ j: cal(V) arrow cal(U) union.sq cal(V) $\n\u003C/Aside>\n\u003C/div>\n\nNotemos que no postulamos ninguna relacin entre universos. En general, se da el caso que \nlos universos $(cal(U) union.sq cal(V)) union.sq cal(W)$ y \n$cal(U) union.sq (cal(V) union.sq cal(W))$ no estn relacionados de ninguna manera.\n\n\n## Igualdad observacional de los nmeros naturales\n\nUsando universos, podemos definir muchas relaciones sobre los nmeros naturales. Damos \naqu el ejemplo de *igualdad observacional* en $NN$. La idea de la igualdad \nobservacional es que, si queremos probar que $m$ y $n$ son observacionalmente iguales, \npodemos hacerlo viendo a $m$ y a $n$:\n\n1. Si $m$ y $n$ son ambos $0_NN$, entonces son observacionalmente iguales. \n2. Si uno de ellos es $0_NN$ y el otro es un sucesor, entonces no son observacionalmente\n  iguales.\n3. Si $m$ y $n$ son sucesores, digamos $m equiv \"succ\" _NN (m')$ y \n  $n equiv \"succ\" _NN (n')$, entonces $n$ y $m$ son observacionalmente iguales si y slo \n  si sus predecesores, $m'$ y $n'$ son observacionalmente iguales.\n\nAs, la igualdad observacional es una relacin definida inductivamente, que nos da un \nalgoritmo para verificar la igualdad en $NN$. En efecto, se pude usar para mostrar que \nla igualdad entre nmeros naturales es *decidible*, es decir, existe un programa que \ndecide si dos nmeros naturales dados $m$ y $n$ son iguales.\n\n\u003Cdiv id=\"definicion-6-3-1\">\n\u003CAside type=\"tip\" title=\"Definicin 6.3.1\">\nDefinimos la **igualdad observacional** en $NN$ como una relacin binaria \n$\"Eq\" _NN : NN arrow (NN arrow cal(U)_0)$ que satisface \n\n```typst \n#table(\n  stroke: none, \n  columns: 2, \n  $\"Eq\" _NN (0_NN, 0_NN) equiv bold(1)$,\n  $\"Eq\" _NN (\"succ\" _NN (n), 0 _NN) equiv emptyset$,\n  $\"Eq\" _NN (0_NN, \"succ\" _NN (n) equiv emptyset)$,\n  $\"Eq\" _NN (\"succ\" _NN (n), \"succ\" _NN (m)) equiv \"Eq\" _NN (n, m).$\n)\n```\n*Construccin* Definimos $\"Eq\" _NN $ por induccin doble sobre $NN$. Para la primera \naplicacin de induccin, es suficiente dar \n\n```typst \n#table(\n  stroke: none,\n  columns: 1, \n  $E_0 : NN arrow cal(U)_0$,\n  $E_S : NN arrow ((NN arrow cal(U)_0) arrow (NN arrow cal(U)_0))$ \n)\n```\nDefinimos $E_0$ por induccin, tomando $E_(00) := bold(1)$ y $E_(0 S)(n, X, m) := emptyset$.\nLa familia $E_0$ resultante satisface \n \n```typst \n#table(\n  stroke: none,\n  columns: 1, \n  $E_0 (0_NN) equiv bold(1)$,\n  $E_0 (\"succ\" _NN (n)) equiv emptyset.$\n)\n```\nDefinimos $E_S$ por induccin, tomando $E_(S 0) := emptyset$ y \n$E_(S S) (n, X, m) := X(m)$. La familia  $E_S$ resultante satisface \n\n```typst \n#table(\n  stroke: none,\n  columns: 1, \n  $E_S (n, X, 0_NN) equiv emptyset$,\n  $E_S (n, X, \"succ\" _NN (m)) equiv X(m).$\n)\n```\nPor lo tanto, por la regla de computacin para la primera induccin, tenemos que la \nigualdad juiciosa \n\n```typst \n#table(\n  stroke: none,\n  columns: 1,\n  $\"Eq\" _NN (0_NN, m) equiv E_0(m)$,\n  $\"Eq\" _NN (\"succ\" _NN (n), m) equiv E_S (n, \"Eq\" _NN (n), m)$\n)\n```\nse mantiene, de lo que las igualdades juiciosas en el enunciado de la definicin se siguen.\n\n\u003C/Aside>\n\u003C/div>\n\nLa igualdad observacional de los nmeros naturales es importante pues se usa para probar \nigualdades y negaciones de igualdades. La proposicin [6.3.3](#proposicion-6-3-3) no \npermite hacer eso.\n\n\u003Cdiv id=\"lema-6-3-2\">\n\u003CAside type=\"tip\" title=\"Lema 6.3.2\">\nLa igualdad observacional en $NN$ es una relacin reflexiva, es decir, tenemos \n\n$ \"refl-Eq\"_ NN : Pi_((n : NN)) \"Eq\" _NN (n.n). $\n\n*Demostracin* La funcin $\"refl-Eq\" _NN$ se define por induccin sobre $n$, tomando \n\n```typst \n#table(\n  stroke: none, \n  columns: 1,\n  $\"refl-Eq\" _NN (0_NN) := star$,\n  $\"refl-Eq\" _NN (\"succ\"_ NN (n)) := \"refl-Eq\" _NN (n).$\n)\n```\n\u003C/Aside>\n\u003C/div>\n\n\n\u003Cdiv id=\"proposicion-6-3-3\">\n\u003CAside type=\"tip\" title=\"Proposicin 6.3.3\">\n\nPara cualesquiera dos nmeros naturales $m$ y $n$ se tiene que \n\n$ (m = n) arrow.r.l \"Eq\" _NN (m, n) $\n\n\n\n```typst\n#import \"@preview/commute:0.3.0\": node, arr, commutative-diagram\n\n#align(center)[#commutative-diagram(\n  node((0, 0), $X$),\n  node((0, 1), $Y$),\n  node((1, 0), $X \\/ \"ker\"(f)$, \"quot\"),\n  arr($X$, $Y$, $f$),\n  arr(\"quot\", (0, 1), $tilde(f)$, label-pos: right, \"dashed\", \"inj\"),\n  arr($X$, \"quot\", $pi$),\n)]\n```\n\u003C/Aside>\n\u003C/div>\n\nTODO!","src/content/docs/tipos/Rijke/universos.mdx","eabce05db5d581ed","tipos/lean/programacion/conociendo",{"id":234,"data":236,"body":243,"filePath":244,"digest":245,"deferredRender":16},{"title":237,"editUrl":16,"head":238,"template":18,"sidebar":239,"pagefind":16,"draft":20,"sitemap":241},"Conociendo a Lean",[],{"order":104,"hidden":20,"attrs":240},{},{"linkInclusionRules":242},[24],"## Evaluando expresiones\n\nPara pedirle a lean que evale una expresin, hay que escribir `#eval` primero, luego lean\nnos reportar el resultado.\n\n```code :language lean4 :eval true\n#eval 1 + 2\n```\n\nLean sigue las leyes de precedencia y asociatividad para operadores aritmticos. Entonces \n\n```code :language lean4 :eval true \n#eval 1 + 2 * 5 \n```\nMientras que la mayora de notacin matemtica y lenguajes de programacin usan parntesis \npara aplicar una funcin a sus argumentos, Lean simplemente escribe la funcin seguida \nde sus argumentos \n\n```code :language lean4 :eval true \n#eval String.append \"Hello \" \"Lean\" \n```\n\nComo Lean es un lenguaje funcional orientado a las expresiones, no hay enunciados\ncondicionales, sino que hay expresiones condicionales \n\n```code :language lean4 :eval true \n#eval String.append \"It is \" (if 1 > 2 then \"yes\" else \"no\")\n \n```\n\n## Tipos\n\nTodo programa en Lean debe tener un tipo. En particular, toda expresin debe tener un tipo \nantes de ser evaluada. Podemos proveer el tipo de una expresin con el operador dos puntos \n\n```code :language lean4 :eval true \n#eval (1 + 2 : Nat) \n```\n\nAqu **Nat** es el tipo de los nmeros naturales, que son enteros sin signo de precisin \narbitraria.\n\nPara obtener el tipo de una expresin podemos usar `#check` en lugar de `#eval`.\n\n```code :language lean4 :eval true \n#check (1 - 2 : Nat) \n```\n\n## Funciones y definiciones\n\nEn Lean, las definiciones se introducen usando la palabra clave **def** y el $:=$.\n\n```code :language lean4 :eval true :session funciones-uno \ndef lean : String := \"Lean\" \n```\nUna vez que hemos definido un nombre, lo podemos usar \n\n```code :language lean4 :eval true :session funciones-uno\n#eval String.append \"Hola \" lean\n```\n\n### Definiendo funciones \n\nLa forma ms fcil de definir una funcin en Lean es poner los argumentos antes del tipo \nde la definicin separados por espacios.\n\n```code :language lean4 :eval true \ndef add1 (n : Nat) : Nat := n + 1\n\n#eval add1 7\n```\n\nPodemos definir funciones con varios argumentos\n\n```code :language lean4 :eval true \ndef maximum (n : Nat) (k : Nat) : Nat := \n  if n \u003C k then \n    k \n  else n\n\n#eval maximum 2 3\n```\n\n### Definiendo tipos \n\nSi, por ejemplo `String` es muy largo, podemos definir \n\n```code :language lean4 :eval true \ndef Str : Type := String\n\ndef palabra : Str := \"Hola\"\n\n#check palabra\n```\n\n## Estructuras \n\nDefinir una estructura introduce un tipo completamente nuevo a Lean, que no se puede \nreducir a cualquier otro tipo. Eso es til porque distintas estructuras pueden representar \nconceptos distintos a pesar de contener los mismo datos.\n\nEl tipo de Lean para los nmeros flotantes es llamado `Float`: \n\n```code :language lean4 :eval true \n#check 1.2\n\n#check -454.2123215\n\n#check 0.0\n```\nSi usamos punto decimal, Lean infiere el tipo `Float`, si no, necesitamos una anotacin \nde tipo.\n\nUn punto Cartesiano es una estructura con dos campos `Float`, llamados `x` y `y`. Esto \nse declara con la palabra clave `structure`.\n\n```code :language lean4 :eval true :session point\nstructure Point where \n  x : Float \n  y : Float\n```\n\nDespus de esta declaracin, `Point` es un nuevo tipo estructura. La manera tpica de crear\nun valor de una estructura es proveer los valores para cada uno de sus campos entre llaves.\n\n```code :language lean4 :eval true :session point  \ndef origin : Point := { x := 0.0, y := 0.0 } \n```\nEl resultado de hacer `#eval` al origen se ve muy similar a su definicin \n\n```code :language lean4 :eval true :session point  \n#eval origin \n```\nPodemos extraer los campos de una estructura usando notacin `.`.\n\n```code :language lean4 :eval true :session point \n#eval origin.x\n\n#eval origin.y\n```\nEsto se puede usar para definir funciones que toman estructuras como argumentos. \n\n```code :language lean4 :eval true :session point \ndef addPoints (a b : Point) : Point := \n  { x := (a.x + b.x) , y := (a.y + b.y)}\n \n#eval addPoints { x := 1.5, y := 32 } { x := -8, y := 0.2 }\n\ndef distance (a b : Point) : Float := \n  Float.sqrt ( ((a.x - b.x) ^ 2.0) + ((a.y - b.y) ^ 2.0) )\n\n#eval distance { x := 1.0, y := 2.0 } { x := 5.0, y := -1.0 }\n```\n### Actualizando estructuras \n\nLean da una sintaxis conveniente para remplazar algunos campos en una estructura. Esto se \nhace usando la palabra clave `with`.\n\n```code :language lean4 :eval true :session point  \ndef zeroX (p : Point) : Point := \n  { p with x := 0 }\n```\n### Detrs de bambalinas \n\nToda estructura tiene un constructor. Los constructores simplemente agrupan los datos \nen una estructura. Por defecto, el constructor para una estructura `S` es llamado `S.mk`.\n\n```code :language lean4 :eval true :session point \n#check Point.mk 1.5 2.8\n```\nPara sobreescribir el nombre de un constructor lo escribimos al principio de la estructura \nseguido de dos dos puntos:\n\n```code :language lean4 :eval true :session point-2 \nstructure Point where \n  point :: \n  x : Float \n  y : Float\n```\nAdems del constructor, una funcin de acceso se define para cada campo de la estructura.\n\n```code :language lean4 :eval true :session point-2 \n#check Point.x \n\n#check Point.y\n```\n\n## Tipos de datos y patrones \n\nLas estructuras permite agrupar datos en uno solo que representa un nuevo tipo. Los \ntipos que agrupan una coleccin de valores son llamados *tipos producto*.\n\nLos tipos de datos que permiten elecciones son llamados *tipos suma* y los que incluyen \ninstancias de s mismos son llamados *recursivos*. Los tipos *suma recursiva* son llamados \n*inductivos*, pues podemos usar induccin matemtica para probar cosas sobre ellos. \nCuando programamos, los tipos de datos inductivos se consumen mediante pattern matching \ny funciones recursivas.\n\nPor ejemplo, `Bool` es inductivo \n\n```code :language lean4 :eval false \ninductive Bool where \n  | false : Bool \n  | true : bool\n```\nEsta definicin tiene dos partes principales. En la primera lnea se da el nombre del tipo \nde dato, las siguientes lneas describen un constructor. A diferencia de las estructuras \n(productos), los tipos inductivos pueden tener varios constructores.\n\n\n### Pattern matching \nUn ejemplo de una funcin que usa pattern matching es la funcin `isZero`:\n\n```code :language lean4 :eval true \ndef isZero (n : Nat) : Bool := \n  match n with \n  | Nat.zero => true \n  | Nat.succ k => false\n```\nA la expresin `match`  le damos el argumento `n` para destruirlo. Si `n` se construy \nusando `Nat.zero`, entonces se toma la primera rama del pattern match y el resultado es \n`true`. Si `n` se construy con `Nat.succ`, la segunda rama se toma y resulta en `false`.\n\n### Funciones recursivas \n\nLas definiciones que se refieren al mismo nombre que se est definiendo son llamadas \n*definiciones recursivas*. Los tipos de datos pueden ser recursivos, como `Nat`.\n\nLos tipos de datos recursivos se complementan bien con las funciones recursivas. Por \nejemplo \n\n```code :language lean4 :eval true\ndef even (n : Nat) : Bool := \n  match n with \n  | Nat.zero => true \n  | Nat.succ k => not (even k)\n```\nEste patrn de pensamiento es tpico para las funciones recursivas. Primero hay que \nidentificar que hacer con `Nat.zero` y luego determinar como transformar el resultado de \nun `Nat` a su sucesor. Este patrn es llamado induccin estructural.","src/content/docs/tipos/Lean/Programacion/conociendo.mdx","15343ef8b170e960","tipos/lean/programacion",{"id":246,"data":248,"body":255,"filePath":256,"digest":257,"deferredRender":16},{"title":249,"editUrl":16,"head":250,"template":18,"sidebar":251,"pagefind":16,"draft":20,"sitemap":253},"Programacin en Lean",[],{"hidden":20,"attrs":252},{},{"linkInclusionRules":254},[24],"Estas son mis notas sobre programacin con el lenguaje Lean4","src/content/docs/tipos/Lean/Programacion/index.mdx","1b281bec4ca1d4b6","tipos/lean/teoremas/dependiente",{"id":258,"data":260,"body":266,"filePath":267,"digest":268,"deferredRender":16},{"title":151,"editUrl":16,"head":261,"template":18,"sidebar":262,"pagefind":16,"draft":20,"sitemap":264},[],{"order":130,"hidden":20,"attrs":263},{},{"linkInclusionRules":265},[24],"## Teora de tipos simple \n \nLa teora de tipos obtiene su nombre del hecho de que cada expresin tiene un tipo asociado.\nPor ejemplo, en un contexto dado, $x + theta$ puede denotar un nmero natural y $f$ una\nfuncin.\n\nAqu hay unos ejemplos de como se pueden declarar objetos en Lean y verificar sus tipos \n\n```code :language lean4 :eval true :session tipos-simples\ndef m  : Nat  := 1  -- m es un nmero natural \ndef n  : Nat  := 0\ndef b1 : Bool := true -- b1 es un booleano\ndef b2 : Bool := false\n```\nPodemos mostrar sus tipos\n\n```code :language lean4 :eval true :session tipos-simples\n/- Verificar tipos -/\n#check m\n#check n\n#check n + 0\n#check m * (n + 0)\n#check b1\n\n#check b1 && b2 -- && es el \"y\" booleano\n#check b1 || b2 -- || es el \"o\" booleano\n#check true\n\n/- Evaluar -/\n\n#eval 5 * 4\n#eval m + 2\n#eval b1 && b2\n```\n\nLa palabra clave `def` se usa para declarar nuevos smbolos constantes en el entorno. El \ncomando `#check` le pide a Lean que una constante reporte su tipo, los comandos \nauxiliares que le preguntan informacin al sistema comienzan con `#`. El comando `#eval` \nle pide a Lean que evale una expresin.\n\nLo que hace poderosa a la teora de tipos es que podemos construir nuevos tipos a partir\nde otros. Por ejemplo, si $a$ y $b$ son tipos, $a arrow b$ denota el tipo de funciones de \n$a$ a $b$ y $a times b$ denota el tipo de parejas que consisten de un elemento de $a$ \nemparejado con un elemento de $b$, tambin conocido como el producto cartesiano.\n\nAlgunos ejemplos \n\n```code :language lean4 :eval true :session tipos-simples-2\n#check Nat \\to Nat \n\n#check Nat \\times Nat\n\n#check Prod Nat Nat \n\n#check Nat \\to Nat \\to Nat\n\n#check Nat.succ\n\n#check (0, 1)\n\n#check Nat.add \n\n#check Nat.succ 2 \n\n#check (5, 9).fst \n\n#eval (5,9).snd\n```\n\n## Tipos como objetos \n\nUna forma en la que la teora de tipos dependiente de Lean extiende la teora de tipos simple \nes que los tipos son ciudadanos de primera clase, es decir, que son objetos en s mismos. \n\n```code :language lean4 :eval true \n#check Nat \n\n#check Bool \n\n#check Nat \\to Bool \n\n#check Nat \\times Bool\n\n#check Nat \\to Nat\n```\n\nTambin podemos declarar nuevas constantes de tipos \n\n```code :language lean4 :eval true \ndef \\alpha : Type := Nat \ndef \\beta  : Type := Bool\ndef F      : Type \\to Type := List \ndef G      : Type \\to Type \\to Type := Prod\n\n#check \\alpha\n#check F \\alpha \n#check G \\alpha \n#check G \\alpha \\beta \n#check G \\alpha Nat\n```\n\nComo toda expresin tiene un tipo en Lean, es natural preguntarse cual es el tipo de Type.\n\n```code :language lean4 :eval true \n#check Type \n#check Type 1 \n#check Type 2 \n#check Type 3\n```\n\nEn los fundamentos de Lean hay una jerarqua infinita de tipos. Podemos pensar en \n`Type 0` como el universo de tipos pequeos u ordinarios. `Type 1` es entonces un \nuniverso de tipos todava ms grande, que contiene a `Type 0` como elemento y as\nsucesivamente. \n\nAlgunas operaciones necesitan ser polimorfas sobre universos de tipos. Por ejemplo, \n`List \\alpha` debe hacer sentido para cualquier tipo $alpha$, sin importar el universo en \nel que $alpha$ habite. Esto explica el tipo de la funcin `List` :\n\n```code :language lean4 :eval true \n#check List \n```\nAqu u es una variable que vara sobre todos los niveles de tipos. La salida del comando \n`#check` significa que siempre que $alpha$ tiene tipo `Type u`, `List \\alpha` tambin tiene \ntipo `Type u`. La funcin `Prod` es tambin polimorfa \n\n```code :language lean4 :eval true \n#check Prod \n```\nPara declarar constantes polimorfas, Lean permite declarar variables de universo \nexplcitamente usando el comando `universe`:\n\n```code :language lean4 :eval true \nuniverse u \n\ndef F (\\alpha : Type u) : Type u := Prod \\alpha \\alpha\n\n#check F\n```\n\nPodemos evitar el comando `universe` dando directamente parmetros de universo cuando \ndefinimos `F`: \n\n```code :language lean4 :eval true \ndef F.{u} (\\alpha : Type u) : Type u := Prod \\alpha \\alpha \n\n#check F\n```\n## Abstraccin de funciones y evaluacin\n\nLean da una palabra clave `fun` (o $lambda$) para crear una funcin a partir de una \nexpresin de la siguiente manera:\n\n```code :language lean4 :eval true \n#check fun (x : Nat) => x + 5\n\n#check \\lambda (x : Nat) => x + 5\n```\n\nEl tipo `Nat` pude ser inferido en este ejemplo \n\n```code :language lean4 :eval true \n#check fun x => x + 5\n\n#check \\lambda x => x + 5\n```\n\nPodemos evaluar una funcin lambda pasando los parmetros requeridos:\n\n```code :language lean4 :eval true \n#eval (\\lambda x : Nat => x + 5) 10 \n```\nCrear una funcin a partir de una expresin es un proceso conocido como *lambda abstraccin*.\nSupongamos que tenemos una variable $x: alpha$ y construimos una expresin $t: beta$, \nentonces la expresin `fun (x : \\alpha) => t` o, de forma equivalente, \n`\\lambda (x : \\alpha) => t` es un objeto de tipo $alpha arrow beta$.\nAqu tenemos algunos ejemplos \n\n```code :language lean4 :eval true \n#check fun x: Nat => fun y : Bool => if not y then x + 1 else x + 2 \n\n#check fun (x : Nat) (y : Bool) => if not y then x + 1 else x + 2\n\n#check fun x y => if not y then x + 1 else x + 2\n```\n\nAlgunas operaciones de funciones comunes se pueden expresar en trminos de lambda \nabstraccin:\n\n```code :language lean4 :eval true \ndef f (n : Nat) : String := toString n \ndef g (s : String) : Bool := s.length > 0\n\n#check fun x : Nat => x \n\n#check fun x : Nat => true \n\n#check fun x : Nat => g (f x)\n\n#check fun x => g (f x)\n```\n\nPodemos pasar funciones como parmetros:\n\n```code :language lean4 :eval true \n#check fun (g : String \\to Bool) (f : Nat \\to String) (x : Nat) => g (f x) \n```\n\nTambin podemos pasar tipos como parmetros \n\n```code :language lean4 :eval true \n#check fun (\\alpha \\beta \\gamma : Type) (g : \\beta \\to \\gamma) (f : \\alpha \\to \\beta) (x : \\alpha) => g (f x) \n```\n\n## Definiciones \n\nRecordemos que `def` nos da una manera de declarar nuevos objetos nombrados.\n\n```code :language lean4 :eval true \ndef double (x : Nat) : Nat :=\n  x + x\n```\nAqu podemos pensar en `def` como una `fun` nombrada.\n\n## Definiciones locales\n\nLean tambin permite introducir definiciones locales con la palabra clave `let`. La \nexpresin `let a := t1; t2` es definicionalmente igual a reemplazar todas las ocurrencias \nde `a` en `t2` por `t1`. El `;` se puede omitir si se usa un salto de lnea.\n\nNotemos que el significado de la expresin `let a := t1; t2` es muy similar al significado \nde `fun a => t2`, pero no son lo mismo. \n\n## Variables y secciones \n\nConsideremos las siguientes definiciones: \n\n```code :language lean4 :eval true \ndef compose (\\alpha \\beta \\gamma : Type) (g : \\beta \\to \\gamma) (f : \\alpha \\to \\beta) (x : \\alpha) : \\gamma :=\n  g (f x)\n\ndef doTwice (\\alpha : Type) (h : \\alpha \\to \\alpha) (x : \\alpha) : \\alpha := \n  h (h x)\n\ndef doThrice (\\alpha : Type) (h : \\alpha \\to \\alpha) (x : \\alpha) : \\alpha :=\n  h (h (h x))\n```\n\nLean nos da un comando `variable` para hacer estas declaraciones ms compactas \n\n```code :language lean4 :eval true \nvariable (\\alpha \\beta \\gamma : Type)\n\ndef compose (g : \\beta \\to \\gamma) (g : \\alpha \\to \\beta) (x : \\alpha) : \\gamma := \n  g (f x)\n\ndef doTwice (h : \\alpha \\to \\alpha) (x : \\alpha) : \\alpha := \n  h (h x)\n\ndef doThrice (h : \\alpha \\to \\alpha) (x : \\alpha) : \\alpha := \n  h (h (h x))\n```\n\nEl comando `variable` instruye a Lean para que inserte las variables declaradas como ligadas\nen las definiciones que las usan por su nombre. La variable permanece en el entorno del \narchivo en el que estamos trabajando. Para limitar los alcances, podemos usar `section`:\n\n```code :language lean4 :eval true \nsection useful \n  variable (\\alpha \\beta \\gamma : Type)\n  variable (g : \\beta \\to \\gamma) (f : \\alpha \\to \\beta) (h : \\alpha \\to \\alpha)\n  variable (x : \\alpha)  \n\n  def compose := g ( f x )\n  def doTwice := h (h x)\n  def doThrice := h (h (h x))\nend useful\n```\nNo se necesitan nombrar las secciones.\n\n## Espacios de nombres \n\nLean nos da la habilidad de agrupar definiciones en espacios de nombres \n\n```code :language lean4 :eval true \nnamespace Foo \n  def a : Nat := 5\n  def f (x : Nat) : Nat := x + 7\n\n  def fa : Nat := f a\n  def ffa : Nat := f (f a)\n  \n  #check a\nend Foo \n\n#check Foo.a\n\nopen Foo \n#check a \n```\n\n## Qu hace dependiente a la teora de tipos dependientes?\n\nEn pocas palabras, los tipos pueden depender de parmetros. Ya vimos esto, como con \n`List` y `Prod`, tambin, por ejemplo, esta `Vec \\alpha n`, el tipo de los vectores \nde elementos de $alpha$ de longitud $n$.\n\n```code :language lean4 :eval true \ndef cons (\\alpha : Type) (a : \\alpha) (as : List \\alpha) : List \\alpha := \n  List.cons a as \n\n#check cons Nat \n\n#check cons Bool \n\n#check cons \n```\n\nEsto es una instancia de un tipo funcin dependiente, o *tipo flecha dependiente*. \nTambin tenemos productos dependiente o $Sigma$-tipos, se pueden escribir como \n`\\Sigma a : \\alpha, \\beta a`, donde `\\beta : \\alpha \\to Type u`. \nPodemos usar `\\langle a, b \\rangle` o  `Sigma.mk a b` para crear un par dependiente.\n\n```code :language lean4 :eval true\nuniverse u v\n\ndef f (\\alpha : Type u) (\\beta : \\alpha \\to Type v) (a : \\alpha) (b : \\beta a) : (a : \\alpha) \\times \\beta a := \n  \\langle a, b \\rangle \n\ndef g (\\alpha : Type u) (\\beta : \\alpha \\to Type v) (a : \\alpha) (b : \\beta a) : \\Sigma a : \\alpha, \\beta a := \n  Sigma.mk a b\n\ndef h1 (x : Nat) : Nat := \n  (f Type (fun \\alpha => \\alpha) Nat x).2\n\n#eval h1 5\n\ndef h2 (x : Nat) : Nat := \n  (g Type (fun \\alpha => \\alpha) Nat x).2\n\n#eval h2 5\n```\n## Argumentos implcitos \n\nSupongamos que tenemos una implementacin de listas como \n\n```code :language lean4 :eval true :session listas\nuniverse u\ndef Lst ( : Type u) : Type u := List \ndef Lst.cons ( : Type u) (a : ) (as : Lst ) : Lst  := List.cons a as\ndef Lst.nil ( : Type u) : Lst  := List.nil\ndef Lst.append ( : Type u) (as bs : Lst ) : Lst  := List.append as bs\n\n#check Lst \n\n#check Lst.cons \n\n#check Lst.nil \n\n#check Lst.append \n\n```\nEntonces podemos construir listas de naturales como: \n\n```code :language lean4 :eval true :session listas \n\n#check Lst.cons Nat 0 (Lst.nil Nat)\n\ndef as1 : Lst Nat := Lst.nil Nat \ndef bs1 : Lst Nat := Lst.cons Nat 5 (Lst.nil Nat)\n\n#check Lst.append Nat as1 bs1\n\n```\n\nComo los constructores son polimorfos sobre tipos, tenemos que insertar el tipo `Nat` como \nun argumento repetidamente. Pero esta informacin es redundante, uno puede inferir el \nargumento $alpha$ en `Lst.cons Nat 5 (Lst.nil Nat)` del hecho de que el segundo argumento,\n5, tiene tipo `Nat`. En Lean, podemos usar `_` para especificar que el sistema debe \nllenar la informacin automticamente. Esto es conocido como un argumento implcito.\n\n```code :language lean4 :eval true :session listas\n#check Lst.cons _ 0 (Lst.nil _)\n\ndef as : Lst Nat := Lst.nil _\ndef bs : Lst Nat := Lst.cons _ 5 (Lst.nil _)\n\n#check Lst.append _ as bs\n```\n\nCuando una funcin toma un argumento que se puede inferir generalmente del contexto, Lean \npermite especificar que dicho argumento debe, por defecto, dejarse implcito. Esto lo hacemos\nponiendo los argumentos entre llaves:\n\n```code :language lean4 :eval true \nuniverse u \ndef Lst (\\alpha : Type u) : Type u := List \\alpha \n\ndef Lst.cons {\\alpha : Type u} (a : \\alpha) (as : Lst \\alpha) : Lst \\alpha := \n  List.cons a as \n\ndef Lst.nil {\\alpha : Type u} : Lst \\alpha := List.nil\ndef Lst.append {\\alpha : Type u} (as bs : Lst \\alpha) : Lst \\alpha := List.append as bs\n```\n\nTambin podemos usar esto para definir funciones \n\n```code :language lean4 :eval true \nuniverse u \ndef ident {\\alpha : Type u} (x : \\alpha) := x\n\n#check ident \n#check (ident)\n#check ident 1 \n#check ident \"hello\"\n#check @ident\n```\nLas variables tambin se pueden dejar implcitas \n\n```code :language lean4 :eval true \nuniverse u \n\nsection \n  variable {\\alpha : Type u}\n  variable (x : \\alpha)\n  def ident := x\nend\n```\nA veces necesitamos que un argumento a una funcin sea explcito a pesar de que lo hayamos \ndefinido como implcito, para eso podemos usar `@`, por ejemplo, si la funcin `foo` tiene \nargumentos implcitos, los volvemos implcitos con `@foo`, `@foo` denota la misma funcin \npero con todos los argumentos hechos explcitos.","src/content/docs/tipos/Lean/Teoremas/dependiente.mdx","35d6ed3e3cc44201","tipos/lean/teoremas",{"id":269,"data":271,"body":278,"filePath":279,"digest":280,"deferredRender":16},{"title":272,"editUrl":16,"head":273,"template":18,"sidebar":274,"pagefind":16,"draft":20,"sitemap":276},"Demostracin de teoremas",[],{"order":104,"hidden":20,"attrs":275},{},{"linkInclusionRules":277},[24],"Estas son mis notas sobre demostracin de teoremas en Lean.","src/content/docs/tipos/Lean/Teoremas/index.mdx","cbdbec239d2d70f9","tipos/lean/teoremas/proposiciones",{"id":281,"data":283,"body":290,"filePath":291,"digest":292,"deferredRender":16},{"title":284,"editUrl":16,"head":285,"template":18,"sidebar":286,"pagefind":16,"draft":20,"sitemap":288},"Proposiciones y pruebas",[],{"order":65,"hidden":20,"attrs":287},{},{"linkInclusionRules":289},[24],"## Proposiciones como tipos \nHay al menos dos maneras de pensar a las proposiciones como tipos. Para la primera, una \nproposicin $p$ representa un cierto tipo de dato, a saber, una especificacin del tipo de \ndatos que constituye una prueba. Una prueba de $p$ es simplemente un objeto $t : p$ del \ntipo correcto. Para la segunda, pensamos esto como un truco, si $p$ es falsa entonces \nes un tipo vaco y si es verdadera, tiene un elemento $star$. Sea da el caso de que las \nreglas de la aplicacin de funciones y la abstraccin nos permiten llevar las cuentas de \nqu proposiciones estn habitadas. As, construir un elemento $t : P$ nos dice que $p$ \nes verdadera. \n\nEstas dos maneras de pensar las proposiciones como tipos difieren en una manera fundamental.\nDesde el punto de vista constructivo, las demostraciones son objetos matemticos *denotados*\npor expresiones adecuadas en la teora de tipos. Si lo pensamos como un mero truco, las \nexpresiones no cargan consigo nada interesante. \n\nEn cualquier caso, para expresar una afirmacin matemtica en la teora de tipos, \nnecesitamos exhibir un trmino $p : \"Prop\"$. Para probar la afirmacin, necesitamos exhibir \nun trmino $t : p$.\n\n## Trabajando con las proposiciones como tipos \nEn el paradigma de las proposiciones como tipos, los teoremas que slo involucran $arrow$ \npueden demostrarse usando lambda abstraccin y aplicacin. En Lean, el comando `theorem` \nintroduce un nuevo teorema \n\n```code :language lean4 :eval true \nvariable {p q : Prop}\n\ntheorem t1 : p \\to q \\to p := \n  fun hp : p => fun hq : q => hp\n\n#check t1 \n```\nComparemos esta demostracin con la expresin `fun x : \\alpha => fun y : \\beta => x` de tipo \n$alpha arrow beta arrow alpha$, donde $alpha$ y $beta$ son tipos de datos. Esto describe \nla funcin que toma $x$ y $y$ de tipos $alpha$ y $beta$, respectivamente y regresa $x$.\nLa demostracin de $t 1$ tiene la misma forma, solo que $p$ y $q$ son de tipo `Prop` en \nlugar de `Type`. Intuitivamente, nuestra demostracin de $p arrow q arrow p$ asume que \n$p$ y $q$ son verdaderas y usa la primer hiptesis para establecer la conclusin, p es \nverdadera.\n\nNotemos que el comando `theorem` es realmente una versin de `def`.\n\nComo con las definiciones, el comando `#print` muestra la prueba de un teorema: \n\n```code :language lean4 :eval true \nvariable {p q : Prop}\n\ntheorem t1 : p \\to q \\to p := \n  fun hp : p => fun hq : q => hp \n\n#print t1\n```\nNotemos que las lambda abstracciones $h p : p$ y $h q : q$ pueden verse como suposiciones \ntemporales en la prueba de $t 1$. Lean tambin permite especificar el tipo del trmino final \n$h p$ explcitamente con el enunciado `show`:\n\n```code :language lean4 :eval true \nvariable {p q : Prop}\n\ntheorem t1 : p \\to q \\to p := \n  fun hp : p => \n  fun hq : q =>\n  show p from hp\n```\nComo con las definiciones, podemos mover las variables del lado izquierdo de los dos puntos:\n\n```code :language lean4 :eval true \nvariable {p q : Prop}\n\ntheorem t1 (hp : p) (hq : q) : p := hp\n\n#print t1\n\n```\nPodemos usar $t 1$ como cualquier otra funcin: \n\n```code :language lean4 :eval true \nvariable {p q : Prop}\n\ntheorem t1 (hp : p) (hq : q) : p := hp\n\naxiom hp : p \n\ntheorem t2 : q \\to p := t1 hp\n```\n\nLa declaracin `axiom` postula la existencia de un elemento de un tipo dado y puede \ncomprometer la consistencia lgica. Por ejemplo, podemos hacer: \n\n```code :language lean4 :eval true \naxiom unsound : False \n\ntheorem ex : 1 = 0 := \n  False.elim unsound\n```\n\nRecordemos aqu que el principio de eliminacin (induccin) para el tipo vaco \n(es decir, `False`) nos dice que para cada familia de tipos $P$ indizada por \n$x : emptyset$ (es decir, `False`), existe una funcin\n\n$ \"ind\" _emptyset : Pi_((x : emptyset)) P(x), $\n\nde modo que, si tomamos a $P$ como una familia constante $A$, obtenemos un elemento \n\n$ \"ex-falso\" := \"ind\" _emptyset : emptyset arrow A.$\n\nAs, cuando escribimos `False.elim` en Lean, no estamos haciendo ms que referirnos a la \nfuncin $\"ind\" _emptyset$. Para ms informacin se puede consultar \n[tipos inductivos](/tipos/rijke/inductivo#definicion-4-3-1)\n\n## Conjuncin \nLa expresin `And.intro h1 h2` construye una prueba de `p \\land q` usando pruebas `h1 : p`\ny `h2 : q`. Observemos que `And.intro` no es ms que el principio de introduccin para \nel tipo producto no dependiente (o $Sigma$-tipo no dependiente).\nEn pocas palabras, este principio nos dice que si tenemos tipos $A$ y $B$ y trminos $a : A$ \ny $b : B$, podemos introducir el elemento $(a, b) : A times B$. Se puede aprender ms sobre \nel tema aqu [tipos inductivos](/tipos/rijke/inductivo#definicion-4-6-1)\n\nEn el siguiente ejemplo, usamos `And.intro` para crear una prueba de \n$p arrow q arrow p and q$.\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (hp : p) (hq : q) : p \\land q := And.intro hp hq\n\n#check fun (hp : p) (hq : q) => And.intro hp hq\n```\n\nEl comando `example` se usa para enunciar un teorema sin darle nombre ni guardarlo \npermanentemente en el contexto. Esencialmente, slo verifica que el trmino dado tenga \nel tipo adecuado.\n\nLa expresin `And.left h` crea una prueba de $p$ a partir de una prueba $h: p and q$. \nSimilarmente, `And.right h` crea una prueba de $q$ a partir de una prueba $h : p and q$.\nEstas son conocidas como las reglas de eliminacin izquierda y derecha, que no son ms que \nlas funciones de proyeccin [tipos inductivos](/tipos/rijke/inductivo#definicion-4-6-2).\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\land q) : p := And.left h \nexample (h : p \\land q) : q := And.right h\n```\nAhora podemos probar $p and q arrow q and p$ con el siguiente trmino:\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\land q) : q \\land p :=\n  And.intro (And.right h) (And.left h)\n```\nNotemos que la introduccin y eliminacin de la conjuncin son muy similares a las \noperaciones de emparejamiento y proyeccin de los productos cartesianos. En realidad son \nlo mismo, slo que la conjuncin acta nicamente sobre proposiciones y el producto \nsobre tipos (no proposiciones). Esta distincin se hace cumplir en Lean.\nLa similitud entre $and$ y $times$ es otra instancia del isomorfismo de Curry-Howard.\nLa demostracin que acabamos de construir es similar a la funcin que intercambia las \nentradas de una pareja ordenada.\n\nVeremos ms adelante que ciertos tipos en Lean son *estructuras*, es decir, su tipo est \ndefinido con un nico *constructor* cannico, que construye un elemento del tipo a partir \nde una sucesin de argumentos adecuados. Para cada `p q : Prop`, `p \\land q` es un ejemplo:\nla forma cannica de construir un elemento es aplicar `And.intro` a argumentos adecuados \n`hp : p` y `hq : q`. Lean nos permite usar la notacin de constructor annimo \n`\\langle arg1, arg2, ... \\rangle` en situaciones como estas, cuando el tipo relevante es \nun tipo inductivo y se puede inferir del contexto. En particular, podemos escribir \n`\\langle hp, hq \\rangle` en lugar de `And.intro hp hq`:\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\nvariable (hp : p) (hq : q)\n\n#check (\\langle hp, hq \\rangle : p \\land q)\n```\nLean nos da una herramienta sintctica til. Dada una expresin $e$ de un tipo inductivo \n`Foo`, la notacin `e.bar` es una abreviacin para `Foo.bar e`. Esto da una forma conveniente\nde acceder a funciones sin abrir un espacio de nombres. Las siguientes expresiones \nsignifican lo mismo: \n\n```code :language lean4 :eval true \nvariable (xs : List Nat)\n\n#check List.length xs \n\n#check xs.length\n```\nComo resultado, dada `h: p \\land q`, podemos escribir `h.left` en lugar de `And.left h` y \n`h.right` en lugar de `And.right h`. As, nuestra prueba queda como: \n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\land q) : q \\land p := \n  \\langle h.right, h.left \\rangle\n```\n## Disyuncin \n\nLa expresin `Or.intro_left q hp` crea una prueba de `p \\lor q` a partir de una prueba de \n`hp : p`. Similarmente, `Or.intro_right p hq` crea una prueba de `p \\lor q` a partir de una \nprueba de `hq : q`. Estas son las reglas de introduccin izquierda y derecha.\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (hp : p) : p \\lor q := Or.intro_left q hp \nexample (hq : q) : p \\lor q := Or.intro_right p hq\n```\n\nLa regla de eliminacin para la disyuncin es un poco ms complicada. La idea es que podemos\nprobar $r$ a partir de $p or q$ mostrando que $r$ se sigue de $p$ y $r$ se sigue de $q$, es \ndecir, es una prueba por casos. \nNotemos que esto no es ms que el principio de induccin para co-productos (no dependientes)\nque dice que, dada una familia de tipos $P$ indizada por $z : A + B$, existe un trmino \n$ \"ind\"_+ : (Pi_((x : A)) P(\"inl\"(x))) arrow (Pi_((y : B)) P(\"inr\"(y)) arrow Pi_((z : A + B)) P(z)) $\nSi tomamos a $P$ como la familia constante $r$, a $A$ y $B$ como $p$ y $q$ y a `+` lo \nescribimos como `\\lor`, obtenemos un trmino \n$ \"ind\"_+ : (p arrow r) arrow ((q arrow r) arrow (p \\lor q arrow r)) $\n\nSi ahora llamamos $h p r$ y $h q r$ a las pruebas de $p arrow r$ y $q arrow r$, \nrespectivamente, entonces\n$ \"ind\" _+ (h p r, h q r) : p \\lor q arrow r, $\n\nes decir, obtenemos una prueba de $p \\lor q arrow r$ y, si $h p q$ es una prueba de $p or q$,\nentonces $\"ind\"_+ (h p r, h q r, h p q) : r$ es una prueba de $r$. Podemos ver ms acerca de \nesto [aqu](/tipos/rijke/inductivo#definicion-4-4-1).\n\nVolviendo a Lean, en la expresin `Or.elim hpq hpr hqr`, `Or.elim` toma tres argumentos, \n`hpq: p \\lor q`, `hpr: p \\to r` y `hqr : q \\to r` y produce un prueba de `r`. En el \nsiguiente ejemplo usamos `Or.elim` para probar que `p \\lor q \\to q \\lor p`.\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\lor q) : q \\lor p := \n  let proofpr (hp : p) := Or.intro_right q hp \n  let proofqr (hq : q) := Or.intro_left p hq \n  show q \\lor p from Or.elim h proofpr proofqr\n```\nO, escrito ms annimamente: \n\n```code :language lean4 :eval true\nvariable (p q : Prop)\n\nexample (h : p \\lor q) : q \\lor p := \n  Or.elim h \n    (fun hp : p =>\n      show q \\lor p from Or.intro_right q hp)\n    (fun hq : q => \n      show q \\lor p from Or.intro_left p hq)\n```\nEn la mayora de los casos, el primer argumento de `Or.intro_right` y `Or.intro_left` puede \nser inferido automticamente por Lean. As, lean da `Or.inr` y `Or.inl`. De esta forma, \npodemos reescribir nuestra prueba como:\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\lor q) : q \\lor p := \n  let proofpr (hp : p) := Or.inr hp \n  let proofqr (hq : q) := Or.inl hq \n  show q \\lor p from Or.elim h proofpr proofqr\n```\nO, de nuevo, de manera annima \n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\lor q) : q \\lor p := \n  Or.elim h (fun hp : p => Or.inr hp) (fun hq : q => Or.inl hq)\n```\nComo `Or` tiene dos constructores, no podemos usar notacin de constructor annimo. Pero \ns podemos escribir `h.elim` en lugar de `Or.elim h`: \n\n```code :language lean4 :eval true \nvariable (p q : Prop) \n\nexample (h : p \\lor q) : q \\lor p := \n  h.elim (fun hp : p => Or.inr hp) (fun hq : q => Or.inl hq)\n```\n\n## Negacin y falsedad \n\nLa negacin $not p$ se define como $p arrow \"False\"$, de modo que obtenemos $not p$ \nderivando una contradiccin a partir de $p$. De forma similar, la expresin `hnp hp` \nproduce una demostracin de `False` a partir de `hp : p` y `hnp : \\lnot p`.\nAqu hay un ejemplo: \n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (hpq : p \\to q ) (hnq : \\lnot q) : \\lnot p := \n  fun hp : p =>\n  show False from hnq (hpq hp)\n```\n`False` tiene una sola regla de eliminacin, `False.elim`, que expresa que cualquier cosa \nse sigue de una contradiccin. Esta regla es llamada *ex falso* o el principio de explosin.\nPodemos leer ms [aqu](/tipos/rijke/inductivo#definicion-4-3-1)\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (hp : p) (hnp : \\lnot p) : q := False.elim (hnp hp) \n```\nEl hecho arbitrario `q`, que se sigue de la falsedad, es un argumento implcito en \n`False.elim` y se infiere automticamente. Este patrn de derivar un hecho arbitrario a \npartir de hiptesis contradictorias es muy comn y es representado por `absurd`.\nPor ejemplo: \n\n```code :language lean4 :eval true \nvariable (p q r : Prop) \n\nexample (hnp : \\lnot p) (hq : q) (hqp : q \\to p) : r := \n  absurd (hqp hq) hnp\n```\nIncidentalmente, as como `False` tiene una sola regla de eliminacin, `True` tiene una \nsola regla de introduccin, `True.intro : True`. Es decir, `True` es simplemente verdadera \ny tiene una prueba cannica, `Ture.intro`.\n\n## Equivalencia lgica \n\nLa expresin `Iff.intro h1 h2` produce una prueba de $p arrow.r.l q$ a partir de \n$h1 : p arrow q$ y $h2 : q arrow p$. La expresin `Iff.mp h` (modus ponens) produce una\nprueba de $p arrow q$ a partir de $h : p arrow.r.l q$. Similarmente `Iff.mpr h` produce \nuna prueba de $q arrow p$ a partir de $h : p arrow.r.l q$. Aqu hay una prueba de \n$p and q arrow.r.l q and p$:\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\ntheorem and_swap : p \\land q \\leftrightarrow q \\land p := \n  Iff.intro \n    (fun h : p \\land q =>\n      show q \\land p from And.intro (And.right h) (And.left h))\n    (fun h : q \\land p =>\n      show p \\land q from And.intro (And.right h) (And.left h))\n\n#check and_swap p q \n\nvariable (h : p \\land q)\nexample : q \\land p := Iff.mp (and_swap p q) h\n```\nPodemos usar la notacin de constructor annimo para construir una prueba de \n$p arrow.r.l q$ a partir de las dos direcciones, tambin podemos usar la notacin de `.`\npara `mp` y `mpr`.\n\nNotemos que la regla de introduccin de $arrow.r.l$ no es ms que la regla de introduccin \nde la conjuncin y que `mp` y `mpr` son las reglas de eliminacin izquierda y derecha.\n\n## Introduciendo metas auxiliares\n\nOtra construccin importante en Lean es `have`, que permite introducir metas auxiliares en \nuna prueba.\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\land q) : q \\land p := \n  have hp : p := h.left \n  have hq : q := h.right \n  show q \\land p from And.intro hq hp\n\n```\nInternamente, la expresin `have h : p := s; t`produce el trmino `(fun (h : P) => t) s`.\nEn otras palabras, `s` es una prueba de `p` y `t` es una prueba de la conclusin deseada \nasumiendo `h : p` y las dos se combinan en una lambda abstraccin y aplicacin.\n\nLean tambin soporta una forma estructurada de razonar en reversa a partir de una prueba, \nque modela el \"es suficiente probar que ...\" de la matemtica usual.\n\n\n```code :language lean4 :eval true \nvariable (p q : Prop)\n\nexample (h : p \\land q) : q \\land p :=\n  have hp : p := h.left \n  suffices hq : q from And.intro hq hp \n  show q from And.right h\n```\nEscribir `suffices hq : q` nos deja con dos metas. Primero, debemos mostrar que es \nsuficiente mostrar `q`, probando la meta `q \\land p` con la hiptesis adicional `hq : q`.\nFinalmente, debemos probar `q`.\n\n## Lgica clsica\n\nLas reglas de introduccin y eliminacin que hemos vistos son todas constructivas, es \ndecir, reflejan un entendimiento computacional de los conectivos lgicos basado en la \ncorrespondencia de proposiciones como tipos. La lgica clsica aade a esto la ley \ndel tercio excluso, `p \\lor \\lnot p`. Para usar este principio, tenemos que abrir el \nespacio de nombres `Classical`.\n\n```code :language lean4 :eval true \nopen Classical \n\nvariable (p : Prop)\n\n#check em p\n```\nintuitivamente, el \"O\" constructivo es muy fuerte: afirmar `p \\lor q` implica saber cual \nde los dos es el caso. Si `RH` representa la Hiptesis de Riemmann, un matemtico clsico \nest dispuesto a aceptar que `RH \\lor \\lnot RH`, a pesar de que no podemos afirmar \nninguno de los componentes. \n\nUna consecuencia del tercio excluso es el principio de eliminacin de la doble negacin:\n\n```code :language lean4 :eval true \nopen Classical \n\ntheorem dne {p : Prop} (h : \\lnot \\lnot p) : p := \n  Or.elim (em p)\n    (fun hp : p => hp)\n    (fun hnp : \\lnot p => absurd hnp h)  \n```\nLa doble negacin permite probar una proposicin `p` asumiendo `\\lnot p` y derivando \n`False`, pues esto es lo mismo que probar `\\lnot \\lnot p`. En otras palabras, la \neliminacin de la doble negacin permite llevar a cabo pruebas por contradiccin, algo\nque en general, no es posible en la lgica constructiva. Como ejercicio, deberamos \nprobar que se puede demostrar `em p` a partir del principio de eliminacin de la doble \nnegacin:\n\nLa prueba es la siguiente, apoyndonos sobre una de las leyes de De Morgan:\n\n```code :language lean4 :eval true \n\naxiom dn {p : Prop} :   p  p\n\ndef morgan {p q : Prop} :  (p  q)    p   q :=  \n  fun (hn :  (p  q)) => \n    And.intro \n      (fun (hp : p) => absurd (Or.intro_left q hp) hn)\n      (fun (hq : q) => absurd (Or.intro_right p hq) hn) \n\n      \ndef em {p : Prop} : p   p := \n  suffices hnn :   (p   p) from dn hnn \n  show   (p   p) from \n    fun hnpp :  (p   p) => \n      have hnp :  p := (morgan hnpp).left  \n      have hp : p := dn (morgan hnpp).right      \n      absurd hp hnp \n\n```\nLos axiomas clsicos nos dan acceso a patrones de prueba que se pueden justificar apelando \na `em`. Por ejemplo, se pueden llevar a cabo las demostraciones por casos:\n\n```code :language lean4 :eval true \nopen Classical \n\nvariable (p : Prop)\n\nexample (h : \\lnot \\lnot p) : p := \n  byCases \n    (fun h1 : p => h1)\n    (fun h1 : \\lnot p => absurd h1 h)\n```\n\nO podemos llevar a cabo pruebas por contradiccin:\n\n```code :language lean4 :eval true  \nopen Classical \nvariable (p : Prop)\n\nexmaple (h : \\lnot \\lnot p) : p := \n  byContradiction \n    (fun h1 : \\lnot p => \n      show False from h h1)\n```\nSi no estamos acostumbrados a pensar de forma constructiva, puede que nos lleve un poco \n  de tiempo detectar dnde se usa el razonamiento clsico.","src/content/docs/tipos/Lean/Teoremas/proposiciones.mdx","7edb9159721ec619","nix/nixos/start",{"id":293,"data":295,"body":302,"filePath":303,"digest":304,"deferredRender":16},{"title":296,"editUrl":16,"head":297,"template":18,"sidebar":298,"pagefind":16,"draft":20,"sitemap":300},"Empezando con NixOS",[],{"order":104,"hidden":20,"attrs":299},{},{"linkInclusionRules":301},[24],"La configuracin por defecto para NixOS est en `/etc/nixos/configuration.nix`. Este \narchivo contiene toda la configuracin declarativa del sistema, incluyendo configuraciones \nde la zona horaria, lenguaje, teclado, redes, usuarios, sistema de archivos y opciones de \nbooteo.\n\nPara modificar el sistema de manera reproducible (lo cual es recomendado), necesitamos \nmodificar manualmente este archivo y luego ejecutar `sudo nixos-rebuild switch` para \naplicar las modificaciones. Este comando genera un nuevo entorno del sistema basado en \nla configuracin modificada, configura el nuevo entorno como el entorno por defecto y \npreserva la configuracin anterior en las opciones de booteo de grub/systemd-boot. Esto \nasegura que siempre podamos regresar al entorno anterior, incluso si el nuevo deja de \nbootear.\n\nMientas que `/etc/nixos/configuration.nix` es el mtodo clsico para configurar NixOS, \ndepende de fuentes de datos configuradas por `nix-channel` y no tiene bloque de versiones, \nlo que hace difcil la reproducibilidad del sistema. Un mejor acercamiento es usar Flakes,\nque dan reproducibilidad y mejor manejo de configuracin.\n\nEn esta seccin aprenderemos a manejar NixOS con el mtodo clsico.\n\n# Configurando el sistema usando  `/etc/nixos/configuration.nix`\n\nPara ilustrar como usar `/etc/nixos/configuration.nix`, consideremos un ejemplo donde \nhabilitamos SSH y aadimos un usuario llamado `ryan` al sistema. Podemos lograrlo de \nesta manera \n\n```code :language nix :eval false \n{ config, pkgs, ... } :\n\n{\n  imports = [\n    ./hardware-configuration.nix \n  ];\n\n  # Aadir el usuario ryan \n  \n  users.user.ryan = {\n    isNormalUser = true;\n    description = \"ryan\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    openssh.authorizedKeys.keys = [\n      \"ssh-ed25519 \u003Csome-public-key> ryan@ryan-pc\"\n    ];\n    packages = with pkgs; [\n      firefox \n    ];\n  };\n  \n  services.openssh = {\n    enable = true;\n    settings = {\n      X11Forwarding = true;\n      PermitRootLogin = \"no\";\n      PasswordAuthentication = false;\n    };\n    openFirewall = true;\n  };\n}\n```\nEn este configuracin declaramos nuestra intencin de habilitar el servicio openssh, \naadimos una llave pblica de SSH para el usuario `ryan` y deshabilitamos el login con \ncontrasea.\n\nPara usar la configuracin modificada, corremos `sudo nixos-rebuild switch`. Este comando \naplicar los cambios, generar un nuevo entorno del sistema y lo configura como por defecto.\nAhora podemos hacer login al sistema usando SSH con las llaves configuradas.","src/content/docs/nix/NixOS/start.mdx","d6251274688893ec","nix/nixos/introduccion-flakes",{"id":305,"data":307,"body":314,"filePath":315,"digest":316,"deferredRender":16},{"title":308,"editUrl":16,"head":309,"template":18,"sidebar":310,"pagefind":16,"draft":20,"sitemap":312},"Introduccin a los Flakes",[],{"order":130,"hidden":20,"attrs":311},{},{"linkInclusionRules":313},[24],"La caracterstica experimental de los flakes es un avance mayor de Nix, introduce una \npoltica para manejar dependencias entre expresiones de Nix, mejor la reproducibilidad, \ncomponibilidad y el uso del ecosistema de Nix. Aunque es experimental es muy usada.\n\nLos Flakes introducen un archivo `flake.nix` para describir las dependencias entre \npaquetes. Adicionalmente, nos da un archivo `flake.lock`, para bloquear las versiones de \nlas dependencias, asegurando la reproducibilidad.\n\n## La nueva CLI y la CLI clsica\n\nNix introdujo dos caractersticas experimentales, `nix-command` y `flakes` en 2020.\nEstas caractersticas traen consigo una nueva interfaz de la lnea de comandos, una \nestructura estandarizada de definicin de paquetes de Nix (conocida como flakes) y \ncaractersticas como `flake.lock`.\n\nAqu enlistamos los conceptos de la CLI que ya no se necesitan en la nueva CLI y en los \nflakes:\n\n1. `nix-channel`: `nix-channel` maneja las versiones de los inputs como `nixpkgs` a travs \n  de canales estable/inestable. Esto es lo que tradicionalmente provee `\u003Cnixpkgs>` en el \n  lenguaje Nix.\n  1. En los Flakes, la funcionalidad de `nix-channel` es reemplazada pro el Flake registry \n    (`nix-registry`). Cuando usamos `flake.nix`, las versiones de los inputs son manejadas \n    directamente por el flake mismo.\n  2. Los flakes usan una seccin `inputs` en `flake.nix` para manejar las versiones de \n  nixpkgs y otros inputs en cada flake en lugar de usar el estado global.\n\n2. `nix-env`: `nix-env` es una herramienta clsica de la lnea de comandos que se usa para \n  manejar paquetes de software en el entorno del usuario.\n  1. Instala paquetes de las fuentes de datos aadidas por `nix-channel`, causando que \n    las versiones de los paquetes estn influenciadas por el canal. Los paquetes instalados \n    mediante `nix-env` nos se registran automticamente en la configuracin declarativa, \n    lo que hace que sea difcil reproducirlos en otras mquinas. No se recomienda usar \n    este comando directamente.\n  2. El comando correspondiente en la nueva CLI es `nix profiles`, pero tampoco es muy \n    recomendado.\n3. `nix-shell`: `nix-shell` crea una shell temporal que es til para pruebas y desarrollo.\n  1. La nueva CLI: esta herramienta se divide en tres sub-comandos: `nix develop`, \n    `nix shell` y `nix run`. Hablaremos ms tarde acerca de ellos.\n\n4. `nix-build` : `nix-build` construye los paquetes de Nix y coloca sus resultados en \n  `/nix/store`, pero no los registra en la configuracin declarativa.\n  1. Nueva CLI: `nix-build` es reemplazado por `nix build`.\n5. `nix-collect-garbage`: El comando de recoleccin de basura para limpiar objetos no \n  usados en `/nix/store`.\n  1. Hay un comando similar en la nueva CLI, `nix store gc --debug`, pero no limpia \n    las generaciones anteriores. Actualmente ste comando no tiene reemplazo.","src/content/docs/nix/NixOS/introduccion-flakes.mdx","a865c4f5c25a8942","nix/nixos/habilitando-flakes",{"id":317,"data":319,"body":326,"filePath":327,"digest":328,"deferredRender":16},{"title":320,"editUrl":16,"head":321,"template":18,"sidebar":322,"pagefind":16,"draft":20,"sitemap":324},"Habilitando NixOS con Flakes",[],{"order":65,"hidden":20,"attrs":323},{},{"linkInclusionRules":325},[24],"Comparado con el mtodo de configuracin usual, los Flakes ofrecen mejor reproducibilidad.\n\n## Habilitando el soporte de flakes \n\nActualmente, los Flakes son experimentales y no se habilitan por defecto. Necesitamos \nmodificar `/etc/nixos/configuration.nix` para habilitarlos junto con la nueva herramienta\nCLI.\n\n```code :language nix :eval false \n{ config, pkgs, ... }: \n\n{\n  imports = [\n    ./hardware-configuration.nix \n  ];\n  \n\n  # Habilitar flakes y la CLI \n  nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n  environment.systemPackages = with pkgs; [\n    git \n  ];\n\n}\n```\nDespus de hacer estos cambios hay que correr `sudo nixos-rebuild switch` para que tomen \nefecto.\n\n## Cambiando la configuracin a flake.nix \nDespus de habilitar los Flakes, el comando `sudo nixos-rebuild switch` prioriza leer \nel archivo `/etc/nixos/flake.nix` y, si no se encuentra, intentar usar \n`/etc/nixos/configuration.nix`.\n\nPodemos empezar usando los templates oficiales. Primero veamos cules estn disponibles \n\n```bash \nnix flake show templates\n```\n\n\nEntre ellos, se encuentra `templates#full` que demuestra todos los posibles usos. Podemos \nver su contenido \n\n```bash \nnix flake init -t templates#full \ncat flake.nix\n```\nAqu hay un ejemplo de su contenido \n\n```code :language nix :eval false \n{\n  description = \"A simple NixOS flake\";\n\n  inputs = {\n    # NixOS official package source, using the nixos-25.05 branch here\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-25.05\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: {\n    # Please replace my-nixos with your hostname\n    nixosConfigurations.my-nixos = nixpkgs.lib.nixosSystem {\n      modules = [\n        # Import the previous configuration.nix we used,\n        # so the old configuration file still takes effect\n        ./configuration.nix\n      ];\n    };\n  };\n}\n```","src/content/docs/nix/NixOS/habilitando-flakes.mdx","99cb7c2fd2d5b3fd","nix/nixos/explicacion-flakes",{"id":329,"data":331,"body":338,"filePath":339,"digest":340,"deferredRender":16},{"title":332,"editUrl":16,"head":333,"template":18,"sidebar":334,"pagefind":16,"draft":20,"sitemap":336},"flake.nix explicado",[],{"order":78,"hidden":20,"attrs":335},{},{"linkInclusionRules":337},[24],"Expliquemos el contenido del `flake.nix` que creamos.\n\n## 1. Flake inputs\n\nPrimero, veamos el atributo `inputs`. Es este atributo el que define todas las dependencias \ndel flake. Estas dependencias se pasan como argumentos a la funcin `outputs`.\n\n```code :language nix :eval false \n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-25.05\";\n  };\n  \n  outputs = { self, nixpgs, ... }@inputs: {\n     \n  };\n} \n```\n\nLas dependencias en `inputs` tienen muchos tipos y definiciones. Puede se otro flake, \nun repositorio de Git o un camino local. \n\nAqu slo definimos una dependencia llamada `nixpkgs`, que es la manera ms comn para \ndar referencias en un flake `github:owner/name/reference`. La `reference` puede ser \nel nombre de un branch, un commit-id o un tag.\n\nDespus de que se define `nixpgs` en `inputs`, podemos usarlo como parmetro en la funcin \n`outputs`.\n\n## 2. Flake outputs \nAhora veamos a `outputs`. Es una funcin que toma las dependencias de `inputs` como\nparmetro y su valor de retorno es un conjunto de atributos, que representa los resultados \nde la construccin del flake: \n\n```code :language nix :eval false \n{\n  description = \"A simple NixOS flake\";\n  \n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-25.05\"; \n  };\n\n  outputs = { self, nixpkgs, ... }@inputs : {\n    nixosConfiguration.my-nixos = nixpkgs.lib.nixosSystem {\n      modules = [\n        ./configuration.nix \n      ]; \n    }; \n  };\n} \n```\n\nLos flakes pueden tener muchos propsitos y tener diferentes tipos de `outputs`. \nCuando corremos `sudo nixos-rebuild switch` el comando busca el atributo \n`nixosConfiguration.my-nixos` (donde `my-nixos` es el hostname del sistema actual) \nen el conjunto de atributos que regresa la funcin `outputs` y usa la definicin para \nconfigurar el sistema.\n\n## 3. El parmetro especial `self` de la funcin `outputs`\n\n`self` es el valor de retorno de la funcin `outputs` del flake y el path al folder del \n`flake`.\n\n## 4. Introduccin a la funcin `nixpkgs.lib.nixosSystem`\n\n**Un flake puede depender de otros para usar las funciones que proveen**\n\nPor defecto, un flake busca un archivo `flake.nix` en el root del directorio para obtener \nsus dependencias y evala de manera floja la funcin `outputs`, luego pasa el conjunto \nde atributos que regresan estas funciones como un argumento a su propia funcin `outputs`.\n\nMs precisamente, la evaluacin de cada funcin `outputs` de cada dependencia es floja. \nEsto significa que la funcin `outputs` de un flake slo se evala cuando se necesita.\n\nEl conjunto de atributos que va despus de `nixpkgs.lib.nixosSystem` es la funcin de un \nslo argumento que contiene todos los parmetros de la configuracin:\n\n- `system`: un alias antiguo para `nixpgs.hostPlatform` que especifica la plataforma en \n  la que corre el sistema. \n- `modules`: Una lista de los mdulos donde la configuracin real del sistema se define.","src/content/docs/nix/NixOS/explicacion-flakes.mdx","0d134c40ea63901f","nix/nixos/modulos",{"id":341,"data":343,"body":350,"filePath":351,"digest":352,"deferredRender":16},{"title":344,"editUrl":16,"head":345,"template":18,"sidebar":346,"pagefind":16,"draft":20,"sitemap":348},"La combinacin de los flakes y el sistema de mdulos de Nixpkgs",[],{"order":117,"hidden":20,"attrs":347},{},{"linkInclusionRules":349},[24],"## El sistema de mdulos de Nixpkgs explicado \n\nAqu est una estructura simplificada de un mdulo de Nixpkgs\n\n```code :language nix :eval false \n{ lib, config, options, pkgs, ... } :\n\n{\n  imports = [\n    ./xxx.nix \n  ];\n  for.bar.enable = true;\n}\n```\n\nLa definicin es en realidad una funcin Nix y tiene 5 parmetros automticamente generados,\ninyectados y sin declaracin que provee el sistema de mdulos: \n\n1. `lib`: Aun biblioteca de funciones incluida con nixpkgs que ofrece funciones prcticas \n  para operar expresiones Nix.\n\n2. `config`: Un conjunto de todos los valores de opciones en el entorno actual, que se usan \n  de forma extensa en la seccin subsecuente del sistema de mdulos.\n3. `options`: Un conjunto de todas las opciones definidas en todos los mdulos del entorno \n  actual.\n4. `pkgs`: Una coleccin que contiene todos los paquetes de nixpkgs junto con algunas \n  funciones tiles.\n5. `modulesPath`: Un parmetro slo disponible en NixOS que apunta a \n  `nixpgks/nixos/modules`.\n\n## Pasando parmetros a sub-mdulos \nSi necesitamos pasar otros parmetros a sub-mdulos, necesitamos usar algunos mtodos \nespeciales para especificar manualmente estos parmetros.\n\nEl sistema de mdulos de Nixpkgs nos da dos formas de pasar estos parmetros:\n\n1. El parmetro `specialArgs` de la funcin `nixpkgs.lib.nixosSystem`.\n2. Usando la opcin `_module.args` en cualquier mdulo para pasar parmetros.\n\nEn pocas palabras, `specialArgs` y `_module.args` ambas requieren un conjunto de atributos \npuesto como su valor y sirven el mismo propsito, pasar todos los parmetros del conjunto \nde atributos a todos los sub-mdulos. \n\nSupongamos que queremos pasar cierta dependencia para usarla en un sub-mdulo. Podemos \nusar `specialArgs` para pasar `inputs` a todos los sub-mdulos:\n\n```code :language nix :eval false \n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-25.05\";\n    another-input.url = \"github:username/repo-name/branch-name\";\n  };\n  \n  outputs = inputs@{ self, nixpkgs, another-input, ... }: {\n    nixosConfiguration.my-nixos = nixpkgs.lib.nixosSystem {\n      specialArgs = { inherit inputs; };\n      modules = [\n        ./configuration.nix\n      ];\n    }; \n  };\n} \n```\n\n## Instalando software de otros Flakes \n\nUsaremos el editor Helix como ejemplo:\n\n```code :language nix :eval false \n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-25.05\";\n    \n    helix.url = \"github:helix-editor/helix/master\";\n  };\n  \n  outputs = inputs@{ self, nixpkgs, ... } : {\n    nixosConfiguration.my-nixos = nixpkgs.lib.nixosSystem {\n      specialArgs = { inherit inputs; };\n      modules = [\n        ./configuration.nix \n      ];\n    };  \n  };\n} \n```\nLuego, podemos referencias estos inputs en `configuration.nix`:\n\n```code :language nix :eval false \n{ config, pkgs, inputs, ... }: \n\n{\n  environment.systemPackages = with pkgs; [\n    git \n    vim \n    wget \n    inputs.helix.packages.\"${pkgs.system}\".helix \n  ];\n}\n```","src/content/docs/nix/NixOS/modulos.mdx","8a5e4516e7bd1fed","nix/nixos/home-manager",{"id":353,"data":355,"filePath":362,"digest":363,"deferredRender":16},{"title":356,"editUrl":16,"head":357,"template":18,"sidebar":358,"pagefind":16,"draft":20,"sitemap":360},"Home Manager",[],{"order":91,"hidden":20,"attrs":359},{},{"linkInclusionRules":361},[24],"src/content/docs/nix/NixOS/home-manager.mdx","641e1bfea7d8e2f1","tipos/rijke/modular",{"id":364,"data":366,"body":374,"filePath":375,"digest":376,"deferredRender":16},{"title":367,"editUrl":16,"head":368,"template":18,"sidebar":369,"pagefind":16,"draft":20,"sitemap":372},"Aritmtica modular va la intepretacion de Curry-Howard",[],{"order":370,"hidden":20,"attrs":371},9,{},{"linkInclusionRules":373},[24],"import { Aside } from '@astrojs/starlight/components';\n\nHemos descrito completamente la teora de tipos dependientes de Martin-Lf. Es momento de \nempezar a desarrollar matemticas en ella y la teora de tipos dependiente de Martin-Lf \nes excelente para matemticas elementales, como la teora de nmeros bsica, algo de \nlgebra y combinatoria. La idea fundamental usada para desarrollar la matemtica en la \nteora de tipos dependiente es la interpretacin de Curry-Howard. Esta es una traduccin \nde la lgica a la teora de tipos, que usaremos para expresar conceptos como divisibilidad,\nlas relaciones de congruencia y dems.\n\nTambin vamos a introducir la familia $\"Fin\"$ de tipos finitos estndar, indizada por \n$NN$ y mostraremos como cada $\"Fin\" _(k + 1)$ puede equiparse con una estructura de \ngrupo de enteros mdulo $k + 1$.\n\n## La interpretacin Curry-Howard\n\nLa *interpretacin Curry-Howard* es una interpretacin de la lgica dentro de la teora de \ntipos. Recordemos que en la teora de tipos no hay una separacin entre el esquema lgico\ny la teora general de las colecciones de objetos matemticos como sucede en la teora \nde conjuntos de Zermelo-Fraenkel. Estos dos aspectos de la matemtica estn unificados \nen la teora de tipos. La idea de la interpretacin de Curry-Howard es entonces expresar \nproposiciones como tipos y pensar a los elementos de estos tipos como sus demostraciones.\nIlustramos esto mediante un ejemplo.\n\n\u003Cdiv id=\"ejemplo-7-1-1\">\n\u003CAside type=\"note\" title=\"Ejemplo 7.1.1\">\n\nSe dice que un nmero natural $d$ divide a un nmero natural $n$ si existe un nmero \nnatural $k$ tal que $d dot k = n$. Para representar el predicado de divisibilidad en la \nteora de tipos, necesitamos definir un tipo \n\n$ d | n, $\n\ncuyos elementos sean pruebas de que $d$ divide a $n$. En otras palabras, $d|n$ debe ser \nel tipo que consiste de nmeros naturales $k$ equipados con una identificacin \n$d dot k = n$. En general, el tipo de $x : A$ equipado con $y : B(x)$ se representa \npor el tipo $Sigma_((x : A)) B(x)$. La interpretacin del cuantificador existencial\n$exists$ en la teora de tipos va la correspondencia Curry-Howard es con los $Sigma$-tipos.\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-7-1-2\">\n\u003CAside type=\"tip\" title=\"Definicin 7.1.2\">\nConsideremos dos nmeros $d$ y $n$. Decimos que $d$ **divide** a $n$ si hay un elemento \nde tipo \n\n$ d | n := Sigma_((k : NN)) d dot k = n. $\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-7-1-3\">\n\u003CAside type=\"note\" title=\"Observacin 7.1.3\">\nLa definicin en la teora de tipos de la relacin de divisibilidad usando $Sigma$-tipos \ntiene dos consecuencias importantes:\n\n1. La forma principal para mostrar que $d | n$ se mantiene es construir un par $(k, p)$\n  que consiste de un nmero natural $k$ y una identificacin $p : d dot k = n$.\n2. La forma principal de usar un hiptesis $H : d | n$ en una prueba es proceder por \n  $Sigma$-induccin sobre la variable $H$. Luego podemos asumir que tenemos un nmero\nnatural $k$ y una identificacin $p: d dot k = n$, para proceder con la prueba.\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"ejemplo-7-1-4\">\n\u003CAside type=\"note\" title=\"Ejemplo 7.1.4\">\nDe la misma forma en la que la cuantificacin existencial $exists$ se traduce en los \n$Sigma$-tipos va la correspondencia de Curry-Howard, la traduccin del cuantificador\nuniversal $forall$ en la teora de tipos se corresponde con los $Pi$-tipos mediante la \ncorrespondencia de Curry-Howard. Por ejemplo, la afirmacin de que todo nmero natural \nes divisible por $1$ se expresa en la teora de tipos como \n\n$ Pi_((x : NN)) 1 | x. $\n\nEn otras palabras, para demostrar que cada nmero natural $x : NN$ es divisible por $1$ \ntenemos que construir una funcin dependiente \n\n$ lambda x. p(x) : Pi_((x : NN)) 1 | x. $\n\nHacemos estro construyendo un elemento \n\n$ p(x) : Sigma_((k : NN)) 1 dot k = x $\n\nindizada por $x : NN$. Un elemento $p(x)$ as se construye como un par $(x, q(x))$, donde\nla identificacin $q(x) : 1 dot x = x$ se obtiene de la ley de unidad izquierda para la \nmultiplicacin en $NN$. \n\nDe manera similar, la prueba en la teora de tipos de que todo nmero natural $k$ divide \na $0$, es el par $(0, p)$ que consiste de un nmero natural $0$ y una identificacin \n$p : k dot 0 = 0$ que se obtiene por la regla de aniquilacin derecha de la multiplicacin\nen $NN$.\n\n\u003C/Aside>\n\u003C/div>\n\nEn la siguiente proposicin veremos como se puede usar una hiptesis de tipo $d | x$.\n\n\u003Cdiv id=\"proposicion-7-1-5\">\n\u003CAside type=\"tip\" title=\"Proposicin 7.1.5\">\nConsideremos tres nmeros naturales $d, x$ y $y$. Si $d$ divide a cualquiera dos de los \ntres nmeros $x, y$ y $x + y$, entonces tambin divide al tercero.\n\n*Demostracin* Slo mostraremos que si $d$ divide a $x$ y $y$, entonces tambin divide \na $x + y$. \nSupongamos que $d$ divide a $x$ y a $y$. Por hiptesis, tenemos elementos \n\n$ H: Sigma_((k : NN)) d dot k = n quad quad K : Sigma_((k : NN)) d dot k = y. $\n\nComo $H$ y $K$ son $Sigma$-tipos, procederemos por $Sigma$-induccin sobre $H$ y $K$.\nAs, asumimos un nmero natural $k : NN$ equipado con una identificacin $p : d dot k = n$\ny un nmero natural $l : NN$ equipado con una identificacin $q : d dot l = y$. \nNuestra meta es construir una identificacin \n\n$ d dot (k + l) = x + y. $\n\nConstruimos esta identificacin como una concatenacin $alpha dot (beta dot gamma)$, donde\nlos tipos de $alpha, beta$ y $gamma$ son:\n\n$ d dot (k + l) =^(alpha) d dot k + d dot l =^(beta) x + d dot l =^(gamma) x + y. $\n\nLa identificacin $alpha$ se obtiene del hecho de que la multiplicacin en $NN$ se \ndistribuye sobre la suma. Las identificaciones $beta$ y $gamma$ se construyen usando \nla accin sobre trayectorias de una funcin \n\n$ beta := \"ap\" _((lambda t. t + d dot l)) (p) $\n\ny\n\n$ gamma := \"ap\" _((lambda t. x + t))(q) $\n\nPara concluir la prueba de que $d | x + y$, notemos que hemos construido un par \n\n$ (k + l, alpha dot (beta dot gamma)): Sigma_((k : NN)) d dot k = x + y $\n\n\u003C/Aside>\n\u003C/div>\n\nLa interpretacin de Curry-Howard de la lgica en la teora de tipos involucra \ninterpretaciones de la disyuncin, conjuncin, implicacin e igualdad.\n\nPor ejemplo, las reglas de introduccin y eliminacin para la disyuncin son:\n\n```typst \n#table(\n  stroke: none,\n  columns: 3,\n  prooftree(\n    rule(\n      $P or Q$,\n      $P$ \n    )\n  ),\n  prooftree(\n    rule(\n      $P or Q$,\n      $Q$\n    )\n  ),\n  prooftree(\n    rule(\n      $P or Q arrow.double R$,\n      $P arrow.double R$,\n      $Q arrow.double R$\n    )\n  )\n)\n```\nLas dos reglas de introduccin afirman que $P or Q$ es verdadera cuando $P$ o $Q$ son \nverdaderas. Estas reglas son anlogas a las reglas de introduccin para el co-producto,\nque aseguran que hay funciones $\"inl\": A arrow A + B$ y $\"inr\": B arrow A + B$. \nEl principio de eliminacin no dependiente para co-productos nos da una funcin \n\n$ (A arrow C) arrow ((B arrow C) arrow (A + B arrow C)) $\n\npara cualquier tipo $C$, que es anlogo a la regla de eliminacin para la disyuncin.\n\nPara interpretar la conjuncin en la teora de tipos observamos que las reglas de \nintroduccin y eliminacin para la conjuncin son \n\n```typst \n#table(\n  stroke: none,\n  columns: 3,\n  prooftree(\n    rule(\n      $P and Q$,\n      $P$,\n      $Q$\n    ) \n  ),\n  \n  prooftree(\n    rule(\n      $P$,\n      $P and Q$\n    )\n  ),\n\n  prooftree(\n    rule(\n      $Q$,\n      $P and Q$\n    ) \n  )\n)\n```","src/content/docs/tipos/Rijke/modular.mdx","3752a9db338966c3","tipos/hott/tipos/funciones-dependientes",{"id":377,"data":379,"body":386,"filePath":387,"digest":388,"deferredRender":16},{"title":380,"editUrl":16,"head":381,"template":18,"sidebar":382,"pagefind":16,"draft":20,"sitemap":384},"Tipos funcin dependiente",[],{"order":104,"hidden":20,"attrs":383},{},{"linkInclusionRules":385},[24],"En la teora de tipos generalmente usamos una versin ms general de las funciones, a las \nque llamamos funciones dependientes o $Pi$-tipos. Los elementos de un $Pi$-tipo son \nfunciones cuyo co-dominio puede variar dependiendo del valor del dominio al que se le \naplica la funcin dependiente. El nombre $Pi$-tipo se usa pues tambin se pueden pensar \ncomo productos cartesianos sobre un cierto tipo.\n\nDado un tipo $A : cal(U)$ y una familia $B : A arrow cal(U)$, podemos construir el tipo \nde funciones dependientes $Pi_((x: A)) B(x) : cal(U)$. \n\nSi $B$ es una familia constante, entonces el tipo producto dependiente no es ms que el \ntipo funcin ordinario: \n\n$ Pi_((x : A)) B = A arrow B. $\n\nPodemos introducir una funcin dependiente mediante definicin explcita: para definir \n$f : Pi_((x : A)) B(x)$, donde $f$ es el nombre de la funcin dependiente, necesitamos una \nexpresin $Phi : B(x)$ que posiblemente involucra a la variable $x : A$, y escribimos \n\n$f(x) : equiv Phi, \" para \" x : A.$\n\nDe manera alternativa, podemos usar $lambda$-abstraccin \n\n$ lambda x. Phi : product_((x : A)) B(x). $","src/content/docs/tipos/HoTT/Tipos/funciones-dependientes.mdx","a23d41b0bce41102","tipos/hott/tipos/pares-dependientes",{"id":389,"data":391,"body":398,"filePath":399,"digest":400,"deferredRender":16},{"title":392,"editUrl":16,"head":393,"template":18,"sidebar":394,"pagefind":16,"draft":20,"sitemap":396},"Pares dependientes",[],{"order":65,"hidden":20,"attrs":395},{},{"linkInclusionRules":397},[24],"As como generalizamos las funciones a funciones dependientes haciendo que el tipo del \nco-dominio pudiera depender del valor del dominio, podemos generalizar los tipos productos \npara que el tipo de la segunda coordenada pueda depender del valor de la primera. Estos \nson llamados los **tipos par dependiente** o *$Sigma$-tipos*, pues corresponden a una suma \nindizada.\n\nDado un tipo $A : cal(U)$ y una familia $B : A arrow cal(U)$, el tipo par dependiente \nse escribe como $Sigma_(x : A) B(x) : cal(U)$.\n\nLa forma de construir elementos de un tipo par dependiente es por medio del emparejamiento,\ntenemos que $(a, b) : Sigma_(a : A) B(x)$ siempre que $a : A$ y $b : B(a)$. Si $B$ es \nconstante, el tipo par dependiente es el producto cartesiano de siempre:\n\n$ (sum_(x : A) B) equiv A times B. $\n\nEl principio de recursin dice que para definir una funcin \n$f : (Sigma_((x : A)) B(x)) arrow C $ necesitamos dar una funcin \n$g : Pi_((x : A)) B(x) arrow C$ y luego podemos definir a $f$ mediante la ecuacin \n\n$ f((a, b)) : equiv g(a)(b).  $\n\nEl principio de induccin dice que, dada una familia de tipos \n$C : (Sigma_(x : A) B(x)) arrow cal(U)$ y una funcin \n\n$ g : product_(x : A) product_(y : B(x)) C ((a,b)) $\n\npodemos derivar una funcin \n\n$ f : product_(p : sigma_((x : A)) B(x)) C(p) $\n\nmediante le ecuacin \n\n$f ((a, b)) : equiv g(a)(b). $\n\nPodemos definir el recursor y la induccin como \n\n$ \"rec\" _(Sigma_((x : A)) B(x)) : product_(C : cal(U)) (product_(x : A) B(x) arrow C) arrow \n(sum_(x : A) B(x)) arrow C $\n\n$ \"ind\" _(Sigma_((x : A)) B(x)) : product_(C : (Sigma_((x : A)) B(x)) arrow cal(U))\n(product_(x : A) product_(y : B(x)) C((x, y))) arrow product_(p : Sigma_((x : A)) B(x)) C(p) $\n\nmediante las ecuaciones \n\n$ \"rec\" _(Sigma_((x : A) B(x))) (C, g, (a, b)) : equiv g(a)(b), $\n$ \"ind\" _(Sigma_((x : A) B(x))) (C, g, (a, b)) : equiv g(a)(b). $","src/content/docs/tipos/HoTT/Tipos/pares-dependientes.mdx","685222b754085317","tipos/hott/tipos/productos",{"id":401,"data":403,"body":410,"filePath":411,"digest":412,"deferredRender":16},{"title":404,"editUrl":16,"head":405,"template":18,"sidebar":406,"pagefind":16,"draft":20,"sitemap":408},"Productos",[],{"order":130,"hidden":20,"attrs":407},{},{"linkInclusionRules":409},[24],"Dados dos tipos $A, B: cal(U)$ introducimos el tipo $A times B : cal(U)$ al que llamamos su \n**producto cartesiano**. Tambin introducimos un tipo que es el neutro respecto del producto \nllamado el **tipo unidad** $bold(1): cal(U)$. \n\nLa manera de construir parejas es evidente, dado $a : A$ y $b : B$, podemos formar \n$(a, b) : A times B$. Similarmente, hay una sola forma de construir elementos de $bold(1)$,\na saber, $star : bold(1)$. \n\nAhora, cmo podemos usar las parejas? Primero consideremos la definicin de una funcin \nno dependiente $f : A times B arrow C$. Como esperamos que los elementos de $A times B$ \nsean pares, esperamos poder definir una de estas funciones diciendo cmo se comportan en \nlas parejas $(a, b)$. Podemos hacer esto dando una funcin $g : A arrow B arrow C$. As,\nintroducimos una regla (la regla de eliminacin para productos) que dice que \ndada una funcin $g : A arrow B arrow C$, podemos definir una funcin \n$f : A times B arrow C$ como \n\n$ f (a, b) = g(a)(b). $\n\nComo un ejemplo, podemos derivar las funciones proyeccin \n\n$ \"pr\" _1 : A times B arrow A $\n$ \"pr\" _2 : A times B arrow B $\n\nmediante las ecuaciones \n\n$ \"pr\" _1 ((a,b)) :equiv a $\n$ \"pr\" _2 ((a,b)) :equiv b $\n\nEn lugar de invocar este principio de definicin de funciones cada vez que vamos a definir \nuna funcin podemos definir una funcin \n\n$ \"rec\" _(A times B) : product_(C : cal(U)) (A arrow B arrow C) arrow A times B arrow C $\n\nmediante la ecuacin \n\n$ \"rec\" _(A times B) (C, g, (a,b)) : equiv g(a)(b). $\n\nLuego, en lugar de definir $\"pr\" _1$ y $\"pr\" _2$ directamente mediante una ecuacin, \npodemos definir \n\n$ \"pr\" _1 : equiv \"rec\" _(A times B) (A, lambda a. lambda b. a) $\n$ \"pr\" _2 : equiv \"rec\" _(A times B) (B, lambda a. lambda b. b) $\n\nA la funcin $\"rec\" _(A times B)$ le llamamos el **recursor** para tipos producto.\n\nTambin tenemos un recursor para el tipo unidad: \n\n$ \"rec\" _(bold(1)) : product_(C : cal(U)) C arrow bold(1) arrow C $\n\ndefinido mediante le ecuacin \n\n$ \"rec\" _(bold(1)) (C, c, star) : equiv c. $\n\nPara poder definir funciones dependientes sobre un tipo producto, necesitamos generalizar \nel recursor. Dada una familia de tipos $C : A times B arrow cal(U) $, podemos definir una \nfuncin $f : Pi_((x : A times B)) C(x)$ dando una funcin \n$g : Pi_((x : A)) Pi_((y : B)) C((x, y))$ y una ecuacin \n\n$ f((x, y)) : equiv g(a)(b). $\n\nPor ejemplo, de esta forma podemos demostrar que cada elemento de un tipo producto \n$A times B$ es una pareja. Especficamente, podemos construir una funcin \n\nLa habilidad de definir funciones dependientes de esta forma significa que para probar una \npropiedad para todos los elementos de un producto, es suficiente probarlo para sus\nelementos cannicos, las parejas ordenadas. Si aplicamos esto en el caso universal \nobtenemos una funcin llamada la **induccin** para tipos productos: dados $A, B : cal(U)$\ntenemos \n\n$ \"ind\" _(A times B) : product_(C : A times B arrow cal(U)) (product_(x : A) product_(y : B)C((x,y))) \narrow product_(x : A times B) C(x) $\n\ndefinida mediante la ecuacin \n\n$ \"ind\" _(A times B) (C, g, (x, y)) : equiv g(a)(b). $\n\nTambin tenemos una funcin induccin para el tipo unidad:\n\n$ \"ind\" _(bold(1)) : product_(C : bold(1) cal(U)) C(star) arrow product_(x : 1) C(x) $\n\ndefinida mediante la ecuacin \n\n$ \"ind\" _(bold(1)) (C, c, star) : equiv c. $","src/content/docs/tipos/HoTT/Tipos/productos.mdx","e5ed8c9d5bdb352c","tipos/hott/tipos/identidad",{"id":413,"data":415,"body":421,"filePath":422,"digest":423,"deferredRender":16},{"title":175,"editUrl":16,"head":416,"template":18,"sidebar":417,"pagefind":16,"draft":20,"sitemap":419},[],{"order":78,"hidden":20,"attrs":418},{},{"linkInclusionRules":420},[24],"import { Aside } from '@astrojs/starlight/components';\n\nDe acuerdo con la concepcin de las proposiciones como tipos, la proposicin de que dos \nelementos del mismo tipo $a, b: A$ son iguales, debe corresponder a algn tipo. Como esta \nproposicin depende tanto de $a$ como de $b$, estos **tipos identidad** deben ser \nfamilias de tipos dependientes de dos copias de $A$.\n\nPodemos escribir esta familia como $\"Id\" _A : A arrow A arrow cal(U)$, de modo que \n$\"Id\" _A (a, b)$ es el tipo que representa la proposicin de la igualdad entre $a$ y \n$b$. Tambin usaremos la notacin $a attach(=, br: A) b$ o simplemente $a = b$ para }\nhablar de $\"Id\" _A (a, b)$. Si tenemos un elemento de $a attach(=, br: A) b$, diremos que \n$a$ y $b$ son **iguales** o **proposicionalmente iguales**.\n\nPodemos pensar al tipo $a = b$ como el tipo de las *identificaciones* de $a$ y $b$.\nLa regla de formacin dice que, dado un tipo $A : cal(U)$ y dos elementos $a, b : A$, \npodemos formar el tipo $(a attach(=, br: A) b) : cal(U)$ en el mismo universo.\nLa forma bsica de construir un elemento de $a = b$ es saber que $a$ y $b$ son lo mismo.\nAs, la regla de introduccin es una funcin dependiente \n\n$ \"refl\" : product_(a : A) (a attach(=, br: A) a) $\n\nllamada reflexividad, que dice que cada elemento de $A$ es igual a s mismo. Podemos pensar \na $\"refl\" _a$ como la trayectoria constante en el punto $a$.\n\nEn particular, si $a$ y $b$ son juiciosamente iguales, $a equiv b$, tenemos un elemento \n$\"refl\" _a : a attach(=, br: A) b$. Esto est bien tipado, pues $a equiv b$ implica que \ntambin el tipo $a attach(=, br: A) b$ es juiciosamente igual al tipo \n$a attach(=, br: A) a$, que es el tipo de $\"refl\" _a$.\n\nEl principio de induccin para tipos identidad es muy sutil, as que consideraremos primero \nuna consecuencia de ste, el principio que dice que iguales se pueden sustituir por }\niguales.\n\n\u003Cdiv id=\"indiscernibilidad-de-los-identicos\">\n\u003CAside type=\"tip\" title=\"Indiscernibilidad de los idnticos\">\n\nPara cada familia \n\n$ C: A arrow cal(U) $\n\nhay una funcin \n\n$ f : product_(x,y : A) product_(p : x attach(=, br: A) y) C(x) arrow C(y) $\n\ntal que \n\n$ f(x, x, \"refl\" _x) : equiv \"Id\" _(C(x)) $\n\n\u003C/Aside>\n\u003C/div>\n\nEsto dice que toda familia de tipos $C$ preserva la igualdad, en el sentido de que aplicar\n$C$ a elementos iguales de $A$ resulta en una funcin entre los tipos resultantes. \n\nLa indiscernibilidad de los idnticos se puede pesar como el principio de recursin para\nel tipo identidad. As como $\"rec\" _NN$ da una funcin $NN arrow C$, la indiscernibilidad \nde los idnticos nos da una funcin de $x attach(=, br: A) y$ a ciertas relaciones \nbinarias reflexivas sobre $A$ a saber, aquellas de la forma $C(x) arrow C(y)$ para \nalgn predicado unario $C(x)$. \n\nEl principio de induccin para el tipo identidad es llamado induccin de trayectorias, en \nvista de la interpretacin homotpica que explicaremos ms adelante. \n\n\u003Cdiv id=\"induccion-de-trayectorias\">\n\u003CAside type=\"tip\" title=\"Induccin de trayectorias\">\n\nDada una familia \n\n$ C : product_(x, y : A) (x attach(=, br: A) y) arrow cal(U) $\n\ny una funcin \n\n$ c : product_(x : A) C(x, x, \"refl\" _x), $\n\nhay una funcin \n\n$ f : product_(x, y : A) product_(p : (x attach(=, br: A) y)) C(x, y, p) $\n\ntal que \n\n$ f(x, x, \"refl\" _x ) : equiv c(x) $\n\no, en una lnea\n\n$ \"ind\"_(attach(=, br: A)) : \nproduct_(C : product_(x, y : A) (x attach(=, br: A) y) arrow cal(U))\n(product_(x : A) C(x, x, \"refl\" _x)) arrow \nproduct_(x, y : A) product_(p : x attach(=, br: A) y) C(x, y, p) $\n\njunto con la igualdad \n\n$ \"ind\"_(attach(=, br: A)) (C, c, x, x, \"refl\" _x) : equiv c(x) $\n\u003C/Aside>\n\u003C/div>\n\nNotemos que la induccin sobre trayectorias nos permite definir ciertas funciones que \nexhiben un comportamiento computacional adecuado. Para entender mejor este principio, \nconsideremos el caso en que $C$ no depende de $p$. Entonces tenemos que \n$C : A arrow A arrow cal(U)$, que se puede considerar como un predicado que depende de \ndos elementos de $A$. Nos interesa saber cundo la proposicin $C(x, y)$ es verdadera \npara un par de elementos $x, y : A$. En este caso, la hiptesis de la induccin sobre \ntrayectorias nos dice que si sabemos que $C(x, x)$ se cumple para cada $x : A$, entonces \nsabemos que $C(x, y)$ se cumple siempre que $x = y$.\n\nLa forma general del principio permite que $C$ tambin dependa de $p: x = y$: para \ndemostrar una propiedad para todos los elementos $x, y : A$ y trayectorias $p : x = y$\nentre ellos, basta considerar el caso en que los elementos son $x$ y la trayectoria es \n$\"refl\" _x : x = x$.\n\nLa funcin $\"ind\" _(attach(=, br: A))$ es tradicionalmente llamada $J$.","src/content/docs/tipos/HoTT/Tipos/identidad.mdx","377c0c31e410cca4","tipos/hott/homotopa/teoria",{"id":424,"data":426,"body":433,"filePath":434,"digest":435,"deferredRender":16},{"title":427,"editUrl":16,"head":428,"template":18,"sidebar":429,"pagefind":16,"draft":20,"sitemap":431},"Teora homotpica de tipos",[],{"order":104,"hidden":20,"attrs":430},{},{"linkInclusionRules":432},[24],"La idea central de la teora homotpica de tipos es que los tipos se pueden pensar como \nespacios en la teora de homotopa o grupoides de alta dimensin en teora de categoras.\n\nEn la teora de homotopa, un espacio $X$ es un conjunto de puntos equipado con una \ntopologa y una trayectoria entre dos puntos $x$ y $y$ es representada mediante una funcin \ncontinua $p : [0, 1] arrow X$, donde $p(0) = x$ y $p(1) = y$. Esta funcin nos da un punto \nen $X$ para cada momento del tiempo. Para muchos propsitos, la igualdad estricta entre \ntrayectorias nos restringe demasiado, as que es mejor considerar una nocin de igualdad \nms relajada llamada *homotopa*. Una homotopa entre un par de funciones continuas \n$f : X_1 arrow X_2$ y $g : X_1 arrow X_2$ es una funcin continua \n$H : X_1 times [0, 1] arrow X_2$ que cumple que $H(x, 0) = f$ y $H(x, 1) = g$. En el caso \nparticular de las trayectorias, una homotopa entre dos trayectorias $p$ y $q$ entre \n$x$ y $y$ es una funcin continua $H: [0, 1] times [0, 1] arrow X$ tal que \n$H(s, 0) = p(s)$ y $H(s, 1) = q(s)$ para cada $s in [0, 1]$. En este caso, pedimos tambin \nque $H(0, t) = x$ y $H(1, t) = y$ para cada $t in [0, 1]$, una homotopa de este estilo \nes llamada *relativa a los extremos*.\n\nLa homotopa es una relacin de equivalencia y las operaciones como la concatenacin, los \ninversos, etc. la preservan. Ms an, las clases de equivalencias de ciclos en un punto \n$x_0$ (trayectorias entre un mismo punto) forman un grupo conocido como el \n*grupo fundamental*. Este grupo es un invariante algebrico del espacio, que se puede usar\npara investigar si dos espacios son *homotpicamente equivalentes* (hay funciones continuas \nentre ellos cuyas composiciones son homotpicas a las identidades), pues espacios \nequivalentes tienen grupos fundamentales isomorfos.\n\nComo las homotopas son, en s mismas, una especie de camino 2-dimensional, hay una nocin\nde *homotopas entre homotopas* 3-dimensionales y as sucesivamente, Esta torre \ninfinita de puntos, homotopas, homotopas entre homotopas, etc. es una instancia de \nuna estructura algebrica llamada $infinity$-grupoide (dbil). Un $infinity$-grupoide \nconsiste de una coleccin de objetos, una coleccin de *morfismos* entre objetos, \n*morfismos entre morfismos* y as sucesivamente, equipados con cierta estructura algebrica\ncompleja; un morfismo de nivel $k$ es llamado un $k$-*morfismo*. Los morfismos en cada nivel\ntienen identidad, composicin e inversin, que son dbiles en el sentido de que \nsatisfacen las leyes de los grupoides (asociatividad de la composicin, las identidades son \nunidades para la composicin y los inversos se cancelan) slo salvo morfismos del siguiente \nnivel y esta debilidad da lugar a mayor estructura.\n\nTodo espacio topolgico $X$ tiene un *$infinity$-grupoide fundamental* cuyos $k$-morfismos \nson las trayectorias $k$-dimensionales en $X$. La debilidad del $infinity$-grupoide \nse corresponde directamente con que las trayectorias forman un grupo slo salvo \nhomotopas, con las $(k+1)$-trayectorias sirviendo como las homotopas entre \n$k$-trayectorias.\n\nAhora, en la teora homotpica de tipos, cada tipo tiene la estructura de un \n$infinity$-grupoide. Una diferencia importante entre la teora de homotopa y la teora \nhomotpica de tipos es que da una descripcin *sinttica* de los espacios, los puntos, \ntrayectorias y las trayectorias entre trayectorias son nociones bsicas, indivisibles \ny primitivas. \n\nUna de las cosas ms impresionantes de la teora homotpica de tipos es que todas las \nconstrucciones bsicas y axiomas surgen automticamente del principio de induccin para \ntipos identidad.","src/content/docs/tipos/HoTT/Homotopa/teoria.mdx","95c98e78ec865c38","tipos/hott/homotopa/grupoides",{"id":436,"data":438,"body":445,"filePath":446,"digest":447,"deferredRender":16},{"title":439,"editUrl":16,"head":440,"template":18,"sidebar":441,"pagefind":16,"draft":20,"sitemap":443},"Los tipos son grupoides",[],{"order":130,"hidden":20,"attrs":442},{},{"linkInclusionRules":444},[24],"import { Aside } from '@astrojs/starlight/components';\n\n\u003Cdiv id=\"lema-2-1-1\">\n\u003CAside type=\"tip\" title=\"Lema 2.1.1\">\n\nPara cada tipo $A$ y cada $x, y : A$ hay una funcin \n\n$ (x = y) arrow (y = x) $\n\ndenotada $p mapsto p^(-1)$, tal que $\"refl\"^(-1)_x equiv \"refl\" _x$ para cada $x : A$.\nLlamamos a $p^(-1)$ el inverso de $p$.\n\n*Demostracin* Supongamos que $A : cal(U)$ est dado y sea \n$D : Pi_((x, y : A)) (x = y) arrow cal(U)$ una familia de tipos definida por \n$D(x, y, p) : equiv (y = x)$. En otras palabras, $D$ es una funcin que le asigna a cada \n$x, y : A$ y $p : x = y$ un tipo, a saber, el tipo $y = x$. Entonces tenemos un elemento \n\n$ d : equiv lambda x. \"refl\" _x : product_(x : A) D(x, x, \"refl\" _x). $\n\nAs, el principio de induccin para tipos identidad nos da un elemento \n$\"ind\" _(attach(=, br: A)) (D, d, x, y, p) : (y = x)$ para cada $p : (x = y)$. Ahora \npodemos definir la funcin buscada como \n$lambda p. \"ind\" _(attach(=, br: A)) (D, d, x, y, p)$, es decir, ponemos \n$p^(-1) : equiv \"ind\" _(attach(=, br: A)) (D, d, x, y, p)$ y, la regla de computacin nos \nda que $\"refl\"^(-1) _x equiv \"refl\" _x$.\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"lema-2-1-2\">\n\u003CAside type=\"tip\" title=\"Lema 2.1.2\">\nPara cada tipo $A$ y cada $x, y, z : A$ hay una funcin \n\n$ (x = y) arrow (y = z) arrow (x = z), $\n\nescrita como $p mapsto q mapsto p dot q$, tal que $\"refl\" _x dot \"refl\" _x equiv \"refl\" _x$\npara cada $x : A$. Llamamos a $p dot q$ la **concatenacin** o **composicin** de $p$ y $q$.\n\n*Demostracin* La funcin deseada tiene tipo \n$Pi_((x, y, z : A)) (x = y) arrow (y = z) arrow (x = z)$. En su lugar, vamos a definir una\nfuncin con el tipo equivalente \n$Pi_(x, y : A) (x = y) arrow Pi_(z : A) (y = z) arrow (x = z)$, que nos permite aplicar \nel principio de induccin de trayectorias dos veces. Sea \n$D : Pi_((x, y : A)) (x = y) arrow cal(U)$ la familia de tipos \n\n$ D(x, y, p) : equiv product_(x : A) product_(q : y = z) (x = z). $\n\nObservemos que $D(x, x, \"refl\" _x) equiv Pi_((z : A)) Pi_(q : x = z) (x = z)$. As, para \naplicar el principio de induccin para tipos de identidad a esta $D$, necesitamos una \nfuncin de tipo \n\n$ product_(x : A) D(x, x, \"refl\" _x) $\n\nes decir, de tipo \n\n$ product_(x : A) product_(q : x = z) (x = z). $\n\nAhora, sea $E : Pi_((x, z : A)) Pi_((q : x = z)) cal(U)$ la familia de tipos \n$E(x, z, q) : equiv (x = z)$. Observemos que $E(x, x, \"refl\" _x) equiv (x = x)$. As,\ntenemos la funcin \n\n$ e(x) : equiv \"refl\" _x : E(x, x, \"refl\" _x). $\n\nPor el principio de induccin aplicado a $E$, obtenemos una funcin \n\n$ d: product_(x, z : A) product_(q : x = z) E(x, z, q). $\n\nPero $E(x, z, q) equiv (x = z)$, de modo que el tipo de $d$ es \n$Pi_(x: A) D(x, x, \"refl\" _x)$. Luego, podemos usar esta funcin $d$ y aplicar el principio\nde induccin para tipos identidad a $D$, para obtener la funcin deseada de tipo \n\n$ product_(x, y : A) (x = y) product_(z : A) (y = z) arrow (x = z) $\n\ny, por lo tanto, $Pi_((x, y, z : A)) (y = z) arrow (x = y) arrow (x = z)$. Las reglas \nde computacin nos dan $\"refl\" _x dot \"refl\" _x equiv \"refl\" _x$ para cada $x : A$.\n\n\u003C/Aside>\n\u003C/div>","src/content/docs/tipos/HoTT/Homotopa/grupoides.mdx","6c36f317243f0c5e","categorias/awodey/exponenciales",{"id":448,"data":450,"body":457,"filePath":458,"digest":459,"deferredRender":16},{"title":451,"editUrl":16,"head":452,"template":18,"sidebar":453,"pagefind":16,"draft":20,"sitemap":455},"Exponenciales",[],{"order":78,"hidden":20,"attrs":454},{},{"linkInclusionRules":456},[24],"import { Aside } from '@astrojs/starlight/components';\n\n\u003Cdiv id=\"definicion-6-1\">\n\u003CAside type=\"tip\" title=\"Definicin 6.1\">\nSea $bold(C)$ una categora con productos finitos. Un *exponencial* de los objetos \n$B$ y $C$ consiste de un objeto \n\n$ C^B $\n\ny una flecha \n\n$ epsilon: C^B times B arrow C $\n\ntal que, para cada objeto $A$ y cada flecha \n\n$ f: A times B arrow C $\n\nhay una nica flecha \n\n$ tilde(f) : A arrow C^B $\n\ntal que \n\n$ epsilon compose (tilde(f) times 1_B) = f $\n\ncomo en el diagrama \n\n```typst \n#table(\n  stroke: none,\n  columns: 2,\n  commutative-diagram(\n    node((0, 0), $A$),\n    node((1, 0), $C^B$),\n    arr($A$, $C^B$, $tilde(f)$)\n  ),\n  commutative-diagram(\n    node((0, 0), $A times B$),\n    node((1, 0), $C^B times B$),\n    node((1, 1), $C$),\n    arr($A times B$, $C^B times B$, $tilde(f) times 1_B$),\n    arr($C^B times B$, $C$, $epsilon$),\n    arr($A times B$, $C$, $f$)\n  )\n)\n```\n\nAqu hay un poco de terminologa:\n\n- $epsilon : C^B times B arrow C$ es llamada la *evaluacin*.\n- $tilde(f): A arrow C^B$ es llamada la *transposicin* (exponencial) de $f$.\n- Dada una flecha $g : A arrow C^B$, escribimos \n    $ overline(g) : epsilon compose (g times 1_B) : A times B arrow C $\n    y tambin la llamamos la *transposicin* de $g$.\n\n\u003C/Aside>\n\u003C/div>\n\n## Categoras cartesianas cerradas \n\n\u003Cdiv id=\"definicion-6-2\">\n\u003CAside type=\"tip\" title=\"Definicin 6.2\">\nUna categora es llamada *cartesiana cerrada* cuando tiene todos los productos finitos \ny exponenciales.\n\u003C/Aside>\n\u003C/div>\n\n\n\n### lgebras Booleanas\nUn *lgebra Booleana* es un conjunto parcialmente ordenado $B$ equipado con dos elementos \ndistinguidos $0$ y $1$, dos operaciones binarias $a or b$ de \"join\" y $a and b$ de \"meet\"\ny una operacin unaria $not b$ de \"complementacin\". Se requiere que satisfagan las \nsiguientes condiciones \n\n```typst \n#table(\n  stroke: none,\n  columns: 1,\n  align: center,\n  $0 lt.eq a$,\n  $a lt.eq 1$,\n  $a lt.eq c \" y \" b lt.eq c quad \"si y slo si\" quad a or b lt.eq c$,\n  $c lt.eq a \" y \" c lt.eq b quad \"si y slo si\" quad c lt.eq a and b$,\n  $a lt.eq not b quad \"si y slo si\" quad a and b = 0$,\n  $not not a = a.$\n)\n```\nUn caso familiar de lgebra Booleana es $bold(2) = brace.l 0, 1 brace.r$, tambin pesado\ncomo los valores de verdad con las operaciones lgicas de disyuncin, conjuncin y negacin\ncomo las operaciones Booleanas.\n\n### lgebras de Heyting\nCualquier lgebra Booleana $B$, pensada como una categora de conjunto parcialmente \nordenado tiene productos finitos $1$ y $a and b$. Tambin podemos definir la exponencial \nen $B$ por \n\n$ b^a = (not a or b) $\n\nque tambin escribimos como $a arrow.double b$. La flecha evaluacin es \n\n$ (a arrow.double b) and a lt.eq b $\n\nEste ejemplo sugiere generalizar la nocin de lgebra Booleana a la de conjunto\nparcialmente ordenado cartesiano cerrado. Consideremos primero la nocin ms fuerte de \nlgebra de Heyting\n\n\u003Cdiv id=\"definicion-68\">\n\u003CAside type=\"tip\" title=\"Defincin 6.8\">\nUn lgebra de Heyting es un conjunto parcialmente ordenado con \n\n1. Meets finitos: $1$ y $p and q$.\n2. Joins finitos: $0$ y $p or q$.\n3. Exponenciales: para cada $a$ y $b$ un elemento $a arrow.double b$ tal que \n    $ a and b lt.eq c quad \"si y slo si\" quad a lt.eq b arrow.double c. $\n\nLa condicin dada sobre la exponencial $a arrow.double b$ es equivalente a la propiedad \nuniversal en el caso de conjuntos parcialmente ordenados. \nVeamos esto ms a detalle:\n\n- Supongamos que para cada $a$ y $b$ hay un elemento $a arrow.double b$ tal que \n    $ a and b lt.eq c quad \"si y slo si\" quad a lt.eq b arrow.double c $\n    Notemos que, como $a arrow.double b lt.eq a arrow.double b$, entonces \n    $(a arrow.double b) and a lt.eq b$. Esta va a ser nuestra flecha evaluacin.\n    Ahora, sea $c$ un elemento cualquiera y supongamos que $c and a lt.eq b$, entonces \n    $c lt.eq a arrow.double b$, de modo que $c and a lt.eq (a arrow.double b) and a$, pero \n    $(a arrow.double b) and a lt.eq b$, de modo que obtenemos nuevamente $c and a lt.eq b$.\n    As, tenemos que, en efecto, la condicin implica que $a arrow.double b$ cumple la \n    propiedad universal de la exponencial.\n- Supongamos que para cada $a$ y $b$, $a arrow.double b$ cumple la propiedad universal de \n    la exponencial, es decir, tenemos un morfismo evaluacin \n    $(a arrow.double b) and a lt.eq b$ y siempre que $c and a lt.eq b$, tenemos que \n    $c lt.eq a arrow.double b$. Lo nico que necesitamos probar es que si \n    $c lt.eq a arrow.double b$ entonces tambin $c and a lt.eq b$. Para esto basta notar \n    que, como $c lt.eq a arrow.double b$ entnoces $c and a lt.eq (a arrow.double b) and a$,\n    de modo que $c and a lt.eq b$.\n\u003C/Aside>\n\u003C/div>\n\nAhora, observemos que toda lgebra de Heyting es una *retcula distributiva*, es decir,\npara cada $a, b$ y $c$ se tiene que \n\n$ (a or b) and c = (a and c) or (b and c) $\n\nEn efecto, observemos que, para cada $z$ \n\n```typst \n$\n  (a or b) and c lt.eq z quad & \"sii\" quad a or b lt.eq c arrow.double z \\\n                              & \"sii\" quad a lt.eq c arrow.double z \" y \" b lt.eq c arrow.double c \\\n                              & \"sii\" quad a and c lt.eq z \" y \" b and c lt.eq z \\\n                              & \"sii\" quad (a and c) or (b and c) lt.eq z\n$\n```\n\nTomando $z = (a or b) and c$ y leyendo de arriba a abajo obtenemos una direccin y, Tomando\n$z = (a and c) or (b and c)$ y leyendo de abajo a arriba obtenemos la otra direccin.\n\n\u003Cdiv id=\"observacion-6-9\">\n\u003CAside type=\"note\" title=\"Observacin 6.9\">\nLa distributividad anterior es un caso especial de un hecho general que sucede en \ncualquier categora con co-productos: los productos necesariamente distribuyen sobre los \nco-productos.\n$ (A + B) times C tilde.equiv (A times C) + (B times C) $\n\u003C/Aside>\n\u003C/div>\n\n## Clculo proposicional\n\nDemos un sistema de reglas para el clculo proposicional intuicionista (CPI). Esto lo \nharemos en trminos de deducciones $p tack.r q$ entre frmulas $p$ y $q$:\n\n1. $tack.r$ es reflexiva y transitiva.\n2. $p tack.r top$.\n3. $bot tack.r p$.\n4. $p tack.r q$ y $p tack.r r$ si y slo si $p tack.r q and r$.\n5. $p tack.r r$ y $q tack.r r$ si y slo si $p or q tack.r r$.\n6. $p and q tack.r r$ si y slo si $p tack.r q arrow.double r$.\n\nEste es un sistema completo para PCI, equivalente a la presentacin ms usual. Para \ncomparar, novemos que tenemos una deduccin de \"evaluacin\" por reflexividad y 6:\n\n```typst \n$ \n  p & arrow.double q tack.r p arrow.double q \\\n  (p arrow.double q) & and p tack.r q\n$\n```\nAs, tenemos la regla \"modus ponens\" por 4 y transitividad:\n\n```typst \n$\n  top & tack.r p arrow.double q quad \"y\" quad top tack.r p \\\n  top & tack.r (p arrow.double q) and p \\\n  top & tack.r q\n$\n```\nTambin, por 4, hay \"proyecciones\":\n\n```typst \n$\n  p and q & tack.r p and q \\\n  p and q & tack.r p quad (\"respectivamente \" q)\n$\n```\n\nde lo que se sigue que que $p tack.l tack.r top and p$. As, obtenemos uno de los axiomas \nusuales para productos:\n\n```typst \n$\n  p and q & tack.r p \\\n  top and (p and q) & tack.r p \\\n  top & tack.r (p and q) arrow.double p\n$\n```\n\nAhora derivemos los axiomas usuales para $arrow.double$, a saber:\n\n1. $p arrow.double p$,\n2. $p arrow.double (q arrow.double p)$,\n3. $(p arrow.double (q arrow.double r)) arrow.double ((p arrow.double q) arrow.double (p arrow.double r))$.\n\nLos primeros dos son casi inmediatos:\n\n```typst \n$\n  p & tack.r p \\\n  top and p & tack.r p \\\n  top tack.r p arrow.double p\n$\n```\n```typst \n$\n  p and q & tack.r p \\\n  p & tack.r q arrow.double p \\\n  top and p & tack.r q arrow.double p \\\n  top & tack.r p arrow.double (q arrow.double p)\n$\n```\n\npara el tercero, usamos el hecho de que $arrow.double$ distribuye sobe $and$ por la derecha\n\n$ a arrow.double (b and c) tack.l tack.r (a arrow.double b) and (a arrow.double c) $\n\nEsto es un caso especial de \n\n$ (B times C)^A tilde.equiv B^A times C^A $\n\nTambin usamos el siguiente hecho \n\n$ a tack.r b quad \"implica\" quad p arrow.double a tack.r p arrow.double b $\n\nEntonces tenemos \n\n```typst \n$\n  (q arrow.double r) and q & tack.r r \\\n  p arrow.double ((q arrow.double r) and q) & tack.r p arrow.double r \\\n  (p arrow.double (q arrow.double r)) and (p arrow.double q) & tack.r p arrow.double r \\\n  (p arrow.double (q arrow.double r)) & tack.r (p arrow.double q) arrow.double (p arrow.double r) \\\n  top & tack.r (p arrow.double (q arrow.double r)) arrow.double ((p arrow.double q) and (p arrow.double r)).\n$\n```\nEl fragmento \"positivo\" del CPI, que involucra slo las operaciones lgicas \n\n$ top, and, arrow.double $\n\ncorresponde a la nocin de conjunto parcialmente ordenado cartesiano cerrado. Despus \naadimos $bot$ y la disyuncin $p or q$ en el lado lgico y joins finitos en el lado \nalgebraico para llegar a la correspondencia entre CPI y las lgebras de Heyting. \nLa correspondencia exacta est dada por construcciones mutuamente inversas entre \nlgebras de Heyting y CPIs. \n\nDado un CPI $cal(L)$ consistente de frmulas proposicionales $p, q, r, dots$ sobre un \nconjunto de variables $x, y, z, dots$ junto con las reglas de inferencias que mencionamos \nantes y, tal vez algunas frmulas distinguidas $a, b, c, dots$ como axiomas, podemos \nconstruir a partir de $cal(L)$ un lgebra de Heyting $\"HA\"(cal(L))$, llamada el lgebra \nde *Lindenbaum-Tarski*, que consiste de clases de equivalencias $[p]$ de frmulas $p$, \ndonde \n\n$ [p] = [q] quad \"si y slo si\" quad p tack.l tack.r q $\n\nEl orden en $\"HA\"(cal(L))$ est dado por \n\n$ [p] lt.eq [q] quad \"si y slo si\" quad p tack.r q $\n\nEsta relacin est bien definida sobre clases de equivalencia, en el sentido de que si \n$p tack.r q$ y $[p] = [p']$ y $[q] = [q']$, entonces $p' tack.r q'$. Las operaciones en \n$\"HA\"(cal(L))$ se introducen en la manera esperada \n\n```typst \n$\n  1 & = [top] \\\n  0 & = [bot] \\\n  [p] and [q] & = [p and q] \\\n  [p] or [q] & = [p or q] \\\n  [p] arrow.double [q] & = [p arrow.double q]\n$\n```\n\nDe nuevo, podemos ver fcilmente que estas operaciones estn bien definidas sobre clases \nde equivalencia y que satisfacen las leyes de las lgebras de Heyting.\n\n\u003Cdiv id=\"lema-6-13\">\n\u003CAside type=\"tip\" title=\"Lema 6.13\">\n\nNotemos que, como $[p] = [q]$ si y slo si $p tack.l tack.r q$, el lgebra de Heyting \n$\"HA(cal(L))\"$ tiene la propiedad de que una frmula $p$ puede ser demostrada \n$top tack.r p$ si y slo si $[p] = 1$. \n\n\u003C/Aside>\n\u003C/div>\n\nAhora, definamos una *interpretacin* $M$ de $cal(L)$ en un lgebra de Heyting $H$ como \nuna asignacin de las variables proposicionales bsicas $x, y, z, dots$ a los elementos \nde $H$, que escribiremos como $[[x]], [[y]], [[z]], dots$. Una interpretacin se extiende \na todas las frmulas por recursin de forma evidente, es decir, \n$[[p and q]] = [[p]] and [[q]]$, etc. Una interpretacin es llamada un *modelo* de \n$cal(L)$ si para cada teorema $top tack.r p$, se tiene que $[[p]] = 1$. Observemos que \nhay una interpretacin cannica de $cal(L)$ en $\"HA\"(cal(L))$ dada por $[[x]] = [x]$, se \npuede mostrar por induccin que, para cada frmula $p$, $[[p]] = [p]$. Ahora, \npor el lema [6.13](#lema-6-13) se tiene que esta interpretacin es de hecho un modelo de\n$cal(L)$ y es \"genrica\", en el sentido de que valida nicamente las frmulas que se pueden\nprobar. Por tanto, tenemos el siguiente teorema de completes para IPC.\n\n\u003Cdiv id=\"proposicion-6-14\">\n\u003CAside type=\"tip\" title=\"Proposicin 6.14\">\nEl clculo proposicional intuicionista es completo con respecto a los modelos en las \nlgebras de Heyting. \n\n*Demostracin* Supongamos que una frmula $p$ es verdadera en todos los modelos dentro de \ntodas las lgebras de Heyting. Entonces, en particular, lo es en $\"HA\"(cal(L))$. As, \n$1 = [[p]] = [p]$ en $\"HA\"(cal(L))$ y, por tanto, $top tack.r p$.\n\u003C/Aside>\n\u003C/div>\n\nEn resumen, una instancia particular $cal(L)$ del CPI puede pensarse como una manera de \nespecificar y pensar sobre un lgebra de Heyting particular $\"HA(cal(L))\"$.\n\n## Igualdad definicional de CCCs\n\nLa siguiente descripcin de las CCCs es trminos de operaciones y ecuaciones en una \ncategora es til.\n\n\u003Cdiv id=\"proposicion-6-15\">\n\u003CAside type=\"tip\" title=\"Proposicon 6.15\">\nUna categora $bold(C)$ es una CCC si y slo si tiene la siguiente estructura:\n\n- Un elemento distinguido $1$, tal que para cada objeto $C$ hay una flecha \n  $ !_C : C arrow 1 $\n  de tal manera que para cada flecha $f : C arrow 1$, \n  $ f = !_C. $\n\n- Para cada par de objetos $A$ y $B$, hay un objeto $A times B$ y flechas \n  $ p_1 : A times B arrow A quad \"y\" quad p_2: A times B arrow B $\n  de tal forma que, para cualquier par de flechas $f : Z arrow A$ y $g : Z arrow B$, hay \n  una flecha \n  $ ( f, g ) : z arrow A times B $\n  tal que \n  ```typst \n  $\n    p_1 compose (f, g) = f \\\n    p_2 compose (f, g) = g \\\n    (p_1 compose h, p_2 compose h) = h quad \"para cada\" quad h: Z arrow A times B.\n  $\n  ```\n- Para cada par de objetos $A$ y $B$ hay un objeto $B^A$ y una flecha \n  $ epsilon : B^A times A arrow B $\n  de tal manera que para cada flecha $f : Z times A arrow B$, hay una flecha \n  $ tilde(f) : Z arrow B^A $\n  tal que \n  $ epsilon compose (tilde(f) times 1_B) = f $\n  y \n  $ tilde((epsilon compose (g times 1_A))) = g $\n  para cada $g : Z arrow B^A$. Aqu y, ms en general, para cada $a : X arrow A$ y \n  $b : Y arrow B$, escribimos \n  $ a times b = (a compose p_1, b compose p_2) : X times Y arrow A times B. $\n\n\u003C/Aside>\n\u003C/div>\n\n## clculo lambda \n\nVimos que las nociones de conjunto parcialmente ordenado cartesiano cerrado con joins \nfinitos (un lgebra de Heyting) y el clculo proposicional intuicionista son \nesencialmente lo mismo: \n$ \"HA\" tilde \"CPI\" $\nEstas son dos maneras de describir la misma estructura donde la descripcin lgica contiene\ndatos superfluos en la eleccin de una presentacin particular. \n\nAhora consideramos una correspondencia muy similar entre sistemas de la lgica y \ncategoras que involucran CCCs en general. En efecto, el ejemplo anterior era el caso \nde conjuntos parcialmente ordenados del caso ms general entre CCCs y $lambda$-clculo:\n$ \"CCC\" tilde lambda-\"clculo\". $\n\nEstas nociones son esencialmente equivalentes en un sentido que ahora esbozamos. Son dos \nformas de representar la misma idea, la de coleccin de objetos y funciones con \noperaciones de emparejamiento, proyeccin, aplicacin y transposicin (o \"currying\").\n\nPrimero, recordemos la nocin de $lambda$-clculo tipado. Consiste de \n\n- Tipos: $A times B$, $A arrow B$, $dots$ (y algunos tipos bsicos).\n- Trminos: $x, y, z, dots : A$ (variables para cada tipo $A$)\n  $a : A, b : B, dots $ (algunas constantes tipadas)\n  ```typst \n  $\n    (a, b) : A times B quad (a : A, b : B) \\\n    \"fst\"(c) : A       quad (c : A times B) \\\n    \"snd\"(c) : B       quad (c : A times B) \\\n    c a : B             quad (c : A times B, a : A) \\\n    lambda x. b : A arrow B quad (x : A, b : B)\n  $\n  ```\n- Ecuaciones que incluyen, al menos todas las instancias de las siguientes:\n  ```typst \n  $ \n    \"fst\"((a,b)) = a \\\n    \"snd\"((a,b)) = b \\\n    (\"fst\"(c), \"snd\"(c)) = c \\\n    (lambda x. b) a = b[a\\/x] \\\n    lambda x. c x = c quad (\"no hay \" x \" en \" c)\n  $\n  ```\n\nDado un $lambda$-clculo particular $cal(L)$, la categora de tipos asociada \n$bold(C)(cal(L))$ se define como sigue:\n\n- Objetos: los tipos, \n- Flechas $A arrow B$: clases de equivalencia de trminos cerrados $[c]: A arrow B$, \n  identificados de acuerdo al renombramiento de variables ligadas y \n  $ [a] = [b] quad \"si y slo si\" quad cal(L) tack.r a = b, $\n- Identidades: $1_A = [lambda x. x]$ (donde $x : A$),\n- Composicin: $[c] compose [b] = [lambda x. c (b x)]$.\n\nEsta es una categora bien definida que tiene productos finitos. Es una cuestin simple \naadir un objeto terminal. Ahora usemos la caracterizacin que dimos de las CCCs para \nmostrar que es cartesiana cerrada. Dados dos objetos $A$ y $B$ proponemos $B^A = A arrow B$\ny, como la flecha evaluacin, tomamos la clase de equivalencia \n\n$ epsilon = lambda z. \"fst\" (z) \"snd\"(z) : B^A times A arrow B quad (z : Z)$ \n\nEntonces para cualquier flecha $f : Z times A arrow B$ tomamos como su transposicin a \n\n$ tilde(f) = lambda z. lambda x. f(z, x) : Z arrow B^A quad (z : Z, x : A). $\n\nAhora\n\n```typst \n$\n  epsilon compose (tilde(f) times 1_A) & = (lambda z. \"fst\"(z) \"snd\"(z)) compose [(lambda y. lambda x. f(y,x)) times lambda u. u] \\\n  & = lambda v . (lambda z . \"fst\"(z) \"snd\" (z)) [(lambda y. lambda x. f(y,x)) times lambda u.u]v \\\n  & = lambda v . (lambda z \"fst\" (z) \"snd\" (z)) [lambda w. ((lambda y. lambda x. f(y,x)) \"fst\"(w), (lambda u. u) \"snd\" (w))] v \\\n  & = lambda v . (lambda z. \"fst\" (z) \"snd\" (z)) [(lambda x. f(\"fst\" (v), x), \"snd\" (v))] \\\n  & = lambda v. (lambda x. f(\"fst\" (v), x)) \"snd\" (v) \\\n  & = lambda v. f (\"fst\" (v), \"snd\" (v)) \\\n  & = lambda v. f v \\\n  & = f\n$\n```\n\nDe manera similar, $tilde((epsilon compose (g times 1_A))) = g$.\n\nLlamemos a un conjunto de tipos bsicos y trminos, junto con un conjunto de ecuaciones \nentre trminos una *teora* en el $lambda$-clculo. Dada una teora de este tipo $cal(L)$,\nla categora cartesiana cerrada $bold(C)(cal(L))$ que se construye del $lambda$-clculo \nsobre $cal(L)$ es la CCC presentada por sus generadores y relaciones. \n\n\u003Cdiv id=\"defincion-6-16\">\n\u003CAside type=\"tip\" title=\"Definicin 6.16\">\nUn *modelo* de $cal(L)$ en $bold(C)$ es una asignacin de tipos y trminos de $cal(L)$\na objetos y flechas de $bold(C)$:\nDonde el tipo $X$ corresponde al objeto $[[X]]$ y la flecha $b : A arrow B$ corresponde \na $[[b]] : [[A]] arrow [[B]]$.\nEsta asignacin se extiende a todos los tipos y trminos de tal manera que las operaciones \ndel $lambda$-clculo se corresponden con las de la CCC:\n$ [[A times B]] = [[A]] times [[B]]\\\\ [[(f,g)]] = ([[f]], [[g]])\\\\ \"etc\" $\nFinalmente, se requiere que todas las ecuaciones de $cal(L)$ se satisfagan, en el sentido\nde que \n$ \n  cal(L) tack.r [a] = [b] : A arrow B quad \"implica\" quad [[a]] = [[b]] : [[A]] arrow [[B] \n$\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"proposicion-6-17\">\n\u003CAside type=\"tip\" title=\"Proposicin 6.17\">\nPara cualquier teora $cal(L)$ en el $lambda$-clculo, se tiene: \n1. Para cualesquiera trminos $a$ y $b$, $cal(L) tack.r a = b$ si y slo si pata todo \n  modelo $M$ en CCCs, $[[a]]_M = [[b]]_M$.\n2. Para cualquier tipo $A$, hay una $t : A$ cerrada si y slo si para todos los modelos \n    $M$ en CCCs, hay una flecha $1 arrow [[A]]_M$.\n\u003C/Aside>\n\u003C/div>\n\nEsta proposicin dice que el $lambda$-clculo es *deductivamente consistente* y *completo*\npara modelos en CCCs. \n\nFinalmente, observemos que las nociones de $lambda$-clculo y CCC son esencialmente \nequivalentes. Dada una CCC $bold(C)$, definimos $cal(L)(bold(C))$ como:\n\n- Tipos bsicos: los objetos de $bold(C)$.\n- Trminos bsicos: $a : A arrow B$ para cada $a : A arrow B$ en $bold(C)$.\n- Ecuaciones: muchas ecuaciones identificando las operaciones del $lambda$-clculo con la \n  estructura correspondiente en $bold(C)$, por ejemplo:\n  ```typst \n  $\n    lambda x. \"fst\"(x) = p_1 \\\n    lambda x. \"snd\"(x) = p_2 \\\n    lambda y. f(x, y) = tilde(f) (x) \\\n    g (f (x)) = (g compose f) (x) \\\n    lambda y. y = 1_A\n  $\n  ```\n\n  Esto es suficiente para asegurarnos de que hay un isomorfismo de categoras \n\n  $ bold(C)(cal(L)(bold(C))) tilde.equiv bold(C). $","src/content/docs/categorias/Awodey/exponenciales.mdx","da1dfc1374d96bf0","categorias/awodey/limites",{"id":460,"data":462,"body":469,"filePath":470,"digest":471,"deferredRender":16},{"title":463,"editUrl":16,"head":464,"template":18,"sidebar":465,"pagefind":16,"draft":20,"sitemap":467},"Lmites",[],{"order":65,"hidden":20,"attrs":466},{},{"linkInclusionRules":468},[24],"import { Aside } from '@astrojs/starlight/components';\n\nLos productos, objetos terminales, pullbacks y equalizadores son casos especiales de la \nnocin ms general de lmite.\n\n\u003Cdiv id=\"definicion-5-15\">\n\u003CAside type=\"tip\" title=\"Defincin 5.15\">\nSean $bold(J)$ y $bold(C)$ categoras. Un diagrama de tipo $bold(J)$ en $bold(C)$ es un \nfunctor \n\n$ D : bold(J) arrow bold(C). $\n\nEscribimos a los objetos de la categora de ndices $bold(J)$ con minsculas $i, j, dots$\ny a los valores del functor $D : bold(J) arrow bold(C)$ como $D_i, D_j, dots$.\n\nUn *cono* para un diagrama $D$ consiste de un objeto $C$ en $bold(C)$ y una familia de \nflechas en $bold(C)$,\n\n$ c_j : C arrow D_J $\n\nuna para cada objeto $j in J$, de tal manera que para cada flecha $alpha : i arrow j$ en \n$bold(J)$, el siguiente tringulo conmuta \n\n```typst \n#commutative-diagram(\n  node((0, 0), $C$),\n  node((0, 1), $D_j$),\n  node((1, 0), $D_i$),\n  arr($C$, $D_j$, $c_j$),\n  arr($C$, $D_i$, $c_i$),\n  arr($D_i$, $D_j$,$D_alpha$)\n)\n```\nUn *morfismo* de conos \n\n$ theta : (C, c_j) arrow (C', c'_j) $  \n\nes una flecha $theta$ en $bold(C)$ que hace que cada tringulo \n\n```typst \n#commutative-diagram(\n  node((0, 0), $C$),\n  node((0, 1), $C'$),\n  node((1, 1), $D_j$), \n  arr($C$, $D_j$, $c_j$),\n  arr($C'$, $D_j$, $c'_j$),\n  arr($C$, $C'$, $theta$)\n)\n```\nconmute.\n\n\u003C/Aside>\n\u003C/div>\n\nAs, hay una categora \n\n$ bold(\"Cone\")(D) $\n\nde conos de $D$, donde los objetos son conos y los morfismos son morfismos de conos.\n\n\u003Cdiv id=\"defincion-5-16\">\n\u003CAside type=\"tip\" title=\"Definicin 5.16\">\nUn *lmite* para un diagrama $D : bold(J) arrow bold(C)$ es un objeto terminal en \n$bold(\"Cone\") (D)$. Un *lmite finito* es un lmite para un diagrama sobre una categora \nfinita de ndices.\nDenotamos un lmite en la forma \n\n$ p_i : lim_(arrow.long.l_j) D_j arrow D_i $\n\u003C/Aside>\n\u003C/div>\n\nLas nociones de conos y lmites se dualizan a las nociones de co-conos y co-lmites.","src/content/docs/categorias/Awodey/limites.mdx","95d0ecb85f11b006","categorias/awodey/naturalidad",{"id":472,"data":474,"body":481,"filePath":482,"digest":483,"deferredRender":16},{"title":475,"editUrl":16,"head":476,"template":18,"sidebar":477,"pagefind":16,"draft":20,"sitemap":479},"Naturalidad",[],{"order":117,"hidden":20,"attrs":478},{},{"linkInclusionRules":480},[24],"import { Aside } from '@astrojs/starlight/components';\n\n## Categoras de categoras \n\nLa categora $bold(\"Cat\")$ tiene co-productos finitos $bold(0)$, $bold(C) + bold(D)$ y \nproductos finitos $bold(1), bold(C) times bold(D)$. Es fcil ver que tambin tiene todos \nlos co-productos y productos pequeos, que se construyen de forma anloga. As, podemos \nmostrar que $bold(\"Cat\")$ tiene todos los lmites construyendo equalizadores. As, sean \n$bold(C)$ y $bold(D)$ dos categoras y $F, G : bold(C) arrow bold(D)$ dos functores \nparalelos. Definamos la categora $bold(E)$ y el functor $E$, \n\n```typst \n#commutative-diagram(\n  node((0, 0), $bold(E)$),\n  node((0, 1), $bold(C)$),\n  node((0, 2), $bold(D)$),\n  arr($bold(E)$, $bold(C)$, $E$),\n  arr($bold(C)$, $bold(D)$, $F$, \"two\"),\n  arr($bold(C)$, $bold(D)$, $G$, \"two\", label-pos: right)\n)\n```\ncomo sigue: \n\n$ bold(E)_0 = brace.l C in bold(C)_0 | F(C) = G(C)  brace.r $\n$ bold(E)_1 = brace.l f in bold(C)_1 | F(f) = G(f) brace.r $\n\ny sea $E : bold(E) arrow bold(C)$ la inclusin evidente. Este es un equalizador.\n\nLa categora $bold(E)$ es un ejemplo de *sub-categora*, es decir, un monomorfismo en \n$bold(\"Cat\")$ (los equalizadores son monos). \n\n\u003Cdiv id=\"definicion-7-1\">\n\u003CAside type=\"tip\" title=\"Definicin 7.1\">\nUn functor $F : bold(C) arrow bold(D)$ se dice que es \n- *inyectivo sobre objetos* si la parte de objetos $F_0 : bold(C)_0 arrow bold(D)_0$ es \n  inyectiva, es *suprayectiva sobre objetos* si $F_0$ es suprayectivo.\n- $F$ es *inyectivo (suprayectivo) sobre flechas* si la parte de las flechas $F_1$ lo es.\n- $F$ es *fiel* si para cada $A, B in bold(C)_0$, el mapa \n  $ F_(A, B) : \"Hom\"_(bold(C)) (A, B) arrow \"Hom\"_(bold(D)) (F(A), F(B)) $\n  definido por $f mapsto F(f)$ es inyectivo.\n- $F$ es *pleno* si $F_(A, B)$ es siempre suprayectivo.\n\u003C/Aside>\n\u003C/div>\n\n## Transformaciones naturales\n\nUna transformacin natural es un morfismo de functores. Esto es correcto: para dos \ncategoras $bold(C)$ y $bold(D)$, podemos pensar a los functores $bold(C) arrow bold(D)$\ncomo los objetos de una nueva categora y las flechas entre estos objetos es lo que \nllamaremos transformaciones naturales. \n\nComencemos considerando un cierto tipo de situacin que ocurre muchas veces: observamos \nque cierta construccin en una categora $bold(C)$ y otra construccin estn relacionadas \nentre s de una manera que es independiente de los objetos y flechas especficos. Es decir,\nla relacin es entre las construcciones mismas. Para dar un ejemplo, supongamos que \n$bold(C)$ tiene productos y consideremos, para objetos $A, B, C in bold(C)$,\n\n$ (A times B) times C  \" y \" A times (B times C). $\n\nSin importar los objetos $A, B$ y $C$ son, tenemos un isomorfismo \n\n$ h : (A times B) times C tilde(arrow) A times (B times C). $\n\nQu significa que este isomorfismo no dependa de los objetos particulares $A$, $B$ y $C$?\nUna forma de explicarlo es la siguiente:\n\nDada cualquiera $f : A arrow A'$, tenemos un cuadrado conmutativo \n\n```typst \n#commutative-diagram(\n  node((0, 0), $(A times B) times C$),\n  node((0, 1), $A times (B times C)$),\n  node((1, 0), $(A' times B) times C$),\n  node((1, 1), $A' times (B times C)$),\n  arr($(A times B) times C$, $A times (B times C)$, $h_A$),\n  arr($(A times B) times C$, $(A' times B) times C$, \"\"),\n  arr($(A' times B) times C$, $A' times (B times C)$, $h_(A')$),\n  arr($A times (B times C)$, $A' times (B times C)$, \"\")\n)\n```\n\nAs que, lo que realmente tenemos es un isomorfismo entre construcciones \n\n$ (- times B) times C quad \"y\" quad - times (B times C) $\n\nsin importar qu hay en el lugar del argumento. \n\nAhora, por construccin, nos referimos a un functor y por una \n\"relacin entre construcciones\" nos referimos a un *morfismo de functores* que es lo que \nvamos a definir. En el ejemplo, hay un isomorfismo \n\n$ (- times B) times C tilde.equiv - times (B times C) $\n\nde functores $bold(C) arrow bold(C)$. De hecho, podemos considerar los functores de \ntres argumentos:\n\n$ F = (-_1 times -_2) times -_3 : bold(C)^3 arrow bold(C) $\n\ny \n\n$ G = -_1 times (-_2 times -_3) : bold(C)^3 arrow bold(C) $\n\ny hay un isomorfismo anlogo \n\n$ F tilde.equiv G. $\n\nPero un isomorfismo es un morfismo especial, as que definamos esa nocin primero.\n\n\u003Cdiv id=\"definicion-7-6\">\n\u003CAside type=\"tip\" title=\"Definicin 7.6\">\nPara categoras $bold(C)$ y $bold(D)$ y functores \n\n$ F, G : bold(C) arrow bold(D) $\n\nuna *transformacin natural* $theta : F arrow G$ es una familia de flechas en $bold(D)$\n\n$ (theta_C : F(C) arrow G(C))_(C in bold(C)_0) $\n\ntal que, para cada $f : C arrow C'$ en $bold(C)$, se tiene que \n$theta_(C') compose F(f) = G(f) compose theta_C$, es decir, el siguiente cuadrado conmuta \n\n```typst \n#commutative-diagram(\n  node((0, 0), $F(C)$),\n  node((0, 1), $G(C)$),\n  node((1, 0), $F(C')$),\n  node((1, 1), $G(C')$),\n  arr($F(C)$, $G(C)$, $theta_C$),\n  arr($F(C')$, $G(C')$, $theta_(C')$),\n  arr($F(C)$, $F(C')$, $F(f)$),\n  arr($G(C)$, $G(C')$, $G(f)$)\n)\n```\nDada una trasformacin natural $theta : F arrow G$, la $bold(D)$-flecha \n$theta_C : F(C) arrow G(C)$ es llamada la *componente* de $theta$ en $C$. \n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-7-9\">\n\u003CAside type=\"tip\" title=\"Definicin 7.9\">\nLa *categora de functores* $\"Fun\"(bold(C), bold(D))$ tiene \n\n- Objetos: functores $F : bold(C) arrow bold(D)$,\n- Flechas: transformaciones naturales $theta : F arrow G$.\n\nPara cada objeto $F$, la transformacin natural $1_F$ tiene componentes\n$ (1_F)_C = 1_(F(C)) : F(C) arrow F(C) $\n\ny la composicin de transformaciones naturales $F arrow^(theta) G arrow^(phi) H$ tiene \ncomponentes \n\n$ (phi compose theta)_C = phi_C compose theta_C. $\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"defincion-7-10\">\n\u003CAside type=\"tip\" title=\"Definicin 7.10\">\nUn *isomorfismo natural* es una transformacin natural \n\n$ theta : F arrow G $\n\nque es un isomorfismo en la categora de functores $\"Fun\"(bold(C), bold(D))$.\n\u003C/Aside>\n\u003C/div>\n\n### Ejemplo \nConsideremos la categora \n\n$ \"Vect\"(RR) $\n\nde espacios vectoriales y transformaciones lineales \n\n$f : V arrow W. $\n\nTodo espacio vectorial tiene un *espacio dual*\n\n$ V^star = \"Vect\"(V, RR) $\n\nde transformaciones lineales hacia $RR$. Y toda transformacin lineal \n\n$ f : V arrow W $\n\nda lugar a una transformacin lineal dual \n\n$ f^star : W^star arrow V^star $\n\ndefinida por la pre-composicin $f^star(A) = A compose f$ para $A : W arrow RR$. En \npocas palabras, $(-)^star = \"Vect\"(-, RR) : bold(\"Vect\"^(\"op\")) arrow bold(\"Vect\")$ es el \nfunctor *representable contra-variante* dotado de estructura de espacio vectorial.\n\nHay una transformacin lineal cannica de cada espacio vectorial en su doble dual \n\n$ eta_V : V arrow V^(star star) $\n$ x mapsto (\"ev\"_x : V^star arrow RR) $ \n\ndonde $\"ev\"_x (A) = A(x)$ para cada $A : V arrow RR$. Este mapa es el componente de una \ntransformacin natural \n\n$ eta : 1_(bold(\"Vect\")) arrow star star $\n\npues el siguiente diagrama siempre conmuta \n\n```typst \n#commutative-diagram(\n  node((0, 0), $V$),\n  node((0, 1), $V^(star star)$),\n  node((1, 0), $W$),\n  node((1, 1), $W^(star star)$),\n  arr($V$, $W$, $f$),\n  arr($V^(star star)$, $W^(star star)$, $f^(star star)$),\n  arr($V$, $V^(star star)$, $eta_V$),\n  arr($W$, $W^(star star)$, $eta_W$)\n)\n```","src/content/docs/categorias/Awodey/naturalidad.mdx","786e50c41d7f40a5","categorias/awodey/pullbacks",{"id":484,"data":486,"body":493,"filePath":494,"digest":495,"deferredRender":16},{"title":487,"editUrl":16,"head":488,"template":18,"sidebar":489,"pagefind":16,"draft":20,"sitemap":491},"Pullbacks",[],{"order":130,"hidden":20,"attrs":490},{},{"linkInclusionRules":492},[24],"import { Aside } from '@astrojs/starlight/components';\n\nLa nocin de pullback, como la de producto, es una que surge comnmente en la matemtica y\nla lgica. Es una generalizacin de la interseccin y de la imagen inversa.\n\nComenzamos con una definicin \n\n\n\u003Cdiv id=\"definicion-5-4\">\n\u003CAside type=\"tip\" title=\"Definicin 5.4\">\n\nEn cualquier categora $bold(C)$, dadas dos flechas $f$ y $g$ tales que $\"cod\"(f) = \"cod\"(g)$,\n\n```typst \n#commutative-diagram(\n  node((0,1), $B$),\n  node((1,0), $A$),\n  node((1,1), $C$),\n  arr($A$, $C$, $f$),\n  arr($B$, $C$, $g$)\n)\n```\n\nel pullback de $f$ y $g$ consiste de flechas \n\n```typst \n#commutative-diagram(\n  node((0,0), $P$),\n  node((0,1), $B$),\n  node((1,0), $A$),\n  arr($P$, $B$, $p_2$),\n  arr($P$, $A$, $p_1$)\n)\n```\n\nde modo que $f compose p_1 = g compose p_2$ y es universal con esta propiedad. Es decir,\ndada $z_1 : Z arrow A$ y $z_2: Z arrow B$ con $f compose z_1 = g compose z_2$, existe una \nnica $u : Z arrow P$ con $z_1 = p_1 compose u$ y $z_2 = p_2 compose u$. Esto est ilustrado\nen el siguiente diagrama:\n\n```typst \n#commutative-diagram(\n  node((0,0), $Z$),\n  node((1,1), $P$),\n  node((1,2), $B$),\n  node((2,1), $A$),\n  node((2,2), $C$),\n  arr($Z$, $P$, $u$, \"dotted\"),\n  arr($Z$, $B$, $z_2$),\n  arr($Z$, $A$, $z_1$),\n  arr($P$, $A$, $p_1$),\n  arr($P$, $B$, $p_2$),\n  arr($A$, $C$, $f$),\n  arr($B$, $C$, $g$)\n)\n```\n\u003C/Aside>\n\u003C/div>\nLos pullbacks son nicos salvo isomorfismos pues estn dados mediante una propiedad \nuniversal. \nEn trminos de elementos generalizados, cualquier $z in A times_C B$, se puede escribir \nde manera nica como $z = angle.l z_1, z_2 angle.r$. Esto hace que \n\n$ A times_C B = brace.l angle.l z_1, z_2 angle.r in A times B | f compose z_1 = g compose z _2 brace.r $\n\nparezca un sub-objeto de $A times B$, determinado como un equalizador de $f compose pi_1$ y \n$g compose pi_2$. De hecho, es as.\n\n\u003Cdiv id=\"proposicion-5-5\">\n\u003CAside type=\"tip\" title=\"Proposicin 5.5\">\nEn una categora con productos y equalizadores, dada una esquina de flechas \n\n```typst \n#commutative-diagram(\n  node((0,1), $B$),\n  node((1,0), $A$),\n  node((1,1), $C$),\n  arr($B$, $C$, $g$),\n  arr($A$, $C$, $f$)\n)\n```\n\nconsideremos el diagrama\n\n```typst \n#commutative-diagram(\n  node((0,0), $Z$),\n  node((1,1), $P$),\n  node((1,2), $B$),\n  node((2,1), $A$),\n  node((2,2), $C$),\n  arr($Z$, $P$, $e$),\n  arr($Z$, $B$, $p_2$),\n  arr($Z$, $A$, $p_1$),\n  arr($P$, $A$, $pi_1$),\n  arr($P$, $B$, $pi_2$),\n  arr($A$, $C$, $f$),\n  arr($B$, $C$, $g$)\n)\n```\nen el que $e$ es un equalizador de $f compose pi_1$ y $g compose pi_2$ y \n$p_1 = pi_1 compose e$ y $p_2 = pi_2 compose e$. Entonces $E$, $p_1$ y $p_2$ forman un \npullback de $f$ y $g$. Recprocamente, si $E$, $p_1$ y $p_2$ son dados como un pullback, \nentonces, la flecha \n\n$ e = angle.l p_1, p_2 angle.r : E arrow A times B $\n\nes un equalizador de $f compose pi_1$ y $g compose pi_2$.\n\n*Demostracin* Tomemos \n```typst \n#commutative-diagram(\n  node((0,0), $Z$),\n  node((0,1), $B$),\n  node((1,0), $A$),\n  arr($Z$, $B$, $z_2$),\n  arr($Z$, $A$, $z_1$)\n)\n```\n\ncon $f compose z_1 = g compose z_2$. Tenemos que \n$angle.l z_1, z_2 angle.r : Z arrow A times B$, de modo que \n\n$ f compose pi_1 compose angle.l z_1, z_2 angle.r = g compose pi_2 compose angle.l z_1, z_2 angle.r. $\n\nPor lo tanto, hay una $u : Z arrow E$ al equalizador con\n$e compose u = angle.l z_1, z_2 angle.r$. Entonces \n\n$ p_1 compose u = pi_1 compose e compose u = pi_1 compose angle.l z_1, z_2 angle.r = z_1 $\n\ny \n\n$ p_2 compose u = pi_2 compose e compose u = pi_2 compose angle.l z_1, z_2 angle.r = z_2. $\n\nSi tambin $u' : Z arrow E$ tiene $p_i u' = z_i$, $i = 1,2$. Entonces \n$pi_i e u' = z_i$, de modo que $e u' = angle.l z_1, z_2 angle.r = e compose u$, por lo que \n$u' = u$ puesto que $e$ es mono. El recproco es similar.\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"coroloario-5-6\">\n\u003CAside type=\"tip\" title=\"Corolario 5.6\">\nSi una categora $bold(C)$ tiene productos binarios y equializadores, entonces tiene \npullbacks.\n\u003C/Aside>\n\u003C/div>","src/content/docs/categorias/Awodey/pullbacks.mdx","bada8855d92329e2","categorias",{"id":496,"data":498,"body":504,"filePath":505,"digest":506,"deferredRender":16},{"title":48,"editUrl":16,"head":499,"template":18,"sidebar":500,"pagefind":16,"draft":20,"sitemap":502},[],{"order":104,"hidden":20,"attrs":501},{},{"linkInclusionRules":503},[24],"import { LinkButton } from '@astrojs/starlight/components';\n\n## Notas\n\nEstas son mis notas sobre teora de categoras, por ahora cubre dos libros:\n\n\u003CLinkButton href=\"/categorias/awodey/\" icon=\"right-arrow\">Teora de categoras (Awodey)\u003C/LinkButton>\n\n\u003CLinkButton href=\"/categorias/milewski/\" icon=\"right-arrow\">Teora de categoras para programadores (Milewski)\u003C/LinkButton>","src/content/docs/categorias/index.mdx","dae3355ccc3e1841","categorias/awodey",{"id":507,"data":509,"body":515,"filePath":516,"digest":517,"deferredRender":16},{"title":48,"editUrl":16,"head":510,"template":18,"sidebar":511,"pagefind":16,"draft":20,"sitemap":513},[],{"order":104,"hidden":20,"attrs":512},{},{"linkInclusionRules":514},[24],"Estas son mis notas sobre categoras basadas en el libro de Awodey.","src/content/docs/categorias/Awodey/index.mdx","7f6076b86bd296ad","categorias/milewski",{"id":518,"data":520,"body":527,"filePath":528,"digest":529,"deferredRender":16},{"title":521,"editUrl":16,"head":522,"template":18,"sidebar":523,"pagefind":16,"draft":20,"sitemap":525},"Teora de categoras para programadores",[],{"order":104,"hidden":20,"attrs":524},{},{"linkInclusionRules":526},[24],"Estas son mis notas sobre teora de categoras basadas en el libro de Milewski","src/content/docs/categorias/Milewski/index.mdx","88d8d229facd50f8","categorias/milewski/tipos-de-datos",{"id":530,"data":532,"body":539,"filePath":540,"digest":541,"deferredRender":16},{"title":533,"editUrl":16,"head":534,"template":18,"sidebar":535,"pagefind":16,"draft":20,"sitemap":537},"Tipos de datos algebricos simples",[],{"order":130,"hidden":20,"attrs":536},{},{"linkInclusionRules":538},[24],"import { Aside } from '@astrojs/starlight/components';\n\nLos productos y co-productos son dos formas bsicas de combinar tipos. Resulta que muchas \nde las estructuras de datos de la programacin de todos los das se pueden construir usando\nestos dos mecanismos.\n\n## Tipos producto \n\nLa implementacin cannica del producto de dos tipos en un lenguaje de programacin es \nel emparejamiento. \nLos pares no son estrictamente conmutativos: un par `(Int, Bool)` no puede ser substituido \npor un par `(Bool, Int)`, aunque contengan la misma informacin. Sin embargo, son \nconmutativos salvo isomorfismos, el isomorfismo es la funcin `swap`, que es su propia \ninversa:\n\n```haskell\nswap :: (a, b) -> (b, a\nswap (x, y) = (y, x)\n```\nPodemos combinar una cantidad arbitraria de tipos en un producto poniendo parejas dentro \nde parejas, pero hay una forma ms fcil, las parejas anidadas son equivalentes a las \n`tuples`. Es la consecuencia de que las diferentes formas de anidar parejas sean isomorfas.\n\nSi queremos combinar tres tipos en un producto `a, b` y `c`, podemos hacerlo de dos formas\n\n`((a, b), c)`\n\no \n\n`(a, (b, c))`\n\nEstos tipos son distintos, no podemos pasarle uno a una funcin que espera el otro, pero \nsus elementos estn en una correspondencia bi-unvoca. Hay una funcin que mapera \nunos a otros \n\n```haskell \nalpha :: ((a, b), c) -> (a, (b, c))\nalpha ((x, y), z) = (x, (y, z))\n```\n\ny esta funcin es invertible\n\n```haskell \nalpha_inv :: (a, (b, c)) -> ((a, b), c)\nalpha_inv (x, (y, z)) = ((x, y), z)\n```\nde modo que es un isomorfismo.\n\nEsto corresponde al hecho de que, en una categora $bold(C)$ con productos, si tenemos \nobjetos $A, B$ y $C$ sucede que \n\n$ A times (B times C) tilde.equiv (A times B) times C $\n\nPodemos mostrar que el tipo unidad $()$ es la unidad del producto de la misma manera en la \nque el $1$ es la unidad de la multiplicacin. El tipo \n\n`(a, ())`\n\nes isomorfo a `a`. Aqu est el isomorfismo \n\n```code :language haskell :eval false \nrho :: (a, ()) -> a \nrho (x, ()) = x\n\nrho_inv :: a -> (a, ())\nrho_inv x = (x, ())\n```\n\nHay una manera ms general de definir tipos producto en Haskell. Usa constructores nombrados\ncon mltiples argumentos. Un par, por ejemplo, se puede definir como \n\n```code :language haskell :eval false \ndata Pair a b = P a b \n```\n\nAqu, `Pair a b` es el nombre del tipo parametrizado por otros dos tipos `a` y `b` y \n`P` es el nombre del constructor. Definimos un tipo par pasando dos tipos al constructor \ndel tipo `Pair`. Podemos construir un valor de este tipo pasando dos valores de tipos \napropiados al constructor `P`. Por ejemplo, definamos el valor de `stmt` cono  un par \nde `String` y `Bool`:\n\n```code :language haskell :eval false \nstmt :: Pair String Bool \nstmt = P \"Este enunciado es\" False\n```\nLa primera lnea es la declaracin de tipo. Usa el constructor del tipo `Pair` con \n`String` y `Bool` remplazando `a` y  `b` en la definicin genrica de `Pair`. \nLa segunda lnea define el valor de `stmt` pasando valores concretos al constructor de \ndatos `P`. Los constructores de tipos se usan para eso, construir tipos, mientras que los \nde datos, evidentemente, construyen datos.\n\nComo los espacios de nombres para los constructores de tipos y datos estn separados en \nHaskell, podemos usar el mismo nombre para ambos, por ejemplo: \n\n```code :language haskell :eval false \ndata Pair a b = Pair a b \n```\n\nProgramar con tuplas y constructores de mltiples argumentos se puede volver complicado,\nHaskell nos da un tipo producto con campos nombrados llamados records.\n\n## Records \n\nVeamos un ejemplo simple. Queremos describir los elementos qumicos usando dos strings \ny un entero, un string para el nombre, uno para el smbolo y un entero para \nel nmero atmico. Podramos usar un tuple y recordar qu componente representa qu.\nPero an mejor, podemos definir un record:\n\n```code :language haskell :eval false \ndata Element = Element {\n  name :: String, \n  symbol :: String, \n  atomicNumber :: Int\n} \n```\nLas dos representaciones son isomorfas:\n\n```code :language haskell :eval false \ntupleToElem :: (String, String, Int) -> Element \n\ntupleToElem (n, s, a) = Element {\n  name = n,\n  symbol = s,\n  atomicNumber = a\n}\n\nelemToTuple :: Element -> (String, String, Int)\nelemToTuple e = (name e, symbol e, atomicNumber e)\n```\n\nNotemos que los nombres de los campos de un record tambin sirven como funciones para \nacceder a esos campos. Por ejemplo, `atomicNumber e` obtiene el campo de `e` que \ncorresponde a `atomicNumber`. Usamos a `atomicNumber` como una funcin del tipo \n\n```code :language haskell :eval false \natomicNumber :: Element -> Int \n```\n\n## Tipos suma \n\nAs como el tipo producto en las categoras da lugar a los tipos producto, el co-producto \nda lugar a los tipos suma. La implementacin cannica de un tipo suma en Haskell es:\n\n```code :language haskell :eval false \ndata Either a b = Left a | Right b \n```\nY como las parejas, los `Either` son conmutativos (salvo isomorfismo), pueden anidarse \ny el orden de anidacin es irrelevante (salvo isomorfismo). As, podemos definir el \nel equivalente de la ternas para sumas:\n\n```code :language haskell :eval false \ndata OneOfThree a b c = Sinistral a | Medial b | Dextral a \n```\ny as sucesivamente.\n\nPodemos pensar en `Either` como la suma y `Void` como el cero. Por ejemplo \n\n```code :language haskell :eval false \nEither a Void \n```\nes isomorfo a `a`, pues no hay ninguna manera de construir una versin derecha de este \ntipo. Los nicos habitantes de `Either a Void` son los que se construyen usando el \nconstructor `Left`. As, simblicamente, `a + 0 = a`.\n\nLos tipos suma son muy comunes en Haskell.\n\nUn ejemplo de tipo suma son las listas:\n\n```code :language haskell :eval false \nList a = Nil | Cons a (List a) \n```\nPodramos definir una funcin sobre listas como: \n\n```code :language haskell :eval false \nmaybeTail :: List a -> Maybe (List a)\n\nmaybeTail Nil = Nothing\nmaybeTail (Cons _ t) = Just t\n```\n\ndonde el tipo `Maybe` se define como:\n\n```code :language haskell :eval false \nMaybe a = Nothing | Just a \n```\n\n## lgebra de tipos \n\nRecapitulemos lo que hemos visto hasta ahora. Hemos visto dos estructuras de monoide \ndebajo del sistema de tipos: Tenemos los tipos suma con `Void` como su elemento neutro \ny los tipos producto con `()` como su elemento neutro. \n\nVeamos que tan lejos podemos llevar esta analoga. Por ejemplo, el producto con 0 da 0?\nEn otras palabras, es un tipo producto con un componente `Void` isomorfo a `Void`?\n\nPara crear un par necesitamos dos valores y como no hay valores de tipo `Void`, el producto\ncon `Void` debe estar vaco y, por tanto, debe ser isomorfo a `Void`.\n\nOtra cosa que liga la adicin y la multiplicacin es la ley distributiva: \n\n`a * (b + c) = a * b + a * c`\n\nTambin se mantiene para tipos productos y sumas? S, salvo isomorfismos. El lado \nizquierdo corresponde al tipo \n\n`(a, Either b c)`\n\ny el derecho a \n\n`Either (a, b) (a, c)`\n\nAqu esta la funcin que los convierte en una direccin \n\n```code :language haskell :eval false \nprodToSum :: (a, Either b c) -> Either (a, b) (a, c)\nprodToSum (x, e) = \n  case e of \n    Left y -> Left (x, y)\n    Right z -> Right (x, z)\n```\ny la otra direccin \n\n```code :language haskell :eval false \nsumToProd :: Either (a, b) (a, c) -> (a, Either b c)\nsumToProd e = \n  case e of \n    Left (x, y) -> (x, Left y)\n    Right (x, y) -> (x, Right z)\n```\n\nEl enunciado `case` se usa para hacer pattern matching dentro de funciones. Cada patrn \nest seguido de una flecha y la expresin que se debe evaluar cuando se hace match al \npatrn.","src/content/docs/categorias/Milewski/tipos-de-datos.mdx","c84d308dcdc2a05e","categorias/milewski/functores",{"id":542,"data":544,"body":551,"filePath":552,"digest":553,"deferredRender":16},{"title":545,"editUrl":16,"head":546,"template":18,"sidebar":547,"pagefind":16,"draft":20,"sitemap":549},"Functores",[],{"order":65,"hidden":20,"attrs":548},{},{"linkInclusionRules":550},[24],"Dadas dos categoras $bold(C)$ y $bold(D)$, un functor mapea objetos de $bold(C)$ en \nobjetos de $bold(D)$ y morfismos de $bold(C)$ en morfismos de $bold(D)$.\nSi $f$ es un morfismo en $bold(C)$ que conecta un objeto $a$ a un objeto $b$,\n\n`f :: a -> b`\n\nla imagen de $f$ en $bold(D)$, $F space f$ conectar la imagen de $a$ con la imagen de $b$\n\n`F f :: F a -> F b`\n\ny tambin, si $h$ es la composicin de $f$ con $g$ en $bold(C)$\n\n`h = g . f`\n\nentonces F mapea a $h$ a la composicin de las imgenes de $f$ y $g$ en $bold(D)$:\n\n `F h = F g . F f`\n\nPor ltimo, los morfismos identidad de $bold(C)$ se deben mapear a los morfismos identidad \nen $bold(D)$\n\n`F id_a = id_(F a)`\n\n\n\n## Functores en la programacin\n\nTenemos nuestra categora de tipos y funciones. Podemos hablar de functores que mapean \nesta categora a s misma, este tipo de functores son llamados endofunctores.\n\n### El functor `Maybe`\n\nLa definicin de `Maybe` es un mapeo  de un tipo `a` al tipo `Maybe a`:\n\n`data Maybe a = Nothing | Just a`\n\nAqu hay un sutileza que hay que remarcar. Maybe no es un tipo, es un constructor de tipos.\nLe tenemos que dar un tipo como argumento, para volverlo un tipo. `Maybe` sin un argumento \nrepresenta una funcin entre tipos. Pero, podemos hacer de `Maybe` un functor?\nUn functor no slo mapea objetos, sino tambin morfismos. Para cualquier funcin de \n`a` a `b`:\n\n`f :: a -> b`\n\nqueremos producir una funcin de `Maybe a` a `Maybe b`. Para definir una funcin de este \nestilo necesitamos considerar dos casos, que corresponden a los dos constructores de \n`Maybe`. El caso `Nothing` es fcil, slo regresamos `Nothing` y, si el argumento es \n`Just`, aplicamos la funcin `f` su contenido, de modo que la imagen de `f` bajo \n`Maybe` es la funcin:\n\n```code :language haskell :eval false \nf' :: Maybe a -> Maybe b \nf' Nothing = Nothing \nf' (Just x) = Just (f x)\n```\n\nEn Haskell, implementamos la parte de morfismos de un functor con una funcin de orden \nmayor llamada `fmap`. En el caso de `Maybe` tiene el siguiente tipo:\n\n`fmap :: (a -> b) -> (Maybe a -> Maybe b)`\n\nFrecuentemente diremos que `fmap` eleva una funcin. La funcin elevada acta sobre \nvalores de `Maybe`. \n\nAs es como implementamos `fmap` para `Maybe`:\n\n```code :language haskell :eval false \nfmap :: (a -> b) -> (Maybe a -> Maybe b)\nfmap _ Nothing = Nothing \nfmap f (Just x) = Just (f x)\n```\n### Typeclasses\nUna typeclass define una familia de tipos que soportan una interfaz comn. Por ejemplo, \nla clase de objetos que soportan igualdad se define como sigue:\n\n```code :language haskell :eval false \nclass Eq a where \n  (==) :: a -> a -> Bool\n```\nEsta definicin dice que el tipo `a` es de la clase `Eq` si soporta el operador \n`(==)` que toma dos argumentos de tipo `a` y regresa un `Bool`.\n\nSi queremos decirle a Haskell que un tipo particular es `Eq`, tenemos que declararlo como \nuna instancia de esta clase y proveer una implementacin de `(==)`\n\n## El functor lista\n\nCualquier tipo parametrizado por otro es un candidato para se un functor. Los \ncontenedores genricos estn parametrizados por el tipo de los elementos que guardan, \nas que veamos un contenedor bsico, la lista:\n\n`data List a = Nil | Cons a (List a)`\n\nTenemos el constructor para tipos `List`, que es un mapeo de cualquier tipo al tipo \n`List a`. Para mostrar que `List` es un functor, tenemos que definir el levantamiento \nde funciones: Dada una funcin `a -> b`, definimos una funcin \n`List a -> List b`:\n\n`fmap :: (a -> b) -> (List a -> List b)`\n\nUna funcin que acta sobre una `List` debe considerar dos casos, que corresponden a los \ndos constructores. El caso `Nil` es trivial, basta regresar `Nil`. El caso `Cons` es un \npoco ms delicado, pues involucra algo de recursin.\n\n`fmap f (Cons x t) = Cons ( x t) (fmap f t)`\n\nJuntndolo todo, tenemos la declaracin de instancia para el functor `List`:\n\n```code :language haskell :eval false \ninstance Functor List where \n  fmap _ Nil = Nil \n  fmap f (Cons x t) = Cons (f x) (fmap f t)\n```\n\n## El functor Reader \n\nEn Haskell, un tipo funcin se construye usando el constructor `(->)` que toma dos tipos:\nel tipo argumento y el tipo resultante. Ya lo hemos visto en forma in-fija `a -> b`, pero \ntambin se puede usar como prefijo cuando la envolvemos entre parntesis:\n\n`(->) a b`\n\nAs como las funciones regulares, los tipos funciones de ms de un argumento se pueden \naplicar parcialmente. As, cuando damos slo un tipo a la flecha, todava espera otro,\nas es como `(->) a` es un constructor de tipos. Para mostrar que este constructor de \ntipos es en realidad un functor, hay que mostrar que podemos levantar las funciones. As, \nbuscamos definir \n\n`fmap :: (b -> c) -> (a -> b) -> (a -> c)`\n\nEs decir, dada una funcin `f :: b -> c` y una funcin `g :: a -> b`, queremos construir \nuna funcin `a -> c`. No hace falta romperse la cabeza, slo hay que componer. As, \nnuestra implementacin de `fmap` es: \n\n```code :language haskell :eval false \ninstance Functor (-> a) where \n  fmap f g = f . g\n```\n\nEste functor es conocido como el functor Reader.","src/content/docs/categorias/Milewski/functores.mdx","09a66b05eee3e2f8","categorias/milewski/functorialidad",{"id":554,"data":556,"body":563,"filePath":564,"digest":565,"deferredRender":16},{"title":557,"editUrl":16,"head":558,"template":18,"sidebar":559,"pagefind":16,"draft":20,"sitemap":561},"Functorialidad",[],{"order":78,"hidden":20,"attrs":560},{},{"linkInclusionRules":562},[24],"## Bi-functores\n\nComo los functores son morfismos en la categora `Cat`, muchas de nuestras intuiciones \nsobre morfismos aplican tambin a los functores. Por ejemplo, as como podemos tener \nuna funcin de dos argumentos, podemos tener un functor de dos argumentos o un \n*bi-functor*. Sobre objetos, los bi-functores mapean cada par de objetos, uno de una \ncategora $C$ y uno de una categora $D$ a un objeto en una categora $E$. Notemos \nque esto es lo mismo que decir que es un mapeo de un *producto cartesiano* de \ncategoras $C times D$ a $E$. De manera similar a los objetos, los bi-functores deben \nmapear pares de morfismos de $C$ y $D$ a morfismos de $E$.\n\nSi tenemos un mapeo de un par de categoras a una tercera categora y demostramos que \nes functorial en cada argumento, entonces el mapeo es automticamente un bi-functor.\n\nDefinamos un bi-functor en Haskell. En este caso, las tres categoras son la misma: la \ncategora de los tipos de Haskell. Un bi-functor es un constructor de tipos que toma dos \nargumentos de tipo. Aqu est la definicin de la typeclass de bi-functor:\n\n```code :language haskell :eval false \nclass Bifunctor f where \n  bimap :: (a -> c) -> (b -> d) -> f a b -> f c d \n  bimap g h = first g . second h \n  first :: (a -> c) -> f a b -> f c b \n  first g = bimap g id \n  second :: (b -> d) -> f a b -> f a d \n  second = bimap id\n```\nLa variable de tipo `f` representa el bi-functor. Podemos ver que en todas las type \nsignatures siempre se aplican a dos argumentos de tipos. El primer argumento de tipo \ndefine `bimap`: un mapeo de dos funciones a la vez. El resultado es una funcin \nlevantada `(f a b -> f c d)`, que opera sobre tipos generados por el constructor del tipo \nbi-functor. \n\n## Bi-functores Producto y Co-producto","src/content/docs/categorias/Milewski/functorialidad.mdx","9470decf648603b2","logica-categorica",{"id":566,"data":568,"body":575,"filePath":576,"digest":577,"deferredRender":16},{"title":569,"editUrl":16,"head":570,"template":18,"sidebar":571,"pagefind":16,"draft":20,"sitemap":573},"Lgica categrica",[],{"order":104,"hidden":20,"attrs":572},{},{"linkInclusionRules":574},[24],"## Notas\n\nEstas son mis notas sobre el libro \"Introduction to higher order categorical logic\" de \nLambek y Scott","src/content/docs/logica-categorica/index.mdx","d7bda9171f5286cc","logica-categorica/categorias/natural",{"id":578,"data":580,"body":587,"filePath":588,"digest":589,"deferredRender":16},{"title":581,"editUrl":16,"head":582,"template":18,"sidebar":583,"pagefind":16,"draft":20,"sitemap":585},"Transformaciones naturales",[],{"order":104,"hidden":20,"attrs":584},{},{"linkInclusionRules":586},[24],"import { Aside } from '@astrojs/starlight/components';\n\n\u003Cdiv id=\"definicion-2-1\">\n\u003CAside type=\"tip\" title=\"Defincin 2.1\">\nDados dos functores $F, G : cal(A) arrow cal(B)$, una *transformacin natural* \n$t : F arrow G$ es una familia de flechas $t(A): F(A) arrow G(A)$ en $cal(B)$, una flecha \npara cada objeto $A$ de $cal(A)$, tal que el siguiente cuadrado conmuta para cada \nflecha $f : A arrow B$ en $cal(A)$:\n\n```typst \n#commutative-diagram(\n  node((0, 0), $F(A)$),\n  node((0, 1), $G(A)$),\n  node((1, 0), $F(B)$),\n  node((1, 1), $G(B)$),\n  arr($F(A)$, $G(A)$, $t(A)$),\n  arr($F(B)$, $G(B)$, $t(B)$),\n  arr($F(A)$, $F(B)$, $F(f)$),\n  arr($G(A)$, $G(B)$, $G(f)$)\n)\n```\nes decir, tal que \n\n$ G(f) compose t(A) = t(B) compose F(f). $\n\n\u003C/Aside>\n\u003C/div>\n\nDadas dos categoras $cal(A)$ y $cal(B)$, la *categora de functores* $cal(B)^(cal(A))$\ntiene functores $F : cal(A) arrow cal(B)$ como objetos y transformaciones naturales como \nflechas. \n\n\u003Cdiv id=\"proposicion-2-3\">\n\u003CAside type=\"tip\" title=\"Proposicin 2.3\">\nPara cualesquiera categoras $cal(A), cal(B)$ y $cal(C)$,\n$ \n    cal(A)^1 tilde.equiv cal(A), quad\n    cal(C)^(cal(A) times cal(B)) tilde.equiv (cal(C)^(cal(B)))^(cal(A)), quad\n    (cal(A) times cal(B))^(cal(C)) tilde.equiv cal(A)^(cal(C)) times cal(B)^(cal(C))\n$\n\u003C/Aside>\n\u003C/div>\n\nSi $cal(A)$ es una categora localmente pequea, entonces hay un functor \n$\"Hom\"_(cal(A)): cal(A)^(\"op\") times cal(A) arrow \"Sets\"$. Para un objeto $(A, B)$ de \n$cal(A)^(\"op\") times cal(A)$, el valor de este functor es $\"Hom\"_(cal(A)) (A, B)$ como \nsugiere la notacin. Para una flecha $(g, h): (A, B) arrow (A', B')$ de \n$cal(A)^(\"op\") times cal(A)$, donde $g: A' arrow A$ y $h: B arrow B'$ en $cal(A)$,\n$\"Hom\"_(cal(A)) (g, h)$ manda $f in \"Hom\"_(cal(A)) (A, B)$ a \n$h compose f compose g in \"Hom\"_(cal(A)) (A', B')$.","src/content/docs/logica-categorica/Categorias/natural.mdx","846102ad84356370","categorias/lcc",{"id":590,"data":592,"body":599,"filePath":600,"digest":601,"deferredRender":16},{"title":593,"editUrl":16,"head":594,"template":18,"sidebar":595,"pagefind":16,"draft":20,"sitemap":597},"Categoras localmente cartesianas cerradas y teora de tipos",[],{"order":104,"hidden":20,"attrs":596},{},{"linkInclusionRules":598},[24],"## Notas\nEstas son mis notas sobre el artculo \"Locally cartesian closed categories and type theory\"\nde R.A.G Seely.","src/content/docs/categorias/LCC/index.mdx","7cbe6a4ac3862bd6","categorias/lcc/ml",{"id":602,"data":604,"body":611,"filePath":612,"digest":613,"deferredRender":16},{"title":605,"editUrl":16,"head":606,"template":18,"sidebar":607,"pagefind":16,"draft":20,"sitemap":609},"La teora de tipos",[],{"order":130,"hidden":20,"attrs":608},{},{"linkInclusionRules":610},[24],"import { Aside } from '@astrojs/starlight/components';\n\nUn sistema ML (Martin Lf) permite la construccin de trminos, tipo y expresiones de la \nforma $t : T$ ($t$ es un trmino de tipo $T$), $s=t$, cuando se han derivado $s, t : T$ y \n$S = T$. Identificamos las expresiones que difieren solamente en un renombramiento de las \nvariables ligadas. Si escribimos $e[x]$, entonces $x$ denota todas las ocurrencias libres \nde $x$ en la expresin $e$ y $e[a]$ es el resultado de remplazar estas ocurrencias por \n$a$, bajo el supuesto de que $a$ puede ser sustituida en $e$. \nSi $x_1, dots, x_n$ es una sucesin de variables, decimos que $x_1, dots, x_n, e$\nsatisfacen la *condicin sobre las variables* (c.s.v) si para cada $i lt.eq n$, $x_i$\nno ocurre en el tipo de ninguna de las variables de $e$ ms que en $x_k$ con $k gt i$.\nSi $x_1, dots, x_n$ contiene todas las variables que ocurren en $e$, decimos que las \nvariables estn propiamente listadas en $e[x_1, dots, x_n]$ si $x_1, dots, x_n, e$ \nsatisface la c.s.v. Donde \"ocurren\" tiene el siguiente sentido:\n\nSi $x : X$ ocurre en $e$, entonces cualquier variable que ocurre en $X$ tambin ocurre en \n$e$. Podemos escribir\n\n$ x_1 : X_1, x_2 : X_2[x_1], dots, x_n : X_n [x_1, dots, x_(n-1)], $\n\nsi las variables estn propiamente enlistadas en $e[x_1, dots, x_n]$.\n\n\u003Cdiv id=\"definicion-1-1\">\n\u003CAside type=\"tip\" title=\"Definicin 1.1\">\nUna teora ML est dada por un lenguaje que incluye un conjunto de constantes de \nfunciones tipo-valuadas tipadas, un conjunto de constantes de funciones trmino-valuadas \ntipadas y variables y constantes que siguen las siguientes reglas (por \n\"constantes de funciones tipadas\" queremos decir que los argumentos tienen tipos \nespecificados y en el caso de las constantes de funciones trmino-valuadas, el valor tiene\nun tipo especificado. Asumiremos que los argumentos estn propiamente enlistados).\n\n1. *Reglas de formacin de tipos*. Los siguientes son tipos:\n  1. Si $F$ es una constante de funcin tipo-valuada y $a_1, dots, a_n$ son trminos de los \n  tipos apropiados, entonces $F(a_1, dots, a_n)$ es un tipo.\n  2. $1$ es un tipo.\n  3. Si $a, b : A$ entonces $I(a,b)$ es un tipo (tambin denotado $a attach(=, br: A) b$).\n  4. Si $A, B[x]$ son tipos, $x: A$, donde $x, B$ satisface la c.s.v, entonces \n  $Pi_((x : A)) B[x]$ y $Sigma_((x : A)) B[x]$ son tipos. Si $x$ no ocurre en $B$, estos \n  tipos se escriben como $A arrow B$ y $A times B$ respectivamente.\n\n2. *Reglas de formacin de trminos* Los siguientes son trminos de los tipos indicados:\n  1. *vbl*. Para cada tipo $A$, hay variables $x : A$, una $x$ as se puede denotar como \n  $x_A$ si el tipo de $x$ no es claro a partir del contexto.\n  2. *fcn*. Si $f$ es una constante de funcin trmino-valuada y $a_1, dots, a_n$ son \n  trminos de los tipos apropiados, entonces $f(a_1, dots, a_n)$ es un trmino del tipo \n  apropiado. \n  3. *$1$I*. $star : 1$.\n  4. *$Pi$I*. Si $t[x] : B[x]$, donde $x_A, t$ (y $x_A, B$) satisfacen la c.s.v, entonces \n  $ lambda (x : A). t[x] : Pi_((x : A)) B[x] $.\n  5. *$Pi$E*. Si $f : Pi_((x : A)) B[x]$ y $a : A$, entonces $f(a) : B[a]$.\n  6. *$Sigma$I*. Si $a : A$ y $b : B[a]$, entonces $(a, b) : Sigma_((x : A)) B[x]$.\n  7. *$Sigma$E*. Si $c : Sigma_((x : A)) B[x]$, entonces $pi(c) : A$ y $pi'(c) : B[pi(c)]$.\n  8. *$=$I*. Si $a : A$, entonces $r(a) : I(a, a)$.\n  9. *$=$E*. Si $a, b : A$, $c : I(a, b)$, $d : C[a, a, r(a)]$, donde $C[x, y, z]$ es un \n  tipo dependiente de $x, y : A$ y $z : I(x, y)$, entonces $sigma(d)[a, b, c] : C[a, b, c]$.\n\n3. *Reglas de igualdad* Tenemos las siguientes ecuaciones:\n  1. *feq*. Cualesquiera ecuaciones impuestas sobre constantes de funciones inducen las \n  ecuaciones obvias.\n  2. *$1$ red*. Si $t : 1$, entonces $t = star$.\n  3. *$Pi$ red*. $(lambda (x : A). t[x])(a) = t[a]$.\n  4. *$Pi$ exp*. $f = lambda (x : A) f(x)$.\n  5. *$Sigma$ red*. $pi((a, b)) = a$, $pi'((a, b)) = b$.\n  6. *$Sigma$ exp*. $c = (pi(c), pi'(c))$.\n  7. *$=$ red*. $sigma(d)[a, a, r(a)] = d$.\n  8. *$=$ exp*. Si $f[a, b, c] : C[a, b, c]$, entonces $f = sigma(f[a, a, r(a)])[a, b, c]$.\n  9. *$I$ regla*. Si $a[x], b[x] : A$, $t[x]: I(a[x], b[x])$, entonces $a[x] = b[x]$ y \n  $t[x] = r(a[x])$.\n\nEn una teora ML, podemos tener axiomas de la forma $S = T$ para tipos $S$ y $T$. Suponemos\nque los axiomas similares para los trminos se dan mediante constantes de funciones del \n$I$-tipo apropiado.\n\nFinalmente, tenemos las reglas usuales para $=$: para tipos o trminos $a, b, c$:\n1. Si $a = b$ entonces $c[a] = c[b]$. Si $a = b$ entonces $b = a$.\n2. Si $a = b$ y $b = c$ entonces $a = c$. $a = a$.\n3. Si $c : a$ y $a = b$, entonces $c : b$. Si $a : c$ y $a = b$ entonces $b : c$.\n\n\u003C/Aside>\n\u003C/div>","src/content/docs/categorias/LCC/ml.mdx","6787f7e33281f239","categorias/lcc/cat",{"id":614,"data":616,"body":623,"filePath":624,"digest":625,"deferredRender":16},{"title":617,"editUrl":16,"head":618,"template":18,"sidebar":619,"pagefind":16,"draft":20,"sitemap":621},"Categoras",[],{"order":65,"hidden":20,"attrs":620},{},{"linkInclusionRules":622},[24],"import { Aside } from '@astrojs/starlight/components';\n\n\u003Cdiv id=\"definicion-2-1\">\n\u003CAside type=\"tip\" title=\"Definicin 2.1\">\nUna categora localmente cartesiana cerrada (LCC) $bold(C)$ es una categora $bold(C)$ \ncon lmites finitos, de tal forma que para cualquier objeto $A$ de $bold(C)$, la \ncategora de rebanada $C \\\\/ A$ es cartesiana cerrada (tiene productos finitos y \nexponenciales).\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"defincion-2-2\">\n\u003CAside type=\"tip\" title=\"Defincin 2.2\">\nPara una categora $bold(C)$ con lmites finitos, una categora $bold(C)$-indizada $bold(P)$\nconsiste de:\n\n  1. Para cada objeto $A$ de $bold(C)$ una categora $bold(P)(A)$,\n  2. Para cada morfismo $f : A arrow B$ de $bold(C)$ un functor \n  $f^star : bold(P)(B) arrow bold(P)(A)$ sujeto a: \n    1. $(\"id\"_A)^star tilde.equiv \"id\"_(bold(P)(A))$.\n    2. $(g compose f)^star tilde.equiv f^star compose g^star$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"definicion-2-3\">\n\u003CAside type=\"tip\" title=\"Defincin 2.3\">\nUna categora $bold(C)$-indizada $bold(P)$ es una *hiper-doctrina* si \n  1. Para cada objeto $A$ de $bold(C)$, $bold(P)(A)$ es cartesiana cerrada,\n  2. Para cada $f : A arrow B$ de $bold(C)$, $f^star$ preserva exponentes,\n  3. Para cada $f : A arrow B$ de $bold(C)$, $f^star$ tiene adjuntos \n  $Sigma_f tack.l f^star tack.l Pi_f$,\n  4. $bold(P)$ satisface la condicin de Beck: si \n  ```typst \n    #commutative-diagram(\n      node((0, 0), $D$),\n      node((0, 1), $C$),\n      node((1, 0), $A$),\n      node((1, 1), $B$),\n      arr($D$, $C$, $h$),\n      arr($A$, $B$, $f$),\n      arr($D$, $A$, $k$),\n      arr($C$, $B$, $g$)\n    ) \n  ```\n  es un pullback en $bold(C)$, entonces para cada objeto $phi$ de $bold(P)(C)$, \n  $Sigma_k h^star phi arrow f^star Sigma_g phi$ es un isomorfismo en $bold(P)(A)$.\n\u003C/Aside>\n\u003C/div>\n\nToda categora $bold(C)$ con lmites finitos induce un categora $bold(C)$-indizada (que \ntambin denotamos $bold(C)$) dada por $bold(C)(A) = bold(C)\\\\/A$, $f^star$ se define como \nel pullback. \n\n\u003Cdiv id=\"teorema-2-4\">\n\u003CAside type=\"tip\" title=\"Teorema 2.4\">\nSi $bold(C)$ tiene lmites finitos, entonces $bold(C)$ es LCC si y slo si, como categora \n$bold(C)$-indizada, $bold(C)$ es una hiper-doctrina.\n\u003C/Aside>\n\u003C/div>\n\nEl punto es que para cada $A$, $bold(C)\\\\/ A$ es cartesiana cerrada si y slo si para cada \n$f$, $f^star$ tiene un adjunto derecho $Pi_f$. Para cada $bold(C)$ con lmites finitos,\ncada $f^star$ de $bold(C)$ tiene un adjunto izquierdo $Sigma_f$ \n(definido por la composicin) y la condicin de Beck para $bold(C)$ se cumple \n(dice que la composicin de dos diagramas de pullback es un diagrama de pullback).\n\n\u003Cdiv id=\"defincicion-2-5\">\n\u003CAside type=\"tip\" title=\"Defincin 2.5\">\nDos categoras $bold(C)$-indizadas $bold(P)_1$ y $bold(P)$_2 son equivalentes, \n$bold(P)_1 tilde.eq bold(P)_2$ si para cada $A$, hay una equivalencia \n$bold(P)_1(A) tilde.eq bold(P)_2(A)$ y estas equivalencias conmutan con las $f^star$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"observacion-2-6\">\n\u003CAside type=\"note\" title=\"Observacin 2.6\">\nSi $bold(P)_1 tilde.eq bold(P)_2$ como categoras $bold(C)$-indizadas y si $bold(P)_1$ es \nuna hiper-doctrina, entonces $bold(P)_2$ tambin lo es y, an ms, las equivalencias \n$bold(P)_1 (A) tilde.eq bold(P)_2 (A)$ conmutan con las $Sigma_f$ y $Pi_f$.\n\u003C/Aside>\n\u003C/div>","src/content/docs/categorias/LCC/cat.mdx","442b9a1ba332725f","categorias/lcc/ml-lcc",{"id":626,"data":628,"body":635,"filePath":636,"digest":637,"deferredRender":16},{"title":629,"editUrl":16,"head":630,"template":18,"sidebar":631,"pagefind":16,"draft":20,"sitemap":633},"De MLL a LCC",[],{"order":78,"hidden":20,"attrs":632},{},{"linkInclusionRules":634},[24],"import { Aside } from '@astrojs/starlight/components';\n\nDada una teora ML $bold(M)$, definimos una categora $C(bold(M))$ cuyos objetos son todos \nlos tipos cerrados de $bold(M)$ (tipos que no dependen de variables libres) y los \nmorfismos $A arrow B$ son los trminos cerrados de tipo $A arrow B$ (De modo que \n$f : A arrow B$ en $C(bold(M)$ significa que $f : A arrow B$ en $bold(M)$).\n\n\u003Cdiv id=\"proposicion-3-1\">\n\u003CAside type=\"tip\" title=\"Proposicin 3.1\">\n$C(bold(M))$ es cartesiana cerrada.\n\n*Demostracin* Podemos verificar que $C(bold(M))$ es cartesiana cerrada con lmites finitos \nde forma directa. \n\n**Axiomas de categoras**: \n\nPara un objeto $A$, $id_A : A arrow A$ es $lambda (x : A).x$.\nDada $f : A arrow B$, $g : B arrow C$, $g compose f : A arrow C$ es \n$lambda (x : A). g(f(x))$.\n\n```typst \n$\nf compose id_A & = f compose (lambda (x : A). x) = lambda (y: A). f((lambda (x: A).x)(y))\\\n               & = lambda (y : A). f(y)\\\n               & = f\n$\n```\nDe manera similar, $id_B compose f = f$, $h compose (g compose f) = (h compose g) compose f.\n\n**Productos** \n\n$1$ es el objeto terminal de $C(bold(M))$. Dado un objeto $A$, hay un morfismo $A arrow 1$,\n$lambda (x : A). star$.\n\n\u003Cdiv id=\"lema\">\n\u003CAside type=\"note\" title=\"Lema\">\nPara cualquier tipo cerrado $A$, si $t$ es un trmino cerrado de tipo $A arrow 1$, entonces \n$t = lambda (x : A). star$.\n\n*Demostracin*\n```typst \n$\nt &= lambda (x : A). t(x) \\\n  &= lambda (x : A). star\n$\n```\n\u003C/Aside>\n\u003C/div>\n\nPara objetos $A$ y $B$, $A times B$ (en $C(bold(M))$) est dado por $A times B$ \n(en $bold(M)$), el emparejamiento $(,)$ y las proyecciones $pi, pi'$ estn dadas por \n\"s mismas\". Las ecuaciones requeridas se siguen fcilmente de ($Sigma$ red) y \n($Sigma$ exp).\n\n**Pullbacks** \n\nDadas $t : A arrow B$ y $s : C arrow B$, el pullback $P$ de $s$ a lo largo \nde $t$ \n\n```typst \n#commutative-diagram(\n  node((0, 0), $P$),\n  node((0, 1), $A$),\n  node((1, 0), $C$),\n  node((1, 1), $B$),\n  arr($P$, $A$, $p$),\n  arr($P$, $C$, $q$),\n  arr($C$, $B$, $s$),\n  arr($A$, $B$, $t$)\n)\n```\nest dado por $Sigma_((x : A)) Sigma_((y : C)) I(t(x), s(x))$ (o, lo que es lo mismo, \n$Sigma_((x : A)) Sigma_((y : C)) t(x) attach(=, br: B) s(y)$), con las proyecciones \nevidentes a $A$ y $C$: $p$ es $pi$ y $q$ es $pi compose pi'$.\n\nVeamos que esto es cierto. Sean $f : X arrow A$ y $g : X arrow C$ tales que \n$t compose f = s compose g$, notemos que hay un trmino \n\n$ rho(x) : t(f(x)) attach(=, br: B) s(g(x)) $\n\na saber, $r(t(f(x)))$. Definamos $h : X arrow P$ por \n$lambda (x : X). (f(x), (g(x), rho(x)))$. Claramente $p compose h = f$ y $q compose h = g$ \ny, usando la ($I$ regla) para ver que $rho(x)$ es el nico trmino posible de tipo \n$t(f(x)) attach(=, br: B) s(g(x))$, $h$ es nica con esta propiedad.\n\n\n**Equalizadores**\n\nDados $s, t : A arrow B$, el equalizador de $s$ y $t$ est dado por \n$Sigma_((x : A)) s(x) attach(=, br: B) t(x)$, la inclusin est dada por la proyeccin \n(que sea un monomorfismo se sigue de la $I$ regla).\n\n**Exponentes**\n\n$B^A$ definido como $A arrow B$ hace a $C(bold(M))$ cartesiana cerrada.\n\nDada $t : A times C arrow B$, definimos \n$hat(t) = lambda (y : C). lambda (x : A). t((x, y)) : C arrow B^A$. Dada \n$s : C arrow B^A$, definimos \n$tilde(s) = lambda (s: A times B) s(pi'(z)) (pi(z)) : A times C arrow B$. \nEstas operaciones son inversas la una de la otra. Notemos que esta es la correspondencia\nusual, por ejemplo: $\"ev\": A times B ^A arrow B$ es simplemente \n$lambda (z : A times B^A) pi'(z) (pi(z))$, de modo que $\"ev\"((a, f)) = f(a)$.\n\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"teorema-3-2\">\n\u003CAside type=\"tip\" title=\"Teorema 3.2\">\n$C(bold(M))$ es localmente cartesiana cerrada.\n\n*Demostracin* Para ver que $C(bold(M))$ es localmente cartesiana cerrada, debemos \nverificar que las categoras de rebanada $C(bold(M))\\\\/A$ son cartesianas cerradas o, \nde forma equivalente, que $C(bold(M))$ es una hiper-doctrina. \n\n\u003Cdiv id=\"definicion-3-2-1\">\n\u003CAside type=\"note\" title=\"Definicin 3.2.1\">\n$P(bold(M))$ es la categora $C(bold(M))$-indizada definida por:\n\n1. Para un objeto $A$ de $C(bold(M))$, $P(bold(M))(A)$ es la categora cuyos objetos son \n   tipos $B[x]$ que slo dependen de $x : A$ y cuyos morfismos son trminos \n   $t[x] : B[x] arrow C[x]$ que slo dependen de $x : A$.\n\n2. Para un trmino $f : B arrow A$ (es decir, un morfismo $f : B arrow A$ en $C(bold(M))$),\n   $f^star$ se define por substitucin: $e[x] mapsto e[f(y)]$, $y : B$ para una expresin \n   $e$.\n\u003C/Aside>\n\u003C/div>\n\n\u003Cdiv id=\"lema-3-2-2\">\n\u003CAside type=\"note\" title=\"Lema 3.2.2\">\nPara cualquier tipo cerrado $A$, $P(bold(M))(A)$ es cartesiana cerrada.\n\n*Demostracin* La demostracin de este hecho es exactamente la prueba de que $C(bold(M))$\nes cartesiana cerrada. Slo hay que saber que los objetos son trminos cerrados y basta \nrepetir los argumentos con un parmetro $x : A$.\n\u003C/Aside>\n\u003C/div>\n\n\n\n\u003C/Aside>\n\u003C/div>","src/content/docs/categorias/LCC/ml-lcc.mdx","446f4c575f41161b","tipos/lambek",{"id":638,"data":640,"body":575,"filePath":647,"digest":648,"deferredRender":16},{"title":641,"editUrl":16,"head":642,"template":18,"sidebar":643,"pagefind":16,"draft":20,"sitemap":645},"Introduccin a la lgica categrica de orden alto",[],{"order":104,"hidden":20,"attrs":644},{},{"linkInclusionRules":646},[24],"src/content/docs/tipos/Lambek/index.mdx","36433bd10cf4a695","tipos/lambek/cccs/calculo-proposicional",{"id":649,"data":651,"body":658,"filePath":659,"digest":660,"deferredRender":16},{"title":652,"editUrl":16,"head":653,"template":18,"sidebar":654,"pagefind":16,"draft":20,"sitemap":656},"Clculo proposicional como sistema deductivo",[],{"order":104,"hidden":20,"attrs":655},{},{"linkInclusionRules":657},[24],"Recordemos que para los categricos, una *grfica* consiste de dos clases y mapas entre \nellos. Las flechas y los nodos. En lugar de escribir \n\n$ \"source\"(f) = A quad \"y\" quad \"target\"(f) $\n\nuno suele escribir $f : A arrow B$ para una flecha entre $A$ y $B$. Investigaremos a las \ngrficas con cierta estructura adicional que son de inters para la lgica.\n\nUn *sistema deductivo* es una grfica con una flecha especificada\n\n- R1a. $1_A : A arrow A$\n\ny una operacin binaria sobre flechas (composicin)\n\n$ g compose f : A arrow C $\n\ndonde $f : A arrow B$ y $g : B arrow C$.\n\nLos lgicos piensan a los objetos de un sistema deductivo como *frmulas*, las flechas como \n*pruebas* (o *deducciones*) y una operacin sobre flechas como una *regla de inferencia*.\n\nUn sistema deductivo no se preocupa meramente de las deducciones lgicas sin nombre como \n$A arrow B$, sino que importan las demostraciones de dichas deducciones. Al escribir \n$f : A arrow B$ pensamos a $f$ como la razn por la cual se puede deducir $B$ a partir de \n$A$.\n\nUn *clculo conjuntivo* es un sistema deductivo que trata sobre la verdad y conjuncin.\nAs, asumimos que nos es dada una frmula $top$ (verdadero) y una operacin binaria \n$and$ (conjuncin) para formar la conjuncin $A and B$ de dos frmulas dadas \n$A$ y $B$. Ms an, especificamos las siguientes flechas y reglas de inferencia:\n\n- R2. $circle_A : A arrow top$,\n- R3a. $pi_(A, B) : A and B arrow A$,\n- R3b. $pi'_(A, B) : A and B arrow B$,\n- R3c. Si $f : C arrow A$ y $g : C arrow B$, entonces $angle.l f, g angle.r arrow A and B$.\n\nAqu hay una prueba de la llamada regla de conmutatividad para la conjuncin\n\n```typst \n#prooftree(\n  rule(\n    $angle.l pi'_(A, B), pi_(A, B) angle.r : A and B arrow B and A$,\n    $pi'_(A, B) : A and B arrow B$,\n    $pi_(A, B): A and B arrow A$\n  )\n)\n```\n\nLa presentacin de esta prueba est dada en forma de rbol, aunque es instructiva, es \nsuperflua. Es suficiente denotarla por $angle.l pi'_(A, B), pi_(A, B) angle.r$ o \n$angle.l pi', pi angle.r$ cuando se sobrentienden los subndices.\n\nOtro ejemplo es la prueba de la ley asociativa \n$alpha_(A, B, C): (A and B) and C arrow A and (B and C)$, la cual est dada por:\n\n$ alpha_(A, B, C) equiv angle.l pi_(A, B) pi_(A and B, C), angle.l pi'_(A, B) pi_(A and B, C), pi'_(A and B, C) angle.r  angle.r $ \n\no simplemente, $alpha equiv angle.l pi pi, angle.l pi' pi, pi' angle.r angle.r$\n\nSi componemos operaciones sobre pruebas, podemos obtener reglas de inferencia \"derivadas\".\nPor ejemplo, consideremos la siguiente regla derivada:\n\n```typst \n#prooftree(\n  rule(\n    $f and g : A and C arrow B and D$,\n    prooftree(\n      rule(\n        $A and C arrow B$,\n        $pi_(A, C) : A and C arrow A$,\n        $f : A arrow B$\n      )\n    ),\n    prooftree(\n      rule(\n        $A and C arrow D$,\n        $pi'_(A, C) : A and C arrow C$,\n        $g : C arrow D$\n      ) \n    )\n  )\n)\n```\n\nLa cual asegura que de pruebas de $f$ y $g$ se puede construir la prueba \n\n$ f and g = angle.l f pi_(A, C), g pi'_(A, C) angle.r $\n\nAs, podemos simplemente escribir \n\n```typst \n#prooftree(\n  rule(\n    $f and g : A and C arrow B and D$,\n    $f : A arrow B$,\n    $g : C arrow D$\n  )\n)\n```\nUn *clculo proposicional intuicionsita positivo* es un clculo conjuntivo con una \noperacin binaria $arrow.double$ (si ... entonces ...). As, si $A$ y $B$ son frmulas,\ntambin lo son $top, A and B$ y $B arrow.double A$. Tambin especificamos una nueva \nflecha y regla de inferencia \n\n- R4a. $epsilon_(A, B) : (B arrow.double A) and B arrow A$,\n- R4b. \n  ```typst \n  #prooftree(\n    rule(\n      $h^star : C arrow B arrow.double A$,\n      $h : C and B arrow A$\n    )\n  )\n  ```\nNotemos que de R4b., con la ayuda de R4a., podemos derivar \n\n- R'4b. $eta_(C, B) : C arrow B arrow.double (C and B)$\n- R'4c. \n  ```typst \n  #prooftree(\n    rule(\n      $1_B arrow.double g  : B arrow.double D arrow B arrow.double A$,\n      $g : D arrow A$\n    )\n  )\n  ```\nPara derivar estas, hacemos \n$ eta_(C, B) equiv (1_(C and B))^star, 1_B arrow.double g equiv (g epsilon_(D, B))^star. $\n\nUn clculo proposicional intuicionista es ms que slo el positivo, tambin requiere de \nla falsedad y la disyuncin, es decir, una frmula $bot$ (falso) y una operacin binaria \n$or$ (disyuncin), con las siguientes flechas:\n\n- R5. $ square_A : bot arrow A $\n- R6a. $kappa_(A, B) : A arrow A or B$\n- R6b. $kappa'_(A, B) : B arrow A or B$\n- R6c. $zeta^(C)_(A, B) : (A arrow.double C) and (B arrow.double C) arrow (A or B) arrow.double C $\n\nLa ltima flecha que mencionamos da lugar y se puede derivar a partir de la regla \n\n- R'6c. \n  ```typst \n  #prooftree(\n    rule(\n      $[f, g] : A or B arrow C$,\n      $f : A arrow C$,\n      $g: B arrow C$\n    )\n  )\n  ```\n\nSi queremos el clculo proposicional *clsico*, necesitamos tambin  \n\n$ (A arrow.double bot) arrow.double bot arrow A $","src/content/docs/tipos/Lambek/CCCs/calculo-proposicional.mdx","5ebe4a2066a2ae5f","tipos/lambek/cccs/cccs",{"id":661,"data":663,"body":670,"filePath":671,"digest":672,"deferredRender":16},{"title":664,"editUrl":16,"head":665,"template":18,"sidebar":666,"pagefind":16,"draft":20,"sitemap":668},"Categoras cartesianas cerradas",[],{"order":130,"hidden":20,"attrs":667},{},{"linkInclusionRules":669},[24],"Una *categora* es un sistema deductivo en el que las siguientes ecuaciones entre pruebas\nse mantienen:\n\n- E1. $f 1_A = f, 1_B f = f, (h g) f = h (g f)$\n  para cada $f : A arrow B$, $g: B arrow C$ y $h : C arrow D$.\n\nAs, a partir de cualquier sistema deductivo, se pude obtener una categora imponiendo \ncierta relacin de equivalencia entre las pruebas.\n\nUna *categora cartesiana* es tanto una categora como un clculo conjuntivo que \nsatisface las siguientes ecuaciones adicionales:\n\n- E2. $f = circle_A$, para cada $f : A arrow top$\n- E3a. $pi_(A, B) angle.l f, g angle.r = f$\n- E3b. $pi'_(A, B) angle.l f, g angle.r = g$\n- E3c. $angle.l pi_(A, B) h, pi'_(A, B) h angle.r = h$\n\npara cada $f : C arrow A$, $g : C arrow B$ y $h : C arrow A and B$.\n\nE2 asegura que $top$ es un objeto terminal. Usualmente escribimos $top = 1$. \nE3 asegura que $A and B$ es un producto de $A$ y $B$ con proyecciones $pi_(A, B)$ y \n$pi'_(A, B)$, usaremos la notacin $A and B equiv A times B$.\n\nComo consecuencia de E3, veamos que se cumple la *ley distributiva*:\n\n$ angle.l f, g angle.r h = angle.l f h, g h angle.r $\n\npara cada $f : C arrow A, g : C arrow B$ y $h : D arrow C$.\n\nNotemos que \n\n```typst \n$\nangle.l f, g angle.r h & = angle.l pi (angle.l f, g angle.r h), pi' (angle.l f, g angle.r h) angle.r \\\n & = angle.l (pi angle.l f, g angle.r) h, (pi' angle.l f, g angle.r) h angle.r \\\n & = angle.l f h, g h angle.r.\n$\n```\n\nTambin escribiremos $f times g = f and g = angle.l f pi_(A, C), g pi'_(A, C) angle.r$\n cuando $f : A arrow B$ y $g : C arrow D$ y observemos que \n$times : cal(A) times cal(A) arrow cal(A)$ es un functor. En efecto:\n\n```typst \n$\n  1_A times 1_C & = angle.l 1_A pi_(A, C), 1_C pi'_(A, C) angle.r \\\n  & = angle.l pi_(A, C), pi'_(A, C) angle.r \\\n  & = angle.l pi_(A, C) 1_(A times C), pi'_(A, C) 1_(A times C) angle.r \\\n  & = 1_(A times C)\n$\n```\nY, por la ley distributiva, omitiendo subndices:\n\n```typst \n$\n(f times g) (f' times g') & = angle.l f pi, g pi' angle.r angle.l f' pi, g' pi' angle.r \\\n& = angle.l f pi angle.l f' pi, g' pi' angle.r, g pi' angle.l f' pi, g' pi' angle.r angle.r\\\n& = angle.l f f' pi, g g' pi' angle.r \\\n& = f f' times g g'\n$\n```\nUna *categora cartesiana cerrada* es una categora cartesiana $cal(A)$ con la estrcutura\nadicional R4 que satisface las siguientes ecuaciones:\n\n- E4a. $epsilon_(A, B) angle.l h^star pi_(C, B), pi'_(C, B) angle.r = h$\n- E4b. $(epsilon_(A, B) angle.l k pi_(C, B), pi'_(C, B) angle.r)^star = k$\n\npara cada $h : C and B arrow A$ y $k : C arrow (B arrow.double A)$\n\nAs, una categora cartesiana cerrada es un clculo proposicional intuicionista positivo \nque satisface las ecuaciones E1-E4. As como escribimos $C and B equiv C times B$, tambin \nescribimos $B arrow.double A equiv A^B$. Las ecuaciones E4 aseguran que el mapeo\n\n$ \"Hom\"(C times B, A) arrow^star \"Hom\" (C, A^B) $\n\nes una correspondencia uno-a-uno. De hecho, se tiene la siguiente propiedad universal para \nla flecha $epsilon_(A, B) : A^B times B arrow A$:\n\nDada una flecha $h : C times B arrow A$ hay una nica flecha $h^star : C arrow A^B$ tal que \n$ epsilon_(A, B) (h^star times 1_B) = h. $\n\nSi recordamos la nocin de adjuncin, nos daremos que $U_B = (-)^B: cal(A) arrow cal(A)$\nes adjunto derecho al functor $F_B = (-) times B : cal(A) arrow cal(A)$. Con \ncoadjuncin $epsilon_B : F_B U_B arrow 1_cal(A)$ definida por \n$epsilon_B (A) = epsilon_(A, B)$.","src/content/docs/tipos/Lambek/CCCs/cccs.mdx","74850c90443f8143","tipos/lambek/cccs/cccs-graficas",{"id":673,"data":675,"body":682,"filePath":683,"digest":684,"deferredRender":16},{"title":676,"editUrl":16,"head":677,"template":18,"sidebar":678,"pagefind":16,"draft":20,"sitemap":680},"Categorias cartesianas cerradas libres generadas por grficas",[],{"order":65,"hidden":20,"attrs":679},{},{"linkInclusionRules":681},[24],"Dada una grfica $cal(H)$, podemos construir el clculo intuicionista positivo \n$cal(D)(cal(H))$ y la categora cartesiana cerrada $cal(F)(cal(H))$ *libremente generada*\npor $cal(H)$.\n\nInformalmente, $cal(D)(cal(H))$ es el clculo intuicionista positivo ms pequeo cuyas \nfrmulas incluyen los vrtices de $cal(H)$ y cuyas pruebas incluyen las flechas de \n$cal(H)$. Ms precisamente, las frmulas y pruebas de $cal(D)(cal(H))$ se definen \ninductivamente como sigue: todos los vrtices de $cal(H)$ son frmulas, $top (equiv 1)$ \nes una frmula, si $A$ y $B$ son frmulas, tambin lo son $A and B (equiv A times B)$ y \n$A arrow.double B (equiv B^A)$. Las flechas de $cal(H)$ y las flechas $1_A$, $circle_A$,\n$pi_(A, B)$, $pi'_(A, B)$ y $epsilon_(A, B)$ son pruebas, para cada par de frmulas $A$\ny $B$ y las pruebas son cerradas bajo las reglas de inferencia (composicin), \n$angle.l -, - angle.r$ y $(-)^star$.\n\nConstruimos a $cal(F)(cal(H))$ a partir de $cal(D)(cal(H))$ imponiendo todas las ecuaciones\nsobre las pruebas que se deben cumplir en una categora cartesiana cerrada. Otra forma de \ndecir esto es que tomamos la relacin de equivalencia ms pequea entre pruebas que \nsatisface las leyes de substitucin apropiadas y respeta las ecuaciones de una categora \ncartesiana cerrada. Las clases de equivalencia entre pruebas son entonces las flechas de \n$cal(F)(cal(H))$.\n\nSea $bold(\"Grph\")$ la categora de grficas, cuyos objetos son las grficas y los morfismos\n$F: cal(H) arrow cal(Y)$ son pares de mapeos $F: \"Objetos\"(cal(H)) arrow \"Objetos\"(cal(Y))$\ny $F: \"Flechas\"(cal(H)) arrow \"Flechas\"(cal(Y))$ de tal manera que $f : X arrow X'$ implica\n$F(f) : F(X) arrow F(X')$.\n\nSea $bold(\"Cart\")$ la categora de categoras cartesianas cerradas cuyos objetos son \ncategoras cartesianas cerradas y cuyas flechas son functores $F : cal(A) arrow cal(B)$\nque preservan la estructura cartesiana cerrada, es decir\n\n- $F(1) = 1$, $F(A times B) = F(A) times F(B)$\n- $F(A^B) = F(A)^F(B)$\n- $F(circle_A) = circle_(F(A))$, $F(pi_(A, B)) = pi_(F(A), F(B))$, etc.\n- $F(angle.l f, g angle.r) = angle.l F(f), F(g) angle.r$, etc \n\nSea $cal(U) : bold(\"Cart\") arrow bold(\"Grph\")$ el functor olvidadizo. A cualquier grfica \n$cal(H)$ le asociamos un morfismo de grficas \n$H_(cal(H)) : cal(H) arrow cal(U)(cal(F)(cal(H)))$ como sigue: $H_(cal(H))(X) = X$ y, si \n$f : X arrow Y$ en $cal(H)$, entonces $H_(cal(H))(f) = f$ (la clase de equivalencia de $f$).\nEntonces tenemos la siguiente propiedad universal:\n\nDada una categora cartesiana cerrada $cal(A)$ y cualquier morfismo \n$F : cal(H) arrow cal(U)(cal(A))$ de grficas, hay una flecha nica \n$F': cal(F)(cal(H)) arrow cal(A)$ en $bold(\"Cart\")$ tal que $cal(U)(F')H_(cal(H)) = F$.\n\n\n```typst \n#commutative-diagram(\n  node((0, 0), $cal(U)cal(F)(cal(H))$),\n  node((0, 1), $cal(F)(cal(H))$),\n  node((1, 1), $cal(U)(cal(A))$),\n  node((2, 0), $cal(H)$),\n  node((1, 2), $cal(A)$),\n  arr($cal(U)cal(F)(cal(H))$, $cal(H)$, $H_(cal(H))$, label-pos: right),\n  arr($cal(U)cal(F)(cal(H))$, $cal(U)(cal(A))$, $cal(U)(F') = F'$),\n  arr($cal(H)$, $cal(U)(cal(A))$, $F$, label-pos: right),\n  arr($cal(F)(cal(H))$, $cal(A)$, $F'$, \"dotted\")\n)\n```\nLa propiedad universal anterior significa que $cal(F)$ es un functor \n$bold(\"Grph\") arrow bold(\"Cart\")$ que es adjunto izquierdo a $cal(U)$ con adjuncin \n$H_(( )) : id arrow cal(U) cal(F)$.","src/content/docs/tipos/Lambek/CCCs/cccs-graficas.mdx","1d971754ff86b98f","tipos/lambek/cccs/polinomiales",{"id":685,"data":687,"filePath":694,"digest":695,"deferredRender":16},{"title":688,"editUrl":16,"head":689,"template":18,"sidebar":690,"pagefind":16,"draft":20,"sitemap":692},"Categoras polinomiales",[],{"order":65,"hidden":20,"attrs":691},{},{"linkInclusionRules":693},[24],"src/content/docs/tipos/Lambek/CCCs/polinomiales.mdx","53844cf6b19397d6","categorias/awodey/diagramas",{"id":696,"data":698,"body":705,"filePath":706,"digest":707,"deferredRender":16},{"title":699,"editUrl":16,"head":700,"template":18,"sidebar":701,"pagefind":16,"draft":20,"sitemap":703},"Diagramas de categoras",[],{"order":91,"hidden":20,"attrs":702},{},{"linkInclusionRules":704},[24],"import { Aside } from '@astrojs/starlight/components';\n\n## Categoras functoriales con conjuntos como valores\n\nNos centraremos en categoras de functores especiales de la forma \n\n$ bold(\"Sets\")^bold(C) $\n\ndonde la categora $bold(C)$ es localemente pequea. As, los objetos son functores conjunto \nvaluados \n\n$ F, G : bold(C) arrow bold(\"Sets\") $\n\ny las flechas son transformaciones naturales \n\n$ alpha, beta : F arrow G. $\n\n## El encaje de Yoneda \n\nEntre los objetos de $bold(\"Sets\")^bold(C)$ hay algunos muy especiales, los funcores \n(covariantes) representable, \n\n$ \"Hom\"_bold(C) (C, -) : bold(C) arrow bold(\"Sets\"). $\n\nObservemos que para cada $h : C arrow D$ en $bold(C)$, tenemos una transformacin natural \n\n$ \"Hom\"_bold(C) (h, -) : \"Hom\" _bold(C) (D, -) arrow \"Hom\" _bold(C) (C , -) $\n\ndonde el componente en $C$ est definido por la pre-composicin \n\n$ (f : D arrow X) mapsto (f compose h : C arrow X). $\n\nDe modo que tenemos un functor contravariante \n\n$ k : bold(C)^\"op\" arrow bold(\"Sets\")^bold(C) $\n\ndefinido por $k(C) = \"Hom\"_bold(C) (C, -)$. Por supuesto, este functor $k$ slo es la \nexponencial del bifunctor \n\n$ \"Hom\"_bold(C) : bold(C)^\"op\" times bold(C) arrow bold(\"Sets\") $\n\nSi transponemos $\"Hom\"_ bold(C)$ con respecto a su otro argumento, obtenemos un functor \ncovariante \n\n$ y : bold(C) arrow \"Sets\"^(bold(C)^\"op\") $\n\nde $bold(C)$ a la categora de functores contravariantes conjunto valuados, a veces llamados \npre-gavillas.\n\n\n\u003Cdiv id=\"definicion-8-1\">\n\u003CAside type=\"note\" title=\"Definicin 8.1\">\nEl *encaje* de Yoneda es el functor $y : bold(C) arrow bold(\"Sets\")^(bold(C)^\"op\")$ tomando \n$C in bold(C)$ al functor contravariante representable \n\n$ y C = \"Hom\"_bold(C) (-, C) : bold(C)^\"op\" arrow bold(\"Sets\") $\n\ny tomando $f : C arrow D$ a la tranformacin natural \n\n$ y f = \"Hom\"_bold(C) (-, f) : \"Hom\" _bold(C) (-, C) arrow \"Hom\" _bold(C) (-, D). $\n\u003C/Aside>\n\u003C/div>\n\n## El lema de Yoneda \n\n\u003Cdiv id=\"lema-8.2\">\n\u003CAside type=\"tip\" title=\"Lema 8.2 (Yoneda)\">\nSea $bold(C)$ localmente pequea. Para cualquier objeto $C in bold(C)$ y functor \n$F in bold(\"Sets\")^(bold(C)^\"op\")$, hay un isomorfismo \n\n$ \"Hom\"(y C, F) tilde.equiv F C $\n\nque es natural en $C$ y $F$.\n\u003C/Aside>\n\u003C/div>","src/content/docs/categorias/Awodey/diagramas.mdx","9e6a4da1e5535071","categorias/awodey/adjunciones",{"id":708,"data":710,"body":717,"filePath":718,"digest":719,"deferredRender":16},{"title":711,"editUrl":16,"head":712,"template":18,"sidebar":713,"pagefind":16,"draft":20,"sitemap":715},"Adjunciones",[],{"order":178,"hidden":20,"attrs":714},{},{"linkInclusionRules":716},[24],"## Definicin preliminar\n\nUna *adjuncin* entre categoras $bold(C)$ y $bold(D)$ consiste de functores\n\n$ F : bold(C) arrow bold(D) quad \"y\" quad U : bold(D) arrow bold(C) $\n\ny una transformacin natural \n\n$ eta : 1_bold(C) arrow U compose F $\n\ncon la propiedad: \n\n- (*) Para cada $C in bold(C)$, $D in bold(D)$ y $f : C arrow U(D)$ existe una nica \n  $g : F C arrow D$ tal que \n  $ f = U(g) compose eta_C $\n  como se indica en \n  ```typst \n  #commutative-diagram(\n    node((0, 0), $F(C)$),\n    node((0, 1), $D$),\n    arr($F(C)$, $D$, $g$, \"dotted\"),\n\n    node((1, 0), $U(F(C))$),\n    node((1, 1), $U(D)$),\n    node((2, 0), $C$),\n    arr($C$, $U(F(C))$, $eta_C$),\n    arr($C$, $U(D)$, $f$, label-pos: right),\n    arr($U(F(C))$, $U(D)$, $U(g)$)\n  )\n  ```\n\n### Terminologa y notacin \n- $F$ es llamado el *adjunto izquierdo*, $U$ el *adjunto derecho* y $eta$ la *unidad* de \n  la adjuncin. \n- A veces escribimos $F tack.l U$ para \"$F$ es adjunto izquierdo y $U$ adjunto derecho\".\n- El enunciado (*) es la propiedad universal de la unidad $eta$.\n\nSupongamos que tenemos una adjuncin \n\n$ bold(C) arrow^F bold(D) quad \"y\" quad bold(D) arrow^U bold(C) $\n\nEntonces, si tomamos $C in bold(C)$ y $D in bold(D)$ y consideramos la operacin \n\n$ phi : \"Hom\"_bold(D) (F C, D) arrow \"Hom\"_bold(C) (C, U D) $\n\ndado por $phi(g) = U(g) compose eta_ C$. Vemos que, por la propiedad universal de $eta$, \ncada $f : C arrow U D$ es $phi(g)$ para una $g$ nica, de modo que $phi$ es un \nisomorfismo\n\n$ \"Hom\"_bold(D) (F(C), D) tilde.equiv \"Hom\"_bold(C) (C, U(D)) $\n\nque se puede representar como una regla de dos sentidos\n\n```typst \n#prooftree(\n  rule(\n    $C arrow.long U(D)$,\n    $F(C) arrow.long D$\n  )\n)\n```\n\n## Definicin \n\nUna adjuncin consiste de dos functores \n\n$ F : bold(C) arrow bold(D) quad \"y\" quad U : bold(D) arrow bold(C) $\n\ny un isomorfismo natural \n\n$ phi : \"Hom\"_D (F C, D) tilde.equiv \"Hom\"_C (C, U D) : psi. $\n\n\n## Cuantificadores como adjunciones \n\nSea $cal(L)$ un lenguaje de primer orden. Para cualquier lista \n$overline(x) = x_1, dots, x_n$ de variables distintas, formemos el conjunto de frmulas con,\na lo ms, esas variables libres por \n\n$ \n\"Form\"(overline(x)) = brace.l phi(overline(x)) | phi(overline(x))\" tiene a lo ms\" \n  overline(x) \"libre\" brace.r \n$\n\nEntonces, $\"Form\"(overline(x))$ es un pre-orden bajo la relacin de deduccin \n\n$ phi(overline(x)) tack.r psi(overline(x)). $\n\nAhora, sea $y$ una variable que no est en la lista $overline(x)$ y notemos que tenemos la \noperacin trivial \n\n$ * : \"Form\"(overline(x)) arrow \"Form\"(overline(x), y) $\n\nque lleva a cada $phi(overline(x))$ a s mismo, esto es slo una cuestin de observar \nque si $phi(overline(x)) in \"Form\"(overline(x))$ entonces $y$ no puede ser libre en \n$phi(overline(x))$. Por supuesto, $*$ es trivialmente un functor, pues \n\n$ phi(overline(x)) tack.r psi(overline(x)) \"en\" \"Form\"(overline(x)) $\n\nimplica trivialmente que \n\n$ * phi(overline(x)) tack.r * psi(overline(x)) \"en\" \"Form\"(overline(x), y). $\n\nAhora, como para cada $psi(overline(x), y) in \"Form\"(overline(x), y)$ no hay ninguna \n$y$ libre en la frmula $forall y. psi(overline(x), y)$, tenemos un mapeo\n\n$ forall y : \"Form\"(overline(x), y) arrow \"Form\"(overline(x)). $\n\nAfirmamos que este mapa es adjunto derecho a $*$, \n\n$ * tack.l forall. $\n\nEn efecto, se tiene la siguiente regla de inferencia \n\n```typst \n#prooftree(\n  rule(\n    $phi(overline(x)) tack.r forall y. psi(overline(x), y) quad \"Form\"(overline(x))$,\n    $* phi(overline(x)) tack.r psi(overline(x), y) quad \"Form\"(overline(x), y)$\n  )\n)\n```\n\nEs ahora natural preguntarnos sobre el cuantificador existencial. Notemos que se cumple \nla siguiente regla en ambos sentidos \n\n```typst \n#prooftree(\n    rule(\n       $psi(overline(x), y) tack.r *phi(overline(x))$,\n       $exists y. psi(overline(x), y) tack.r phi(overline(x))$\n    )\n)\n```\n\nDe modo que tenemos las adjunciontes \n\n$ exists tack.l * tack.l forall. $","src/content/docs/categorias/Awodey/adjunciones.mdx","8d91e8ac6ea412a8"]