---
title: How to Use
description: Guide for using executable code blocks and commutative diagrams
---

import ExecutableCode from '../../components/ExecutableCode.astro';
import TypstDiagram from '../../components/TypstDiagram.astro';

# How to Use

This guide explains how to use executable code blocks and commutative diagrams in your MDX notes.

# Executable Code Blocks

## Basic Syntax

There are two ways to write executable code blocks:

### Method 1: Using the Component Directly

```jsx
<ExecutableCode
  language="python"
  id="my-block"
  code={`print("Hello, World!")`}
/>
```

### Method 2: Using ```code Syntax (Simplified)

You can also use a simpler fence syntax that gets automatically converted:

````
<ExecutableCode
  language="python"
  id="my-block"
  code={`print("Hello, World!")`}
/>
````

Then run `npm run convert-code-syntax` to convert it to the ExecutableCode component.

### Required Props/Attributes

- **`language`**: The programming language (`python`, `lean4`, or `rust`)
- **`id`**: A unique identifier for the block (within the file)
- **`code`**: The code to execute (wrapped in template literals)

### Optional Props

- **`session`**: Session name to share state between blocks
- **`output`**: Manual output (if you don't want auto-execution)
- **`showOutput`**: Set to `false` to hide the output section

## Session Handling

Use sessions to persist variables between code blocks.

**Component syntax:**

```jsx
<ExecutableCode
  language="python"
  id="block-1"
  session="my-session"
  code={`x = 10
y = 20`}
/>

<ExecutableCode
  language="python"
  id="block-2"
  session="my-session"
  code={`print(f"x + y = {x + y}")`}
/>
```

**```code syntax:**

````
<ExecutableCode
  language="python"
  id="block-1"
  session="my-session"
  code={`x = 10
y = 20`}
/>

<ExecutableCode
  language="python"
  id="block-2"
  session="my-session"
  code={`print(f"x + y = {x + y}")`}
/>
````

All blocks with the same `session` name will share their state.

## Supported Languages

### Python

**Component syntax:**
```jsx
<ExecutableCode
  language="python"
  id="python-example"
  code={`def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))`}
/>
```

**```code syntax:**
````
<ExecutableCode
  language="python"
  id="python-example"
  code={`def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))`}
/>
````

### Lean4

**Component syntax:**
```jsx
<ExecutableCode
  language="lean4"
  id="lean-example"
  code={`def double (x : Nat) : Nat := x + x

#eval double 21`}
/>
```

**```code syntax:**
````
<ExecutableCode
  language="lean4"
  id="lean-example"
  code={`def double (x : Nat) : Nat := x + x

#eval double 21`}
/>
````

## Workflow

### If Using Component Syntax Directly

1. **Write your MDX file** with ExecutableCode components
2. **Import the component** at the top of your file:
   ```jsx
   import ExecutableCode from '../../../components/ExecutableCode.astro';
   ```
3. **Run the execution script**:
   ```bash
   npm run execute-code
   ```
4. **View your notes** with `npm run dev`

### If Using ```code Syntax

1. **Write your MDX file** using ````code` fences with attributes
2. **Run the processing script**:
   ```bash
   npm run process-all
   ```

   This runs three scripts in sequence:
   - Converts LaTeX in headings to Unicode
   - Converts ````code` syntax to ExecutableCode components (adds import automatically)
   - Executes all code blocks and generates outputs

3. **View your notes** with `npm run dev`

## Important Notes

### Unique IDs

IDs only need to be unique **within each file**. The system automatically prefixes IDs with the filename to prevent collisions:

```
dependiente.mdx:  id="example-1"  →  dependiente::example-1
example.mdx:      id="example-1"  →  example::example-1
```

So you can use simple IDs like "1", "2", "example-1", etc. in each file without worrying about conflicts.

### Import Statement

Always add this import at the top of your MDX file (after the frontmatter):

```jsx
---
title: Your Title
---

import ExecutableCode from '../../../components/ExecutableCode.astro';
```

Make sure there's a blank line after the frontmatter (`---`) and before the import.

### Manual Output

If you want to provide output manually without execution:

```jsx
<ExecutableCode
  language="python"
  code={`print("Hello")`}
  output="Hello"
/>
```

### Hiding Output

To show only the code without output:

```jsx
<ExecutableCode
  language="python"
  id="setup"
  code={`import numpy as np`}
  showOutput={false}
/>
```

## Scripts Reference

- **`npm run convert-code-syntax`** - Convert code blocks to ExecutableCode components
- **`npm run convert-diagram-syntax`** - Convert diagram blocks to TypstDiagram components
- **`npm run typst-to-unicode`** - Convert Typst math in headings to Unicode (e.g., `$NN$` → ℕ)
- **`npm run execute-code`** - Execute all code blocks
- **`npm run process-all`** - Run all scripts in sequence (code, diagrams, unicode, execution)

## Showcase Examples

### Python: Fibonacci Sequence

<ExecutableCode
  language="python"
  id="showcase-fibonacci"
  code={`def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        print(a, end=' ')
        a, b = b, a + b

fibonacci(10)`}
/>

### Lean4: Type Theory

<ExecutableCode
  language="lean4"
  id="showcase-lean"
  code={`def compose {α β γ : Type} (g : β → γ) (f : α → β) : α → γ :=
  fun x => g (f x)

def double (x : Nat) : Nat := x + x
def triple (x : Nat) : Nat := x + x + x

#eval (compose triple double) 5`}
/>

### Rust: Pattern Matching

<ExecutableCode
  language="rust"
  id="showcase-rust"
  code={`fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    let sum: i32 = numbers.iter().sum();
    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();

    println!("Sum: {}", sum);
    println!("Doubled: {:?}", doubled);
}`}
/>

### Python with Sessions: Data Processing

<ExecutableCode
  language="python"
  id="showcase-data-1"
  session="data-demo"
  code={`import statistics

data = [23, 45, 12, 67, 34, 89, 56]
print(f"Original data: {data}")`}
/>

<ExecutableCode
  language="python"
  id="showcase-data-2"
  session="data-demo"
  code={`mean = statistics.mean(data)
median = statistics.median(data)
print(f"Mean: {mean:.2f}")
print(f"Median: {median}")`}
/>

<ExecutableCode
  language="python"
  id="showcase-data-3"
  session="data-demo"
  code={`sorted_data = sorted(data)
print(f"Sorted: {sorted_data}")
print(f"Min: {min(data)}, Max: {max(data)}")`}
/>

## Tips

1. Run `npm run execute-code` whenever you add or modify code blocks
2. The outputs are cached in `src/code-outputs.json`
3. Sessions are scoped per file and language
4. Use descriptive IDs to make it easier to debug
5. Supported languages: Python, Lean4, and Rust

---

# Commutative Diagrams with Typst

Create beautiful commutative diagrams using Typst.

## Simple Example

<TypstDiagram scale={1.5} code={`#commutative-diagram(
  node((0, 0), $A$),
  node((0, 1), $B$),
  arr((0, 0), (0, 1), $f$)
)`} />

**Code:**
```jsx
<TypstDiagram scale={1.5} code={`#commutative-diagram(
  node((0, 0), $A$),
  node((0, 1), $B$),
  arr((0, 0), (0, 1), $f$)
)`} />
```

## Available Parameters

- `scale` - Scale factor (e.g., `1.5`, `2`)
- `nodePadding` - Node spacing (e.g., `"(80pt, 60pt)"`)
- `width`, `height` - Custom dimensions
- `arrClearance` - Arrow spacing from nodes
- `padding` - Outer padding

## Arrow Styles

<TypstDiagram scale={1.5} nodePadding="(80pt, 60pt)" code={`#commutative-diagram(
  node((0, 0), $A$),
  node((0, 1), $B$),
  node((0, 2), $C$),
  arr((0, 0), (0, 1), $f$, "inj"),
  arr((0, 1), (0, 2), $g$, "surj")
)`} />

**Special arrows:**
- `"inj"` - Injective (hook)
- `"surj"` - Surjective (double tip)
- `"dashed"` - Dashed line
- `curve: 20deg` - Curved arrow
- `label-pos: left/right` - Label position

See `/categorias/` for more examples!

## Testing Fenced Diagram Syntax

This diagram uses the fenced syntax and will be converted when you run `npm run convert-diagram-syntax`:

<TypstDiagram scale={1.5} nodePadding="(70pt, 60pt)" code={`#commutative-diagram(
  node((0, 0), $X$),
  node((0, 1), $Y$),
  node((1, 0), $Z$),
  arr((0, 0), (0, 1), $f$, label-pos: left),
  arr((0, 0), (1, 0), $g$, label-pos: right),
  arr((0, 1), (1, 0), $h$)
)`} />
