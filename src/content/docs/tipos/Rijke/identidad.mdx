---
title: Tipos identidad
sidebar:
    order: 7
typstImports: 
    - '#import "@preview/curryst:0.5.1": rule, prooftree'
---
import { Aside } from '@astrojs/starlight/components';
    
Desde la perspectiva de los tipos como proposiciones donde las demostraciones son relevantes, ¡cómo deberíamos pensar
la *igualdad* en la teoría de tipos? Dado un tipo $a$, y dos elementos $x,y: A$, la igualdad $x=y$ debe ser de nuevo
un tipo. En efecto, queremos *usar* la teoría de tipos para demostrar igualdades. La teoría de tipos dependiente nos
da un lugar adecuado para esto: el tipo identidad $x=y$ depende de $x, y: A$

Entonces, si $x=y$ va a ser un tipo, ¿cómo deberíamos pensar sobre los elementos de $x=y$? Un elemento $p: x = y$
es un observador de que $x$ y $y$ son elementos iguales de tipo $A$. En otras palabras, $p: x = y$ es una 
*identificación* de $x$ y $y$. En el mundo donde las demostraciones son relevantes, podría haber muchos elementos 
de tipo $x = y$, es decir, muchas identificaciones de $x$ y $y$. Y como $x = y$ es un tipo, podemos formar el tipo 
$p = q$ para cualesquiera dos identificaciones $p, q: x = y$. Es decir, como $x = y$ es un tipo, en la teoría de 
tipos también podemos probar cosas sobre las identificaciones y podemos usar la teoría de tipos para realizar 
construcciones sobre ellas. Como veremos más adelante, a cada tipo le podemos dar estructura de grupoide.

Claramente, el tipo igualdad no debe ser un tipo cualquiera que dependa de $x, y: A$. Entonces, ¿cómo formamos
el tipo igualada y qué maneras hay de usar las identificaciones en la teoría de tipos? La respuesta a ambas preguntas
es que formaremos el tipo igualdad como un *tipo inductivo*, generado por un sólo elemento reflexivo, que será una 
identificación que identifica a $x$ consigo mismo. El principio de inducción nos dará una manera de realizar 
construcciones sobre estas identificaciones, como concatenarlas, invertirlas y demás. Así, el tipo identidad 
está equipado con un elemento reflexivo y posee la estructura que se genera por el principio de inducción y la 
teoría de tipos. Esta construcción es elegante, hermosamente simple y muy lejos de ser trivial.

La situación en la que dos elementos se pueden identificar en más de una manera es análoga a la situación en la 
teoría de *homotopia*, donde dos puntos de un espacio pueden conectares por más de una trayectoria. En efecto, para 
cualesquiera dons puntos $x$ y $y$ en un espacio, hay un espacio de *homotopías* entre ellos.

## La definición inductiva de los tipos identidad

<div id="definicion 5.1.1">
<Aside type="tip" title="Definición 5.1.1">
Consideremos un tipo $A$ y sea $a: A$. Entonces definimos el **tipo identidad**  de $A$ en $a$ como la familia 
inductiva de tipos $a attach(a, br: A) x$ indizada por $x: A$, de la cual el constructor es 
$ "refl"_a : a attach(=, br: A) a. $
El principio de inducción para el tipo identidad postula que para cualquier familia de tipos $P(x, p)$ indizada 
por $x: A$ y $p: a attach(=, br: A) x$, hay una función
$ "ind-eq"_a : P(a, "refl"_a) arrow Pi_((x: A)) Pi_((p: a attach(=, br: A) x)) P(x, p) $
que satisface $"ind-eq"_a (u, a, "refl"_a) equiv u$, dada $u: P(a, "refl"_a)$.

Un elemento de tipo $a attach(=, br: A) x$ es también llamado una **identificación** de $a$ con $x$ o una 
**trayectoria** de $a$ a $x$. El principio de inducción para los tipos identidad es a veces llamado 
**eliminación de identificaciones** o **inducción de trayectorias**. También escribimos $"Id"_A$ para el tipo 
identidad en $A$ y escribimos $a = x$ para el tipo de identificaciones de $a$ con $x$, omitiendo la referencia al 
espacio ambiente $A$.
</Aside>
</div>

<div id="observacion 5.1.2">
<Aside type="note" title="Observación 5.1.2">
Vemos que el tipo identidad no es un tipo inductivo cualquiera, como $NN, emptyset$ y $bold(1)$ por ejemplo, sino 
una *familia* inductiva de tipos. Aunque tenemos un tipo $a attach(=, br: A) x$ para cada $x: A$, el constructor sólo
nos da un elemento $"refl"_a: a attach(=, br: A) a$, que identifica a $a$ consigo mismo. El principio de inducción
entonces dice que para probar algo sobre todas las identificaciones de $a$ con algún $x: A$, es suficiente probarlo 
para $"refl"_a$ solamente. Veremos más adelante que este principio de inducción es suficientemente fuerte para 
derivar muchos hechos familiares sobre la igualdad, por ejemplo, que es una relación de equivalencia y que todas 
las funciones la preservan.

</Aside>
</div>


<div id="observacion 5.1.3">
<Aside type="tip" title="Observacíón 5.1.3">
Como los tipos identidad requieren que nos acostumbremos a ellos, damos sus reglas formales. El tipo identidad es 
formado por la regla de formación

```typst
#prooftree(
    rule(
       $Gamma, x: A tack.r a attach(=, br: A) x "type"$,
       $Gamma tack.r a: A $
    )
)
```
El constructor del tipo identidad está dado por la regla de introducción:
```typst
#prooftree(
    rule(
       $Gamma tack.r "refl"_a : a attach(=, br: A) a$,
       $Gamma tack.r a: A$
    )
)
```

El principio de inducción está dado por al regla de eliminación:

```typst
#prooftree(
    rule(
        $Gamma tack.r "ind-eq"_a : P(a, "refl"_a) arrow Pi_((x: A)) Pi_((p: a attach(=, br: A) x)) P(x, p)$,
        $Gamma tack.r a: A$,
        $Gamma, x: A, p: a attach(=, br: A) x tack.r P(x, p) "type"$,
    )
)
```
Y finalmente, la regla de computación es:

```typst
#prooftree(
    rule(
       $Gamma, u: P(a, "refl"_a) tack.r "ind-eq"_a (u, a, "refl"_a) equiv u: P(a, "refl"_a)$,
       $Gamma tack.r a: A$,
       $Gamma, x: A, p: a attach(=, br: A) x tack.r P(x, p) "type"$
    )
)
```
</Aside>
</div>

<div id="observacion 5.1.4">
<Aside type="note" title="Observación 5.1.4">

Uno podría preguntarse si es posible formar el tipo identidad en un tipo *variable* de tipo $A$, en lugar de un 
elemento. Esto es ciertamente posible: como podemos formar el tipo identidad en cualquier contexto, podemos 
formar el tipo identidad en una variable $x: A$ como sigue:

```typst 
#prooftree(
    rule(
       $Gamma, x: A, y: A tack.r x attach(=, br: A) y "type"$,
       $Gamma, x: A tack.r x: A$
    )
)
```
De esta manera, obtenemos el tipo identidad "binario". Su constructor es también indizado por $x: A$. Tenemos 
la siguiente regla de introducción 
```typst
#prooftree(
    rule(
       $Gamma, x: A tack.r "refl"_x : x attach(=, br: A) x$,
       $Gamma, x: A tack.r x: A$
    )
)
```
y similarmente tenemos reglas de eliminación y computación.
</Aside>
</div>


## La estructura de grupoide de los tipos

Mostraremos que las identificaciones pueden ser *concatenadas* e *invertidas*, lo que corresponde a la transitividad
y simetría del tipo identidad.

<div id="definicion 5.2.1">
<Aside type="note" title="Definición 5.2.1">
Sea $A$ un tipo. Definimos la operación de **concatenación**
$ "concat": Pi_((x, y, z: A)) (x = y) arrow ((y = z) arrow (x = z)) $
Escribiremos $p dot q$ para $"concat"(p, q)$.

*Construcción* Primero construimos una función
$ f(x) : Pi_((y: A)) (x = y) arrow Pi_((z: A)) (y = z) arrow (x = z) $
para cada $x: A$. Por el principio de inducción para tipos identidad, basta construir 
$ f(x, x, "refl"_x): Pi_((z: A)) (x = z) arrow (z = z). $
Aquí, tenemos la función $lambda z. "id"_ ((x = Z))$. La función $f(x)$ que obtenemos vía eliminación de identidades 
está explícitamente definida como 
$ f(x) := "ind-eq"_(x) (lambda z. "id") : Pi_((y: A)) (x = y) arrow Pi_((z: A)) (y = z) arrow (x = z). $

Para terminar la construcción de concat, usamos el ejercicio 4.2 para cambiar el orden de la tercera y cuarta variable
de $f$, es decir, definimos 
$ "concat"_ (x, y, z) (p, q) := f(x, y, p, z, q) $ 
</Aside>
</div>

<div id="definicion-5-2-2">
<Aside type="tip" title="Definición 5.2.2">
Sea $A$ un tipo. Definimos la **operación de inversión**
$ "inv": Pi_((x, y: A)) (x = y) arrow (y = x) $

La mayoría de las veces escribimos $p^(-1)$ en lugar de $"inv"(p)$.

*Construcción* Por el principio de inducción para tipos identidad, es suficiente construir 
$ "inv" ("refl" _x): x = x $
para cada $x: A$. Así, tomamos $"inv"("refl") _x := "refl" _x$.
</Aside>
</div>

La siguiente pregunta es si las operaciones de concatenación e inversión sobre identificaciones se comportan como 
esperamos. Más concretamente: ¿es la concatenación de identificaciones asociativa?, ¿satisface las leyes de 
unidad?, ¿es el inverso de una identificación inverso por ambos lados?

Por ejemplo, en el caso de la asociatividad, estamos comparando las identificaciones 
$ (p dot q) dot r " y " p dot (q dot r) $
para cualesquiera $p: x = y$, $q: y = z$ y $r: z = w$ en un tipo $A$. Las reglas de computación para el tipo 
identidad no son lo suficientemente fuertes para probar que $(p dot q) dot r$ y $p dot (q dot r)$ son juiciosamente
iguales. Sin embargo, $(p dot q) dot r$ y $p dot (q dot r)$ son elementos del mismo tipo, ambos son identificaciones 
de tipo $x = w$. Como el tipo identidad es un tipo como cualquier otro, podemos preguntarnos si hay una 
*identificación*
$ (p dot q) dot r = p dot (q dot r). $
Esta es una idea muy útil: aunque a veces es imposible mostrar que dos elementos del mismo tipo son iguales en juicio,
puede ser posible que esos elementos puedan ser *identificados*. En efecto, identificamos dos elementos construyendo
un elemento del tipo identidad y podemos usar toda la teoría de tipos a nuestra disposición para construir dicho 
elemento. De esta manera, podemos mostrar, por ejemplo, que la adición en los números naturales o en los enteros
es asociativa y satisface las leyes de la unidad. Aquí mostraremos que la concatenación de identificaciones es 
asociativa y satisface las leyes de la unidad.

<div id="definicion-5-2-3">
<Aside type="tip" title="Definición 5.2.3">
Sea $A$ un tipo y consideremos tres identificaciones consecutivas 
$ x =^p y =^q z =^r w $
en $A$. Definimos el *asociador* 
$ "assoc(p, q, r)": (p dot q) dot r = p dot (q dot r) $

*Construcción* Por el principio de inducción para tipos identidad, es suficiente probar que
$ Pi_((z: A)) Pi_((q: x = z)) Pi_((w: A)) Pi_((r: z=w)) ("refl" _x dot q) dot r  = "refl" _x dot (q dot r) $
Sea $q: x = z$ y $r: z = w$. Notemos que por la regla de computación para tipos identidad, tenemos una igualdad 
juiciosa $"refl" _x dot q equiv q$. Entonces concluimos que 
$ ("refl" _x dot q) dot r equiv q dot r $
Similarmente, tenemos la igualdad juiciosa $"refl" _x dot (q dot r) equiv q dot r$. Así, vemos que el lado 
izquierdo y el lado derecho en 
$ ("refl" _x dot q) dot r = "refl" _x dot (q dot r) $
son juiciosamente iguales, de modo que simplemente podemos definir $"assoc"("refl" _x, q, r) := "refl" _(q dot r)$.
</Aside>
</div>

<div id="definicion-5-2-4">
<Aside type="tip" title="Definición 5.2.4">
Sea $A$ un tipo. Definimos las operaciones de *leyes de unidad* derecha e izquierda, que asignan a cada $p: x = y$
las identificaciones
$ "left-unit"(p) : "refl" _x dot p = p $
$ "right-unit"(p) : p dot "refl" _x. $
respectivamente.

*Construcción* Por eliminación de identificaciones, es suficiente construir 
$ "left-unit"("refl" _x): "refl" _x dot "refl" _x = "refl" _x $
$ "right-unit"("refl" _x): "refl" _x dot "refl" _x = "refl" _x. $
en ambos casos, tomamos $"refl" _("refl" _x)$.
</Aside>
</div>

<div id="definicion-5-2-5">
<Aside type="tip" title="Definición 5.2.5">
Sea $A$ un tipo. Definimos las *leyes de inversión* derechas e izquierdas 
$ "left-inv"(p): p^(-1) dot p = "refl" _y $
$ "right-inv"(p): p dot p^(-1) = "refl" _x $

*Construcción* Por eliminación de identificaciones, es suficiente probar 
$ "left-inv"("refl" _x): "refl"^(-1) _(x) dot "refl" _x = "refl" _x $
$ "right-inv"("refl" _x): "refl" _x dot "refl"^(-1) _x = "refl" _x $
Usando las reglas de computación vemos que 
$ "refl"^(-1) _x dot "refl" _x equiv "refl" _x dot "refl" _x equiv "refl" _x, $
de modo que definimos $"left-inv" ("refl" _x) := "refl" _("refl" _x)$. Similarmente, se sigue de las reglas de 
computación que 
$ "refl" _x dot "refl"^(-1) _x equiv "refl"^(-1) _x equiv "refl" _x $
Así que definimos $"right-inv" ("refl" _x) := "refl" _("refl" _x)$.
</Aside>
</div>

<div id="observacion-5-2-6">
<Aside type="note" title="Observación 5.2.6">
Hemos visto que el asociador, las leyes de la unidad y las leyes de la inversión todas se demuestran 
construyendo una identificación de identificaciones. Y, por supuesto, no hay nada que nos detenga de considerar
identificaciones de esas identificaciones. Podemos ir tan arriba como queramos en la torre de los *tipos identidad*,
que se obtiene tomando tipos identidad de forma iterada.
Los tipos identidad iterados dan tipos en la teoría homotópica de tipos que tienen una estructura muy intricada.
Una forma importante de estudiar esta estructura es mediante los grupos de homotopía de los tipos, algo que poco a 
poco iremos construyendo.
</Aside>
</div>

## La acción de las funciones sobre las identificaciones
Usando el principio de inducción de los tipos identidad, podemos mostrar que toda función preserva las 
identificaciones. En otras palabras, toda función manda elementos identificados a objetos identificados. Notemos
que esta es una forma de continuidad para funciones en la teoría de tipos: si hay una identificación que 
identifica dos puntos $x$ y $y$ de un tipo $A$, entonces también hay una identificación entre los valores 
$f(x)$ y $f(y)$ en el co-dominio de $f$.




