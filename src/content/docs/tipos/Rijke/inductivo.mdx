---
title: Más tipos inductivos
sidebar:
  order: 6
typstImports: 
  - '#import "@preview/curryst:0.5.1": rule, prooftree'
---
import { Aside } from '@astrojs/starlight/components';

## La idea de los tipos inductivos

Los tipos inductivos se especifican por sus _constructores_, un _principio de 
inducción_ y sus _reglas de computación_:

1. Los constructores dicen qué estructura tiene el tipo inductivo. Puede haber una 
  cantidad finita de constructores, inclusive ninguno, en la especificación de 
  un tipo inductivo.
2. El principio de inducción especifica qué datos se deben dar para construir una 
  sección de una familia de tipos arbitraria sobre el tipo inductivo. La idea es 
  siempre la misma: para definir una función dependiente $f: Pi_((x: A)) B(x)$ 
  necesitamos especificar el comportamiento de $f$ en los constructores de $A$.
3. Las reglas de computación afirman que la sección definida inductivamente concuerda
  en los constructores con los datos que se usaron para definir la sección. Así, 
  hay una regla de computación para cada constructor.

## El tipo unidad

Un ejemplo sencillo de tipo inductivo es el _tipo unidad_ que tiene un sólo 
constructor. Su principio de inducción es análogo a sólo el caso base del principio 
de inducción para los naturales.

<div id="definicion-4-2-1">
<Aside type="tip" title="Definición 4.2.1">
Definimos el *tipo unidad* como un tipo *1* equipado con un término 
$ star : 1, $
que satisface el principio de inducción que dice que para cada familia de tipos 
$P(x)$ indizada por $star: 1$, hay una función 
$ "ind"_1 : P(star) arrow.r Pi_((x: 1)) P(x) $
para la cual, la regla de computación 
$ "ind"_1 (p, star) equiv p $

se cumple. De forma alternativa, una definición de una función dependiente 
$f: Pi_((x: 1)) P(x)$ por inducción usando $p: P(star)$ puede presentarse vía 
patrones como 
$ f(star) := p. $
</Aside>
</div>

Un caso especial de principio de inducción es cuando $P$ no depende de *1*. Si nos dan
un tipo $A$, podemos debilitarlo para obtener una familia constante sobre *1* con 
valor $A$. Entonces el principio de inducción del tipo unidad nos da una función 
$ "ind"_1 : A arrow (1 arrow  A) $
En otras palabras, el principio de inducción para el tipo unidad nos da para cada 
$x: A$ una función $"pt"_x := "ind"_1(x): bold(1) arrow A$.

## El tipo vacío

El tipo vacío es un caso degenerado de un tipo inductivo. No viene equipado con 
ningún constructor, y por tanto, no tiene reglas de computación. El principio de 
inducción meramente dice que toda familia de tipos tiene una sección. En otras
palabras: si asumimos que el tipo vacío tiene un término, entonces podemos probar
cualquier cosa.

<div id="definicion-4-3-1">
<Aside type="tip" title="Definición 4.3.1">
Definimos el *tipo vacío* como un tipo $emptyset$ que staisface el principio de 
inducción que dice que para cada familia de tipos $P(x)$ indizada por $x: emptyset$,
hay un término 
$ "ind"_emptyset : Pi_((x: emptyset)) P(x) $
De nuevo, es un caso especial del principio de inducción que tengamos una función 
$ "ex-falso":= "ind"_emptyset : emptyset arrow A $
para cada tipo $A$. Para obtener esta función, primero debilitamos $A$ para obtener
una familia constante sobre $emptyset$ con valor $A$, y luego el principio de 
inducción da la función deseseada. La función ex-falso puede usarse para derivar 
cualquier consclusión después de derivar una contradicción.
</Aside>
</div>

<div id="definicion-4-3-2">
<Aside type="tip" title="Definición 4.3.2">
Pra cada tipo $A$ definimos la *negación* de $A$ como 
$ not A := A arrow emptyset. $
También decimos que un tipo $A$ *está vacío* si viene equipado con un elemento
de tipo $not A$. Así, definimos 
$ "is-empty"(A) := A arrow emptyset. $
</Aside>
</div>

<div id="observacion-4-3-3">
<Aside type="note" title="Observación 4.3.3">
Como $not A$ es el tipo de funciones de $A$ en $emptyset$, una demostración de 
$not A$ se da asumiendo que se cumple $A$ y luego construyendo un elemento del 
tipo vacío. En otras palabras, demostramos $not A$ asumiendo $A$ y derivando una 
contradicción. Este estilo de demostración se llama *prueba de negación*.

Las pruebas de negación no deben confundirse con las demostraciones por contradicción.
Incluso si una demostración de negación involucra llegar a una contradicción, en 
lógica, una *demostración por contradicción* de una proposición $P$ es un argumento 
en el que concluimos que $P$ se cumple después de mostrar que $not P$ implica una 
contradicción. En otras palabras, una demostración por contradicción usa el paso 
lógico $not not P arrow.double P$, que también es llamado *eliminación de la doble
negación*.
En la teoría de tipos, el tipo $not not A$ es el tipo de funciones 
$ (A arrow emptyset) arrow emptyset. $
Este tipo es muy distinto del tipo $A$, y con las reglas de la teoría de tipos no 
es posible construir una función $not not A arrow A$ a menos que sepamos más cosas 
sobre $A$. 
</Aside>
</div>

En la siguiente proposición mostramos como trabajar con la definición de la negación.

<div id="proposicion-4-3-4"> 
<Aside type="tip" title="Proposición 4.3.4" >
Para cualesquiera dos tipos $P$ y $Q$, hay una función 
$ (P arrow Q) arrow (not Q arrow not P) $ 

_Demostración._ La función deseada es definida por $lambda$-abstracción, así que 
empezamos asumiendo que tenemos una función $f: P arrow Q$. Luego, tenemos que 
construir una función $not Q arrow not P$, que también es construida mediante 
$lambda$-abstracción. Asumimos que tenemos $tilde(q): not Q$. Por nuestra definición
de $not Q$, $tilde(q)$ es una función $Q arrow emptyset$. Ahora debemos construir
un término de tipo $not P$, que es el tipo de funciones $P arrow emptyset$.
Aplicamos $lambda$-abstracción una vez más, así que asumimos $p: P$. Ahora tenemos 

```typst
#table(
  stroke: none,
  columns: 1,
  $f: P arrow Q$,
  $tilde(q): Q arrow emptyset$,
  $p: P,$
)
```

Como tenemos $f: P arrow Q$ y $p: P$, obtenemos $f(p): Q$. También, tenemos 
$tilde(q): Q arrow emptyset$, así obtenemos $tilde(q)(f(p)): emptyset$. Esto completa
la prueba. La función que construimos es 
$ lambda f. lambda tilde(q). lambda p. tilde(q)(f(p)): (P arrow Q) arrow (not Q arrow not P) $
</Aside>
</div>

## Co-productos

<div id="definicion-4-4-1">
<Aside type="tip" title="Definición 4.4.1">
Sean $A$ y $B$ tipos. Definimos el *co-producto+ $A + B$ como un tipo que viene 
equipado con 

```typst
#table(
  stroke: none,
  columns: 1,
  $"inl": A arrow A + B$,
  $"inr": B arrow A + B,$
)
```
que satisface el principio de inducción que dice que para cada familia de 
tipos $P(x)$ indizada por $x: A + B$, existe un término 

$ "ind"_+ : (Pi_((x: A)) P("inl"(x))) arrow ((Pi_((y: B)) P("inr"(y))) arrow Pi_((z: A + B)) P(z))$

para el cual las reglas de computación 

```typst
#table(
  stroke: none,
  columns: 1,
  $"ind"_+ (f, g, "inl"(x)) equiv f(x)$,
  $"ind"_+ (f, g, "inr"(y)) equiv g(x)$
)
```
se cumplen. Alternativamente, una definición de una función dependiente 
$h: Pi_((x: A + B)) P(x)$ por inducción usando $f: Pi_((x: A)) P("inl"(x))$ y 
$g: Pi_((y: B)) P("inr"(y))$ puede presentarse vía patrones como 

$ h("inl"(x)) := f(x)  $
$ h("inr"(y)) := g(y). $

A veces escribimos $[f, g]$ en lugar de la función $"ind"_+ (f, g)$. El co-producto de
dos tipos es también llamado *suma disjunta*.
</Aside>
</div>

Por el principio de inducción para co-productos, obtenemos una función 

$ "ind"_+ : (A arrow X) arrow ((B arrow X) arrow (A + B arrow X)) $

para cualquier tipo $X$. Notemos que este caso especial del principio de inducción 
para co-productos es muy similar a la regla de eliminación de la disyunción en
la lógica de primer orden: si $P$, $P'$ y $Q$ son proposiciones, entonces 
$ (P arrow Q) arrow ((P' arrow Q) arrow (P or P' arrow Q)) $
En efecto, podemos pensar en las _proposiciones como tipos_ y los términos como 
sus demostraciones constructivas. Bajo esta interpretación el co-producto es de hecho
la disyunción.

<div id="observacion-4-4-2">
<Aside type="note" title="Observación 4.4.2">
Una aplicación simple del principio de inducción para co-productos nos da un mapa 
$ f + g : A + B arrow A' + B' $
para cada $f: A arrow A'$ y $g: B arrow B'$. En efecto, el mapa $f + g$ se define 
como

```typst
#table(
  stroke: none,
  columns: 1,
  $(f + g)("inl"(x)) := "inl"(f(x))$,
  $(f + g)("inr"(y)) := "inr"(g(x))$
)
```

</Aside>
</div>

<div id="proposicion-4-4-3">
<Aside title="Proposición 4.4.3">
Consideremos dos tipos $A$ y $B$ y supongamos que $B$ es vacío. Entonces hay una 
función 
$ (A + B) arrow A. $

_Demostración._ Construiremos la función $(A + B) arrow A$ con el principio de 
inducción para el co-producto $A + B$. Así, necesitamos construir dos funciones 

```typst
#table(
  stroke: none,
  columns: 1,
  $f: A arrow A$,
  $g: B arrow A$
)
```
La función $f$ es simplemente la identidad $id_A : A arrow A$ y, como asumimos que 
$B$ es vacío, entonces tenemos una función $tilde(b): B arrow emptyset$, además,
siempre tenemos la función $"ex-falso": emptyset arrow A$. Entonces podemos definir
$g = "ex-falso" compose tilde(b)$ para completar la prueba.
</Aside>
</div>

## El tipo de los enteros
El conjunto de los enteros usualmente se define como un cociente sobre el conjunto 
$NN times NN$, por la relación de equivalencia 
$ ((n, m) tilde (n', m')) := (n + m', n' +m). $
El problema es que no hay tipos cociente en la teoría de tipos dependientes de 
Martin-Löf. 

<div id="definicion-4-5-1">
<Aside type="tip" title="Definición 4.5.1">
Definimos a los *enteros* como el tipo $ZZ := NN + (bold(1) + NN)$. El tipo 
de los enteros viene equipado con las funciones inclusión de los enteros positivos 
y negativos.

```typst
#table(
  stroke: none,
  columns: 1,
  $"in-pos":= "inr" compose "inr" : NN arrow ZZ$,
  $"in-neg":= "inl" : NN arrow ZZ $
)
```
y con las constantes

```typst
#table(
  stroke: none,
  columns: 1,
  $-1_ZZ := "in-neg"(0_NN)$,
  $0_ZZ := "inr"("inl"(star))$,
  $1_ZZ := "in-pos"(0_NN)$
)
```
</Aside>
</div>

La definición de los enteros como el co-producto $NN + (bold(1) + NN)$ pude 
representarse visualmente como sigue:

```typst
#import "@preview/fletcher:0.5.8" as fletcher: diagram, node, edge

#diagram(
  $ 
    & bold(1) edge("dr", ->) & & NN edge("dl", ->) \
    NN edge("dr", ->) & & bold(1) + NN edge("dl", ->) & \
    & ZZ & & 
  $
)
```

<div id="observacion-4-5-2">
<Aside type="note" title="Observación 4.5.2">
El tipo de los enteros es construido enteramente a partir de tipos inductivos, de 
modo que es posible derivar un principio de inducción para él, que se puede usar 
para definir las operaciones básicas sobre $ZZ$, como el mapa sucesor, adición y 
multipicación. Este principio de inducción afirma que para cualquier familia de tipos
$P$ sobre $ZZ$, podemos definir una función dependiente $f: Pi_((k: ZZ)) P(k)$
recursivamente por 

```typst
#table(
  stroke: none,
  columns: 1,
  $f(-1_ZZ) := p_(-1)$,
  $f("in-neg"("succ"_NN (n))) := p_(-S)(n, f("in-neg"(n)))$,
  $f(0_ZZ) := p_0$,
  $f(1_ZZ) := p_1$,
  $f("in-pos"("succ"_NN (n))) := p_S (n, f("in-pos"(n))),$
)
```
donde los tipos de $p_(-1), p_(-S), p_0, p_1$ y $p_S$ son

```typst
#table(
  stroke: none,
  columns: 1,
  $f(-1_ZZ) : P(-1_ZZ)$,
  $f("in-neg"("succ"_NN (n))) : Pi_((n: NN)) P("in-neg"(n)) arrow P("in-neg"("succ"_NN (n)))$,
  $f(0_ZZ) : P(0_ZZ)$,
  $f(1_ZZ) : P(1_ZZ)$,
  $f("in-pos"("succ"_NN (n))) : Pi_((n: NN)) P("in-pos"(n)) arrow P("in-pos"("succ"_NN (n))).$
)
```
</Aside>
</div>

<div id="definicion-4-5-3">
<Aside type="tip" title="Definición 4.5.3">
Definimos la *función sucesor* en los enteros $"succ"_ZZ : ZZ arrow ZZ$ usando el 
principio de inducción de la observación [4.5.2](#observacion-4-5-2), tomando 

```typst
#table(
  stroke: none,
  columns: 1,
  $"succ"_ZZ (-1_ZZ) := 0_ZZ$,
  $"succ"_ZZ ("in-neg"("succ"_NN (n))) := "in-neg"(n)$,
  $"succ"_ZZ (0_ZZ) := "in-pos"(1_NN)$,
  $"succ"_ZZ ("in-pos"("succ"_NN (n))) := "in-pos"("succ"_NN (n)).$
)
```
</Aside>
</div>

## Tipos par dependiente 

Dada una familia de tipos $B$ sobre $A$, podemos considerar las parejas $(a,b)$ de 
términos, donde $a: A$ y $b: B(a)$. Notemos que el tipo de $b$ depende de el primer 
término en el par. Así, llamamos a un par así un *par dependiente* El tipo de este 
tipo de pares es el tipo inductivo generado por los pares dependientes.

<div id="definicion-4-6-1">
<Aside type="tip" title="Definición 4.6.1">
Consideremos una familia de tipos $B$ sobre $A$. El *tipo par dependiente* o *$Sigma$-tipo* se define como el tipo inductivo $Sigma_((x: A)) B(x)$ equipado con una 
*función de emparejamiento*

$ "pair" : Pi_((x: A)) ( B(x) arrow Sigma_((y: A)) B(y)). $
</Aside>
</div>

El principio de inducción para $Sigma_((x: A)) B(x)$ afirma que para cualquier 
familia de tipos $P(p)$ indizada por $p: Sigma_((x: A)) B(x)$, hay una función 
$ "ind"_Sigma : (Pi_((x: A)) Pi_((y: B(x))) P ("pair"(x,y))) arrow (Pi_((z: Sigma_((x: A))))  P(z) ) $
que satisface la regla de computación 
$ "ind"_Sigma (g, "pair"(x,y)) equiv g(x,y). $
Alternativamente, una definición de una función dependiente
$f: Pi_((z: Sigma_((x: A)))) P(z) $ pude presentarse vía patrones como 
$ f("pair"(x,y)) := g(x,y). $
usualmente escribimos $(x,y)$ en lugar de $"pair"(x,y)$.

El principio de inducción para $Sigma$-tipos puede usarse para definir las funciones
proyección

<div id="definicion-4-6-2">
<Aside type = "tip" title = "Definición 4.6.2">
Consideremos un tipo $A$ y una familia de tipos $B$ sobre $A$.

1. La *función primera proyección* $ "pr"_1 : (Sigma_((x: A)) B(x)) arrow A $ se define
  por inducción como $ "pr"_1 (x, y) := x. $
2. La *función segunda proyección* es una función dependiente
  $ "pr"_2 : Pi_((p: Sigma_((x: A)) B(x))) B("pr"_1 (p)), $
  se define por inducción como $ "pr"_2 (x, y) := y. $
</Aside>
</div>

<div id="observacion-4-6-3">
<Aside type = "note" title = "Observación 4.6.3">
Si queremos construir una función $ f: Pi_((z: Sigma_((x: A)) B(x))) P(z) $
por $Sigma$-inducción, entonces debemos asumir un par $(x, y)$ consistente de $x: A$ y 
$y: B(x)$ y nuestra meta es construir un elemento de tipo $P(x, y)$. El principio de 
inducción para $Sigma$-tipos es entonces el recíproco de la *operación de currying*,
un concepto familiar de la teoría de lenguajes de programación, que está dado por la 
función 
$ "ev-pair": ( Pi_((z: Sigma_((x: A)) B(x) )) P(z) ) arrow (Pi_((x: A)) Pi_((y: B(x))) P(x, y)) $
dada por $f mapsto lambda x. lambda y. f(x,y)$. El principio de inducción $"ind"_Sigma$
es entonces conocido como la operación de *des-curryficación*.
</Aside>
</div>

Un caso especial muy común de $Sigma$-tipo ocurre cunado $B$ es una familia constante 
sobre $A$, i.e., cuando $B$ es sólo un tipo debilitado por $A$. En este caso, el tipo 
$Sigma_((x: A)) B$ es el tipo de _pares ordinarios_ $(x, y)$ donde $x: A$ y $y: B$, 
aquí, el tipo de $y$ no depende de $x$. El tipo de pares ordinarios $(x, y)$ que 
consiste de $x: A$ y $y: B$ es por supuesto el _producto_ de $A$ y $B$, así que 
los tipos productos aparecen com un caso especial de los $Sigma$-tipos, de la misma 
manera en la que los tipos función fueron definidos como un caso especial de los 
$Pi$-tipos.

<div id="definicion-4-6-4">
<Aside type = "tip" title = "Definción 4.6.4">
Consideremos dos tipos $A$ y $B$. Entonces podemos definir el *producto cartesiano*
$A times B$ de $A$ y $B$ como $ A times B := Sigma_((x: A)) B. $
</Aside>
</div>

<div id="observacion-4-6-5">
<Aside type = "note" title = "Observación 4.6.5">
Como $A times B$ es definido como un $Sigma$-tipo, se sigue el los productos
cartesianos también satisfacen el principio de inducción para $Sigma$-tipos. En este 
caso especial, el principio de inducción para $A times B$ deice que para cada familia 
de tipos $P$ sobre $A times B$ hay una función 
$ "ind"_times : (Pi_((x: A)) Pi_((y: B)) P(x,y)) arrow (Pi_((z: A times B)) P(z)) $
que satisface la regla de computación 
$ "ind"_times (g, (x, y)) equiv g(x, y). $
</Aside>
</div>
Los mapas de proyección se definen de manera similar a los mapas de proyección para los
$Sigma$-tipos. Cuando uno piensa en proposiciones, el tipo $A times B$ es interpretado 
como la conjunción de $A$ y $B$.












