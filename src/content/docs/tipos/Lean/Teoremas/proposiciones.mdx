--- 
title: Proposiciones y pruebas 
sidebar: 
  order: 3
---

## Proposiciones como tipos 
Hay al menos dos maneras de pensar a las proposiciones como tipos. Para la primera, una 
proposición $p$ representa un cierto tipo de dato, a saber, una especificación del tipo de 
datos que constituye una prueba. Una prueba de $p$ es simplemente un objeto $t : p$ del 
tipo correcto. Para la segunda, pensamos esto como un truco, si $p$ es falsa entonces 
es un tipo vacío y si es verdadera, tiene un elemento $star$. Sea da el caso de que las 
reglas de la aplicación de funciones y la abstracción nos permiten llevar las cuentas de 
qué proposiciones están habitadas. Así, construir un elemento $t : P$ nos dice que $p$ 
es verdadera. 

Estas dos maneras de pensar las proposiciones como tipos difieren en una manera fundamental.
Desde el punto de vista constructivo, las demostraciones son objetos matemáticos *denotados*
por expresiones adecuadas en la teoría de tipos. Si lo pensamos como un mero truco, las 
expresiones no cargan consigo nada interesante. 

En cualquier caso, para expresar una afirmación matemática en la teoría de tipos, 
necesitamos exhibir un término $p : "Prop"$. Para probar la afirmación, necesitamos exhibir 
un término $t : p$.

## Trabajando con las proposiciones como tipos 
En el paradigma de las proposiciones como tipos, los teoremas que sólo involucran $arrow$ 
pueden demostrarse usando lambda abstracción y aplicación. En Lean, el comando `theorem` 
introduce un nuevo teorema 

```code :language lean4 :eval true 
variable {p q : Prop}

theorem t1 : p \to q \to p := 
  fun hp : p => fun hq : q => hp

#check t1 
```
Comparemos esta demostración con la expresión `fun x : \alpha => fun y : \beta => x` de tipo 
$alpha arrow beta arrow alpha$, donde $alpha$ y $beta$ son tipos de datos. Esto describe 
la función que toma $x$ y $y$ de tipos $alpha$ y $beta$, respectivamente y regresa $x$.
La demostración de $t 1$ tiene la misma forma, solo que $p$ y $q$ son de tipo `Prop` en 
lugar de `Type`. Intuitivamente, nuestra demostración de $p arrow q arrow p$ asume que 
$p$ y $q$ son verdaderas y usa la primer hipótesis para establecer la conclusión, p es 
verdadera.

Notemos que el comando `theorem` es realmente una versión de `def`.

Como con las definiciones, el comando `#print` muestra la prueba de un teorema: 

```code :language lean4 :eval true 
variable {p q : Prop}

theorem t1 : p \to q \to p := 
  fun hp : p => fun hq : q => hp 

#print t1
```
Notemos que las lambda abstracciones $h p : p$ y $h q : q$ pueden verse como suposiciones 
temporales en la prueba de $t 1$. Lean también permite especificar el tipo del término final 
$h p$ explícitamente con el enunciado `show`:

```code :language lean4 :eval true 
variable {p q : Prop}

theorem t1 : p \to q \to p := 
  fun hp : p => 
  fun hq : q =>
  show p from hp
```
Como con las definiciones, podemos mover las variables del lado izquierdo de los dos puntos:

```code :language lean4 :eval true 
variable {p q : Prop}

theorem t1 (hp : p) (hq : q) : p := hp

#print t1

```
Podemos usar $t 1$ como cualquier otra función: 

```code :language lean4 :eval true 
variable {p q : Prop}

theorem t1 (hp : p) (hq : q) : p := hp

axiom hp : p 

theorem t2 : q \to p := t1 hp
```

La declaración `axiom` postula la existencia de un elemento de un tipo dado y puede 
comprometer la consistencia lógica. Por ejemplo, podemos hacer: 

```code :language lean4 :eval true 
Faxiom unsound : False 

theorem ex : 1 = 0 := 
  False.elim unsound
```

Recordemos aquí que el principio de eliminación (inducción) para el tipo vacío 
(es decir, `False`) nos dice que para cada familia de tipos $P$ indizada por 
$x : emptyset$ (es decir, `False`), existe una función

$ "ind" _emptyset : Pi_((x : emptyset)) P(x), $

de modo que, si tomamos a $P$ como una familia constante $A$, obtenemos un elemento 

$ "ex-falso" := "ind" _emptyset : emptyset arrow A.$

Así, cuando escribimos `False.elim` en Lean, no estamos haciendo más que referirnos a la 
función $"ind" _emptyset$. Para más información se puede consultar 
[tipos inductivos](/tipos/rijke/inductivo#definicion-4-3-1)

## Conjunción 
La expresión `And.intro h1 h2` construye una prueba de `p \land q` usando pruebas `h1 : p`
y `h2 : q`. Observemos que `And.intro` no es más que el principio de introducción para 
el tipo producto no dependiente (o $Sigma$-tipo no dependiente).
En pocas palabras, este principio nos dice que si tenemos tipos $A$ y $B$ y términos $a : A$ 
y $b : B$, podemos introducir el elemento $(a, b) : A times B$. Se puede aprender más sobre 
el tema aquí [tipos inductivos](/tipos/rijke/inductivo#definicion-4-6-1)

