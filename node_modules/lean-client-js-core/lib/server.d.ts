import { AllHoleCommandsRequest, AllHoleCommandsResponse, AllMessagesResponse, CheckingMode, CommandResponse, CompleteRequest, CompleteResponse, CurrentTasksResponse, FileRoi, HoleCommandsRequest, HoleCommandsResponse, HoleRequest, HoleResponse, InfoRequest, InfoResponse, Request, RoiRequest, SymbolRequest, SymbolResponse, SearchRequest, SearchResponse, SyncRequest, WidgetEventRequest, WidgetEventResponse, GetWidgetRequest, GetWidgetResponse } from './commands';
import { Event } from './event';
import { Connection, Transport, TransportError } from './transport';
export interface UnrelatedError {
    error: 'unrelated';
    message: string;
}
export declare type ServerError = TransportError | UnrelatedError;
export declare class Server {
    transport: Transport;
    jsonMessage: Event<any>;
    error: Event<ServerError>;
    allMessages: Event<AllMessagesResponse>;
    tasks: Event<CurrentTasksResponse>;
    logMessagesToConsole: boolean;
    private currentSeqNum;
    private conn?;
    private currentMessages;
    private sentRequests;
    constructor(transport: Transport);
    connect(): void;
    restart(): void;
    send(req: InfoRequest): Promise<InfoResponse>;
    send(req: GetWidgetRequest): Promise<GetWidgetResponse>;
    send(req: WidgetEventRequest): Promise<WidgetEventResponse>;
    send(req: CompleteRequest): Promise<CompleteResponse>;
    send(req: SyncRequest): Promise<CommandResponse>;
    send(req: RoiRequest): Promise<CommandResponse>;
    send(req: Request): Promise<CommandResponse>;
    send(req: SymbolRequest): Promise<SymbolResponse>;
    send(req: SearchRequest): Promise<SearchResponse>;
    send(req: HoleCommandsRequest): Promise<HoleCommandsResponse>;
    send(req: AllHoleCommandsRequest): Promise<AllHoleCommandsResponse>;
    send(req: HoleRequest): Promise<HoleResponse>;
    info(file: string, line: number, column: number): Promise<InfoResponse>;
    sync(file: string, contents: string): Promise<CommandResponse>;
    complete(file: string, line: number, column: number, skipCompletions?: boolean): Promise<CompleteResponse>;
    symbols(file_name: string): Promise<SymbolResponse>;
    search(query: string): Promise<SearchResponse>;
    allHoleCommands(file: string): Promise<AllHoleCommandsResponse>;
    holeCommands(file: string, line: number, column: number): Promise<HoleCommandsResponse>;
    hole(file: string, line: number, column: number, action: string): Promise<HoleResponse>;
    roi(mode: CheckingMode, files: FileRoi[]): Promise<CommandResponse>;
    alive(): boolean;
    dispose(): void;
    /** Creates a Transport that utilises the same Connection as this server (but without seq_num clashes).
     * This is useful if you have a need for multiple `Server` objects using the same underlying lean process.
     * This happens, for example, in the vscode extension where there is a Server instance in the InfoView
     * and a Server instance in the extension.
     */
    makeProxyTransport(): Transport;
    private onMessage(msg);
}
export declare class ProxyConnection implements Connection {
    private parent;
    error: Event<TransportError>;
    jsonMessage: Event<any>;
    private subscriptions;
    constructor(parent: Server);
    readonly alive: boolean;
    send(jsonMsg: any): Promise<void>;
    dispose(): void;
}
