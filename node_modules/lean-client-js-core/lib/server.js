"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const event_1 = require("./event");
class Server {
    constructor(transport) {
        this.transport = transport;
        this.jsonMessage = new event_1.Event();
        this.error = new event_1.Event();
        this.allMessages = new event_1.Event();
        this.tasks = new event_1.Event();
        this.logMessagesToConsole = false;
        this.currentSeqNum = 0;
        this.currentMessages = [];
        this.sentRequests = new Map();
        this.jsonMessage.on((msg) => this.onMessage(msg));
    }
    connect() {
        this.conn = this.transport.connect();
        this.conn.jsonMessage.on((msg) => this.jsonMessage.fire(msg));
        this.conn.error.on((msg) => this.error.fire(msg));
    }
    // TODO(gabriel): restore roi & files on restart?
    restart() {
        this.dispose();
        this.connect();
    }
    send(req) {
        if (!this.alive()) {
            return new Promise((resolve, reject) => reject('server is not alive'));
        }
        if (this.logMessagesToConsole) {
            console.log('=> server: ', req);
        }
        req.seq_num = this.currentSeqNum++;
        const promise = new Promise((resolve, reject) => this.sentRequests.set(req.seq_num, { resolve, reject }));
        this.conn.send(req);
        return promise;
    }
    info(file, line, column) {
        return this.send({ command: 'info', file_name: file, line, column });
    }
    sync(file, contents) {
        return this.send({ command: 'sync', file_name: file, content: contents });
    }
    complete(file, line, column, skipCompletions) {
        return this.send({ command: 'complete', file_name: file, line, column,
            skip_completions: skipCompletions || false });
    }
    symbols(file_name) {
        return this.send({ command: 'symbols', file_name });
    }
    search(query) {
        return this.send({ command: 'search', query });
    }
    allHoleCommands(file) {
        return this.send({ command: 'all_hole_commands', file_name: file });
    }
    holeCommands(file, line, column) {
        return this.send({ command: 'hole_commands', file_name: file, line, column });
    }
    hole(file, line, column, action) {
        return this.send({ command: 'hole', file_name: file, line, column, action });
    }
    roi(mode, files) {
        return this.send({ command: 'roi', files, mode });
    }
    alive() {
        return this.conn && this.conn.alive;
    }
    dispose() {
        if (this.conn) {
            this.conn.dispose();
            this.sentRequests.forEach((info, seqNum) => info.reject('disposed'));
            this.sentRequests.clear();
            this.currentSeqNum = 0;
            this.conn = null;
        }
    }
    /** Creates a Transport that utilises the same Connection as this server (but without seq_num clashes).
     * This is useful if you have a need for multiple `Server` objects using the same underlying lean process.
     * This happens, for example, in the vscode extension where there is a Server instance in the InfoView
     * and a Server instance in the extension.
     */
    makeProxyTransport() {
        return {
            connect: () => new ProxyConnection(this),
        };
    }
    onMessage(msg) {
        if (this.logMessagesToConsole) {
            console.log('<= server: ', msg);
        }
        const reqInfo = this.sentRequests.get(msg.seq_num); // undefined if msg.seq_num does not exist
        if (reqInfo !== undefined) {
            this.sentRequests.delete(msg.seq_num);
            if (msg.response === 'ok') {
                reqInfo.resolve(msg);
            }
            else {
                reqInfo.reject(msg.message || msg);
            }
        }
        else if (msg.response === 'all_messages') {
            const allMsgRes = msg;
            this.currentMessages = allMsgRes.msgs;
            this.allMessages.fire(allMsgRes);
        }
        else if (msg.response === 'additional_message') {
            const addMsgRes = msg;
            this.currentMessages = this.currentMessages.concat([addMsgRes.msg]);
            this.allMessages.fire({
                response: 'all_messages',
                msgs: this.currentMessages,
            });
        }
        else if (msg.response === 'current_tasks') {
            this.tasks.fire(msg);
        }
        else {
            // unrelated error
            this.error.fire({ error: 'unrelated', message: msg.message || JSON.stringify(msg) });
        }
    }
}
exports.Server = Server;
class ProxyConnection {
    constructor(parent) {
        this.parent = parent;
        this.error = new event_1.Event();
        this.jsonMessage = new event_1.Event();
        this.subscriptions = [];
        this.subscriptions.push(this.error, this.jsonMessage, this.parent.jsonMessage.on((x) => x.seq_num || this.jsonMessage.fire(x)), this.parent.error.on((x) => this.error.fire(x.error == 'unrelated' ? Object.assign({}, x, { error: 'connect' }) : x)));
    }
    get alive() { return this.parent.alive(); }
    send(jsonMsg) {
        return __awaiter(this, void 0, void 0, function* () {
            const seq_num = jsonMsg.seq_num;
            try {
                const result = yield this.parent.send(jsonMsg);
                this.jsonMessage.fire(Object.assign({}, result, { seq_num }));
            }
            catch (msg) {
                const res = { response: 'error', message: msg, seq_num };
                this.jsonMessage.fire(res);
            }
        });
    }
    dispose() {
        for (const s of this.subscriptions) {
            s.dispose();
        }
    }
}
exports.ProxyConnection = ProxyConnection;
