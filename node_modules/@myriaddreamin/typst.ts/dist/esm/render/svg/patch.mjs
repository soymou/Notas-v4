/// Semantic attributes attached to SVG elements.
var TypstSvgAttrs;
(function (TypstSvgAttrs) {
    /// The data-tid attribute is used to identify the element.
    /// It is used to compare two elements.
    ///
    /// At most time, the data-tid is exactly their content hash.
    /// A disambiguation suffix is added when the content hash is not unique.
    TypstSvgAttrs["Tid"] = "data-tid";
    /// The data-reuse attribute is used to this element is reused from specified element.
    /// The attribute content is the data-tid of the element.
    TypstSvgAttrs["ReuseFrom"] = "data-reuse-from";
})(TypstSvgAttrs || (TypstSvgAttrs = {}));
/// Predicate that a xml element is a `<g>` element.
function isGElem(node) {
    return node.tagName === 'g';
}
/// Compare two elements by their data-tid attribute.
function equalElem(prev, next) {
    const prevDataTid = prev.getAttribute(TypstSvgAttrs.Tid);
    const nextDataTid = next.getAttribute(TypstSvgAttrs.Tid);
    return prevDataTid && prevDataTid === nextDataTid;
}
/// Interpret the transform between origin sequence and target sequence.
export function interpretTargetView(originChildren, targetChildren, tIsU = (_x) => true) {
    const availableOwnedResource = new Map();
    const targetView = [];
    for (let i = 0; i < originChildren.length; i++) {
        const prevChild = originChildren[i];
        if (!tIsU(prevChild)) {
            continue;
        }
        const data_tid = prevChild.getAttribute(TypstSvgAttrs.Tid);
        if (!data_tid) {
            targetView.push(['remove', i]);
            continue;
        }
        if (!availableOwnedResource.has(data_tid)) {
            availableOwnedResource.set(data_tid, [prevChild, []]);
        }
        availableOwnedResource.get(data_tid)[1].push(i);
    }
    const toPatch = [];
    for (let i = 0; i < targetChildren.length; i++) {
        const nextChild = targetChildren[i];
        if (!tIsU(nextChild)) {
            continue;
        }
        const nextDataTid = nextChild.getAttribute(TypstSvgAttrs.Tid);
        if (!nextDataTid) {
            throw new Error('not data tid for reusing g element for ' + nextDataTid);
        }
        const reuseTargetTid = nextChild.getAttribute(TypstSvgAttrs.ReuseFrom);
        if (!reuseTargetTid) {
            targetView.push(['append', nextChild]);
            continue;
        }
        if (!availableOwnedResource.has(reuseTargetTid)) {
            throw new Error('no available resource for reuse ' + reuseTargetTid);
        }
        const rsrc = availableOwnedResource.get(reuseTargetTid);
        const prevIdx = rsrc[1].shift();
        /// no available resource
        if (prevIdx === undefined) {
            /// clean one is reused directly
            if (nextDataTid === reuseTargetTid) {
                const clonedNode = rsrc[0].cloneNode(true);
                toPatch.push([clonedNode, nextChild]);
                targetView.push(['append', clonedNode]);
            }
            else {
                targetView.push(['append', nextChild]);
            }
            continue;
        }
        /// dirty one should be patched and reused
        toPatch.push([originChildren[prevIdx], nextChild]);
        targetView.push(['reuse', prevIdx]);
    }
    for (let [_, unusedIndices] of availableOwnedResource.values()) {
        for (let unused of unusedIndices) {
            targetView.push(['remove', unused]);
        }
    }
    return [targetView, toPatch];
}
/// Change a sequence of target view instructions to the origin ones.
/// Currently, it applies a greedy strategy.
/// + First, it applies all remove instructions.
/// + Then, it applies the swap ones.
/// + Finally, it inserts the extra elements.
///
/// Some better strategy would help and be implemented in future.
export function changeViewPerspective(originChildren, targetView, tIsU = (_x) => true) {
    const originView = [];
    /// see remove instructions
    let removeIndices = [];
    for (let inst of targetView) {
        if (inst[0] === 'remove') {
            removeIndices.push(inst[1]);
        }
    }
    removeIndices = removeIndices.sort((a, b) => a - b);
    const removeShift = [];
    /// apply remove instructions and get effect
    {
        let r = 0;
        for (let i = 0; i < removeIndices.length; i++) {
            while (r < removeIndices[i]) {
                removeShift.push(r - i);
                r++;
            }
            removeShift.push(undefined);
            originView.push(['remove', removeIndices[i] - i]);
            r++;
        }
        while (r <= originChildren.length) {
            removeShift.push(r - removeIndices.length);
            r++;
        }
    }
    // console.log(removeIndices, removeShift);
    /// get shift considering remove effects
    const getShift = (off) => {
        if (off >= removeShift.length || removeShift[off] === undefined) {
            throw new Error(`invalid offset ${off} for getShift ${removeShift}`);
        }
        return removeShift[off];
    };
    /// variables used by `interpretOriginView`
    /// scanning the target view
    let targetViewCursor = 0;
    /// the append effect
    let appendOffset = 0;
    /// converted append instructions.
    const swapIns = [];
    /// converted append instructions.
    const inserts = [];
    /// apply append and reuse instructions till the offset of origin sequence.
    const interpretOriginView = (off) => {
        // console.log(off, getShift(off));
        off = getShift(off);
        while (targetViewCursor < targetView.length) {
            let done = false;
            const inst = targetView[targetViewCursor];
            switch (inst[0]) {
                case 'append':
                    inserts.push(['insert', appendOffset, inst[1]]);
                    appendOffset++;
                    break;
                case 'reuse':
                    const target_off = getShift(inst[1]);
                    swapIns.push(target_off);
                    appendOffset++;
                    break;
                // case "remove":
                default:
                    break;
            }
            targetViewCursor++;
            if (done) {
                break;
            }
        }
    };
    /// scanning the origin view
    for (let off = 0; off < originChildren.length; off++) {
        const prevChild = originChildren[off];
        if (removeShift[off] === undefined) {
            continue;
        }
        // keep position of unpredictable elements
        if (!tIsU(prevChild)) {
            const target_off = getShift(off);
            swapIns.push(target_off);
            continue;
        }
        interpretOriginView(off);
    }
    interpretOriginView(originChildren.length);
    const simulated = [];
    for (let i = 0; i < swapIns.length; i++) {
        simulated.push(i);
    }
    for (let i = 0; i < swapIns.length; i++) {
        const off = swapIns[i];
        for (let j = 0; j < simulated.length; j++) {
            if (simulated[j] === off) {
                // console.log("swap_in", j, i, simulated);
                simulated.splice(j, 1);
                if (i <= j) {
                    simulated.splice(i, 0, off);
                }
                else {
                    simulated.splice(i + 1, 0, off);
                }
                if (j !== i) {
                    originView.push(['swap_in', i, j]);
                    // console.log("swap_in then", j, i, simulated);
                }
                break;
            }
        }
    }
    return [...originView, ...inserts];
}
function runOriginViewInstructions(prev, originView) {
    // console.log("interpreted origin view", originView);
    for (const [op, off, fr] of originView) {
        switch (op) {
            case 'insert':
                prev.insertBefore(fr, prev.children[off]);
                break;
            case 'swap_in':
                prev.insertBefore(prev.children[fr], prev.children[off]);
                break;
            case 'remove':
                prev.children[off].remove();
                break;
            default:
                throw new Error('unknown op ' + op);
        }
    }
}
/// End of View Interpretation
/// Begin of Recursive Svg Patch
/// Patch the `prev <svg>` in the DOM according to `next <svg>` from the backend.
export function patchRoot(prev, next) {
    /// Patch attributes
    patchAttributes(prev, next);
    /// Patch global svg resources
    patchSvgHeader(prev, next);
    /// Patch `<g>` children, call `reuseOrPatchElem` to patch.
    patchChildren(prev, next);
    return;
    function patchSvgHeader(prev, next) {
        for (let i = 0; i < 3; i++) {
            const prevChild = prev.children[i];
            const nextChild = next.children[i];
            // console.log("prev", prevChild);
            // console.log("next", nextChild);
            if (prevChild.tagName === 'defs') {
                if (prevChild.getAttribute('class') === 'glyph') {
                    // console.log("append glyphs:", nextChild.children, "to", prevChild);
                    prevChild.append(...nextChild.children);
                }
                else if (prevChild.getAttribute('class') === 'clip-path') {
                    // console.log("clip path: replace");
                    // todo: gc
                    prevChild.append(...nextChild.children);
                }
            }
            else if (prevChild.tagName === 'style' && nextChild.getAttribute('data-reuse') !== '1') {
                // console.log("replace extra style", prevChild, nextChild);
                // todo: gc
                if (nextChild.textContent) {
                    // todo: looks slow
                    // https://stackoverflow.com/questions/3326494/parsing-css-in-javascript-jquery
                    var doc = document.implementation.createHTMLDocument(''), styleElement = document.createElement('style');
                    styleElement.textContent = nextChild.textContent;
                    // the style will only be parsed once it is added to a document
                    doc.body.appendChild(styleElement);
                    const currentSvgSheet = prevChild.sheet;
                    const rulesToInsert = styleElement.sheet?.cssRules || [];
                    // console.log("rules to insert", currentSvgSheet, rulesToInsert);
                    for (const rule of rulesToInsert) {
                        currentSvgSheet.insertRule(rule.cssText);
                    }
                }
            }
        }
    }
}
/// apply attribute patches to the `prev <svg or g>` element
function patchAttributes(prev, next) {
    const prevAttrs = prev.attributes;
    const nextAttrs = next.attributes;
    if (prevAttrs.length === nextAttrs.length) {
        let same = true;
        for (let i = 0; i < prevAttrs.length; i++) {
            const prevAttr = prevAttrs[i];
            const nextAttr = nextAttrs.getNamedItem(prevAttr.name);
            if (nextAttr === null || prevAttr.value !== nextAttr.value) {
                same = false;
                break;
            }
        }
        if (same) {
            // console.log("same attributes, skip");
            return;
        }
    }
    // console.log("different attributes, replace");
    const removedAttrs = [];
    for (let i = 0; i < prevAttrs.length; i++) {
        removedAttrs.push(prevAttrs[i].name);
    }
    for (const attr of removedAttrs) {
        prev.removeAttribute(attr);
    }
    for (let i = 0; i < nextAttrs.length; i++) {
        prev.setAttribute(nextAttrs[i].name, nextAttrs[i].value);
    }
}
/// apply patches to the children sequence of `prev <svg or g>` in the DOM
function patchChildren(prev, next) {
    const [targetView, toPatch] = interpretTargetView(prev.children, next.children, isGElem);
    for (let [prevChild, nextChild] of toPatch) {
        reuseOrPatchElem(prevChild, nextChild);
    }
    // console.log("interpreted target view", targetView);
    const originView = changeViewPerspective(prev.children, targetView, isGElem);
    runOriginViewInstructions(prev, originView);
}
/// Replace the `prev` element with `next` element.
/// Return true if the `prev` element is reused.
/// Return false if the `prev` element is replaced.
function reuseOrPatchElem(prev, next) {
    const canReuse = equalElem(prev, next);
    /// Even if the element is reused, we still need to replace its attributes.
    next.removeAttribute(TypstSvgAttrs.ReuseFrom);
    patchAttributes(prev, next);
    if (canReuse) {
        return true /* reused */;
    }
    /// Hard replace elements that is not a `<g>` element.
    replaceNonSVGElements(prev, next);
    /// Patch `<g>` children, will call `reuseOrPatchElem` again.
    patchChildren(prev, next);
    return false /* reused */;
    function replaceNonSVGElements(prev, next) {
        const removedIndices = [];
        for (let i = 0; i < prev.children.length; i++) {
            const prevChild = prev.children[i];
            if (!isGElem(prevChild)) {
                removedIndices.push(i);
            }
        }
        for (const index of removedIndices.reverse()) {
            prev.children[index].remove();
        }
        for (let i = 0; i < next.children.length; i++) {
            const nextChild = next.children[i];
            if (!isGElem(nextChild)) {
                prev.appendChild(nextChild.cloneNode(true));
            }
        }
    }
}
/// End of Recursive Svg Patch
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0Y2gubWpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3JlbmRlci9zdmcvcGF0Y2gubXRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLGlEQUFpRDtBQUNqRCxJQUFXLGFBV1Y7QUFYRCxXQUFXLGFBQWE7SUFDdEIsMkRBQTJEO0lBQzNELHVDQUF1QztJQUN2QyxHQUFHO0lBQ0gsNkRBQTZEO0lBQzdELHlFQUF5RTtJQUN6RSxpQ0FBZ0IsQ0FBQTtJQUVoQixzRkFBc0Y7SUFDdEYseURBQXlEO0lBQ3pELDhDQUE2QixDQUFBO0FBQy9CLENBQUMsRUFYVSxhQUFhLEtBQWIsYUFBYSxRQVd2QjtBQUVELG9EQUFvRDtBQUNwRCxTQUFTLE9BQU8sQ0FBQyxJQUFhO0lBQzVCLE9BQU8sSUFBSSxDQUFDLE9BQU8sS0FBSyxHQUFHLENBQUM7QUFDOUIsQ0FBQztBQUVELHFEQUFxRDtBQUNyRCxTQUFTLFNBQVMsQ0FBQyxJQUFpQixFQUFFLElBQWlCO0lBQ3JELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pELE9BQU8sV0FBVyxJQUFJLFdBQVcsS0FBSyxXQUFXLENBQUM7QUFDcEQsQ0FBQztBQXFDRCx3RUFBd0U7QUFDeEUsTUFBTSxVQUFVLG1CQUFtQixDQUNqQyxjQUFtQixFQUNuQixjQUFtQixFQUNuQixPQUFPLENBQUMsRUFBSyxFQUFXLEVBQUUsQ0FBQyxJQUFJO0lBRS9CLE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxHQUFHLEVBQXlCLENBQUM7SUFDaEUsTUFBTSxVQUFVLEdBQStCLEVBQUUsQ0FBQztJQUVsRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVB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QUFTLENBQUMsTUFBTSxLQUFLLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUMxQyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMxQyxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUIsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkQsSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUMzRCxJQUFJLEdBQUcsS0FBSyxDQUFDO2dCQUNiLE1BQU07WUFDUixDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksSUFBSSxFQUFFLENBQUM7WUFDVCx3Q0FBd0M7WUFDeEMsT0FBTztRQUNULENBQUM7SUFDSCxDQUFDO0lBQ0QsZ0RBQWdEO0lBRWhELE1BQU0sWUFBWSxHQUFhLEVBQUUsQ0FBQztJQUVsQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxLQUFLLE1BQU0sSUFBSSxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDMUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzRCxDQUFDO0FBQ0gsQ0FBQztBQUVELDBFQUEwRTtBQUMxRSxTQUFTLGFBQWEsQ0FBQyxJQUFhLEVBQUUsSUFBYTtJQUNqRCxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxHQUFHLG1CQUFtQixDQUMvQyxJQUFJLENBQUMsUUFBb0MsRUFDekMsSUFBSSxDQUFDLFFBQW9DLEVBQ3pDLE9BQU8sQ0FDUixDQUFDO0lBRUYsS0FBSyxJQUFJLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQzNDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsc0RBQXNEO0lBRXRELE1BQU0sVUFBVSxHQUFHLHFCQUFxQixDQUN0QyxJQUFJLENBQUMsUUFBb0MsRUFDekMsVUFBVSxFQUNWLE9BQU8sQ0FDUixDQUFDO0lBRUYseUJBQXlCLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFFRCxtREFBbUQ7QUFDbkQsZ0RBQWdEO0FBQ2hELG1EQUFtRDtBQUNuRCxTQUFTLGdCQUFnQixDQUFDLElBQWlCLEVBQUUsSUFBaUI7SUFDNUQsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUV2QywyRUFBMkU7SUFDM0UsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUMsZUFBZSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUU1QixJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQ2IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzNCLENBQUM7SUFFRCxzREFBc0Q7SUFDdEQscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xDLDZEQUE2RDtJQUM3RCxhQUFhLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFCLE9BQU8sS0FBSyxDQUFDLFlBQVksQ0FBQztJQUUxQixTQUFTLHFCQUFxQixDQUFDLElBQWEsRUFBRSxJQUFhO1FBQ3pELE1BQU0sY0FBYyxHQUFhLEVBQUUsQ0FBQztRQUNwQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM5QyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztnQkFDeEIsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QixDQUFDO1FBQ0gsQ0FBQztRQUVELEtBQUssTUFBTSxLQUFLLElBQUksY0FBYyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoQyxDQUFDO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDOUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzlDLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFFRCw4QkFBOEIiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gVGhlIEVsZW1lbnRDaGlsZHJlbiByZXByZXNlbnRzIGFuIG9iamVjdCBvZiBhIGxpc3Qgb2Ygbm9kZXMuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudENoaWxkcmVuIHtcclxuICB0YWdOYW1lOiBzdHJpbmc7XHJcbiAgZ2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGw7XHJcbiAgY2xvbmVOb2RlKGRlZXA6IGJvb2xlYW4pOiB1bmtub3duO1xyXG59XHJcblxyXG4vLy8gU2VtYW50aWMgYXR0cmlidXRlcyBhdHRhY2hlZCB0byBTVkcgZWxlbWVudHMuXHJcbmNvbnN0IGVudW0gVHlwc3RTdmdBdHRycyB7XHJcbiAgLy8vIFRoZSBkYXRhLXRpZCBhdHRyaWJ1dGUgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgZWxlbWVudC5cclxuICAvLy8gSXQgaXMgdXNlZCB0byBjb21wYXJlIHR3byBlbGVtZW50cy5cclxuICAvLy9cclxuICAvLy8gQXQgbW9zdCB0aW1lLCB0aGUgZGF0YS10aWQgaXMgZXhhY3RseSB0aGVpciBjb250ZW50IGhhc2guXHJcbiAgLy8vIEEgZGlzYW1iaWd1YXRpb24gc3VmZml4IGlzIGFkZGVkIHdoZW4gdGhlIGNvbnRlbnQgaGFzaCBpcyBub3QgdW5pcXVlLlxyXG4gIFRpZCA9ICdkYXRhLXRpZCcsXHJcblxyXG4gIC8vLyBUaGUgZGF0YS1yZXVzZSBhdHRyaWJ1dGUgaXMgdXNlZCB0byB0aGlzIGVsZW1lbnQgaXMgcmV1c2VkIGZyb20gc3BlY2lmaWVkIGVsZW1lbnQuXHJcbiAgLy8vIFRoZSBhdHRyaWJ1dGUgY29udGVudCBpcyB0aGUgZGF0YS10aWQgb2YgdGhlIGVsZW1lbnQuXHJcbiAgUmV1c2VGcm9tID0gJ2RhdGEtcmV1c2UtZnJvbScsXHJcbn1cclxuXHJcbi8vLyBQcmVkaWNhdGUgdGhhdCBhIHhtbCBlbGVtZW50IGlzIGEgYDxnPmAgZWxlbWVudC5cclxuZnVuY3Rpb24gaXNHRWxlbShub2RlOiBFbGVtZW50KTogbm9kZSBpcyBTVkdHRWxlbWVudCB7XHJcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ2cnO1xyXG59XHJcblxyXG4vLy8gQ29tcGFyZSB0d28gZWxlbWVudHMgYnkgdGhlaXIgZGF0YS10aWQgYXR0cmlidXRlLlxyXG5mdW5jdGlvbiBlcXVhbEVsZW0ocHJldjogU1ZHR0VsZW1lbnQsIG5leHQ6IFNWR0dFbGVtZW50KSB7XHJcbiAgY29uc3QgcHJldkRhdGFUaWQgPSBwcmV2LmdldEF0dHJpYnV0ZShUeXBzdFN2Z0F0dHJzLlRpZCk7XHJcbiAgY29uc3QgbmV4dERhdGFUaWQgPSBuZXh0LmdldEF0dHJpYnV0ZShUeXBzdFN2Z0F0dHJzLlRpZCk7XHJcbiAgcmV0dXJuIHByZXZEYXRhVGlkICYmIHByZXZEYXRhVGlkID09PSBuZXh0RGF0YVRpZDtcclxufVxyXG5cclxuLy8vIEJlZ2luIG9mIFZpZXcgSW50ZXJwcmV0YXRpb25cclxuLy8vXHJcbi8vLyAjIyMgVmlld1xyXG4vLy9cclxuLy8vIFRoZSB2aWV3IGlzIGRlZmluZWQgYXMgYSBzdHJ1Y3R1cmUgdG8gZGVzY3JpYmUgdGhlIHN0YXRlIG9mIGEgc2VxdWVuY2UsXHJcbi8vLyBXaGlsZSB0aGUgdmlldyBpbnN0cnVjdGlvbnMgZGVzY3JpYmUgdGhlIGNoYW5nZSBvZiB2aWV3LlxyXG4vLy8gICBUaGF0IGlzLCBHaXZlbiBWLCBWJywgViBiZWNvbWVzIFYnIGFmdGVyIGFwcGx5aW5nIHZpZXcgaW5zdHJ1Y3Rpb25zIGluIG9yZGVyLlxyXG4vLy8gV2UgY2FsbCBWJyB0aGUgdGFyZ2V0IHZpZXcsIGFuZCBWJyB0aGUgb3JpZ2luIHZpZXcuXHJcbi8vL1xyXG4vLy8gIyMjIFZpZXcgSW5zdHJ1Y3Rpb25cclxuLy8vXHJcbi8vLyBJbnRyb2R1Y2VkIHRoZSB0YXJnZXQvb3JpZ2luIHZpZXcsIHRoZXJlIGFyZSB0d28gdHlwZSBvZiBpbnN0cnVjdGlvbnMgdG8gbm90ZTpcclxuXHJcbi8vLyBUaGUgdGFyZ2V0IHZpZXcgaW5zdHJ1Y3Rpb25zIGFyZSBnZW5lcmF0ZWQgYnlcclxuLy8vICAgY29tcGFyaW5nIHdpdGggdGhlIHRhcmdldCB2aWV3IGFuZCBvcmlnaW4gdmlldy5cclxuLy8vIFRoZSBpbnN0cnVjdGlvbiBzZXF1ZW5jZSBzcGVjaWZ5IGhvdyB3ZSBjYW4gZ2VuZXJhdGUgYSB2aWV3IHdpdGggY29uZGl0aW9uczpcclxuLy8vICsgSXQgaXMgZ2VuZXJhdGVkIGZyb20gYSBlbXB0eSBzZXF1ZW5jZS5cclxuLy8vICsgSXQgY2FuIHV0aWxpemUgYSBzZXQgb2YgZWxlbWVudHMgYXMgcmVzb3VyY2VzLlxyXG4vLy9cclxuLy8vIEV4YW1wbGUxOiByZXNvdXJjZTpbXSAtPiA8YXBwZW5kIHQxPiAtPiBbdDFdXHJcbi8vLyBFeGFtcGxlMjogcmVzb3VyY2U6W28xXSAtPiA8cmV1c2UgbzE+IC0+IFtvMV1cclxuLy8vIEV4YW1wbGUzOiByZXNvdXJjZTpbbzFdIC0+IDxyZXVzZSBvMT4gPHJldXNlIG8xPiAtPiBbbzEsIG8xXVxyXG4vLy8gRXhhbXBsZTQ6IHJlc291cmNlOltvMSwgbzJdIC0+IDxyZXVzZSBvMT4gPGFwcGVuZCB0MT4gLT4gW28xLCB0MV1cclxuLy8vXHJcbi8vLyBUbyByZW1vdmUgdW51c2VkIHJlc291cmNlcywgQW4gZXh0cmEgcmVtb3ZlIGluc3QgY2FuIHJlbW92ZSBhIHNwZWNpZnkgZWxlbWVudFxyXG4vLy9cclxuLy8vIEV4YW1wbGU1OiByZXNvdXJjZTpbbzEsIG8yXSAtPiA8cmV1c2UgbzE+IDxhcHBlbmQgdDE+IDxyZW1vdmUgbzI+IC0+IFtvMSwgdDFdIGFuZCByZW1vdmUgbzJcclxuZXhwb3J0IHR5cGUgVGFyZ2V0Vmlld0luc3RydWN0aW9uPFQ+ID0gWydhcHBlbmQnLCBUXSB8IFsncmV1c2UnLCBudW1iZXJdIHwgWydyZW1vdmUnLCBudW1iZXJdO1xyXG5cclxuLy8vIFRoZSByZWN1cnNpdmUgcGF0Y2ggb3BlcmF0aW9uIG11c3QgYmUgYXBwbGllZCB0byB0aGlzIHR3byBlbGVtZW50LlxyXG5leHBvcnQgdHlwZSBQYXRjaFBhaXI8VD4gPSBbVCAvKiBvcmlnaW4gKi8sIFQgLyogdGFyZ2V0ICovXTtcclxuXHJcbi8vLyBJbnRlcnByZXRlZCByZXN1bHQgZm9yIHRyYW5zZm9ybWluZyBvcmlnaW4gc2VxdWVuY2UgdG8gdGFyZ2V0IHNlcXVlbmNlLlxyXG5leHBvcnQgdHlwZSBWaWV3VHJhbnNmb3JtPFU+ID0gW1RhcmdldFZpZXdJbnN0cnVjdGlvbjxVPltdLCBQYXRjaFBhaXI8VT5bXV07XHJcblxyXG4vLy8gSW50ZXJwcmV0IHRoZSB0cmFuc2Zvcm0gYmV0d2VlbiBvcmlnaW4gc2VxdWVuY2UgYW5kIHRhcmdldCBzZXF1ZW5jZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGludGVycHJldFRhcmdldFZpZXc8VCBleHRlbmRzIEVsZW1lbnRDaGlsZHJlbiwgVSBleHRlbmRzIFQgPSBUPihcclxuICBvcmlnaW5DaGlsZHJlbjogVFtdLFxyXG4gIHRhcmdldENoaWxkcmVuOiBUW10sXHJcbiAgdElzVSA9IChfeDogVCk6IF94IGlzIFUgPT4gdHJ1ZSxcclxuKTogVmlld1RyYW5zZm9ybTxVPiB7XHJcbiAgY29uc3QgYXZhaWxhYmxlT3duZWRSZXNvdXJjZSA9IG5ldyBNYXA8c3RyaW5nLCBbVCwgbnVtYmVyW11dPigpO1xyXG4gIGNvbnN0IHRhcmdldFZpZXc6IFRhcmdldFZpZXdJbnN0cnVjdGlvbjxVPltdID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHByZXZDaGlsZCA9IG9yaWdpbkNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKCF0SXNVKHByZXZDaGlsZCkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YV90aWQgPSBwcmV2Q2hpbGQuZ2V0QXR0cmlidXRlKFR5cHN0U3ZnQXR0cnMuVGlkKTtcclxuICAgIGlmICghZGF0YV90aWQpIHtcclxuICAgICAgdGFyZ2V0Vmlldy5wdXNoKFsncmVtb3ZlJywgaV0pO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWF2YWlsYWJsZU93bmVkUmVzb3VyY2UuaGFzKGRhdGFfdGlkKSkge1xyXG4gICAgICBhdmFpbGFibGVPd25lZFJlc291cmNlLnNldChkYXRhX3RpZCwgW3ByZXZDaGlsZCwgW11dKTtcclxuICAgIH1cclxuICAgIGF2YWlsYWJsZU93bmVkUmVzb3VyY2UuZ2V0KGRhdGFfdGlkKSFbMV0ucHVzaChpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRvUGF0Y2g6IFtVLCBVXVtdID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IG5leHRDaGlsZCA9IHRhcmdldENoaWxkcmVuW2ldO1xyXG4gICAgaWYgKCF0SXNVKG5leHRDaGlsZCkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmV4dERhdGFUaWQgPSBuZXh0Q2hpbGQuZ2V0QXR0cmlidXRlKFR5cHN0U3ZnQXR0cnMuVGlkKTtcclxuICAgIGlmICghbmV4dERhdGFUaWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZGF0YSB0aWQgZm9yIHJldXNpbmcgZyBlbGVtZW50IGZvciAnICsgbmV4dERhdGFUaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJldXNlVGFyZ2V0VGlkID0gbmV4dENoaWxkLmdldEF0dHJpYnV0ZShUeXBzdFN2Z0F0dHJzLlJldXNlRnJvbSk7XHJcbiAgICBpZiAoIXJldXNlVGFyZ2V0VGlkKSB7XHJcbiAgICAgIHRhcmdldFZpZXcucHVzaChbJ2FwcGVuZCcsIG5leHRDaGlsZF0pO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmICghYXZhaWxhYmxlT3duZWRSZXNvdXJjZS5oYXMocmV1c2VUYXJnZXRUaWQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYXZhaWxhYmxlIHJlc291cmNlIGZvciByZXVzZSAnICsgcmV1c2VUYXJnZXRUaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJzcmMgPSBhdmFpbGFibGVPd25lZFJlc291cmNlLmdldChyZXVzZVRhcmdldFRpZCkhO1xyXG4gICAgY29uc3QgcHJldklkeCA9IHJzcmNbMV0uc2hpZnQoKTtcclxuXHJcbiAgICAvLy8gbm8gYXZhaWxhYmxlIHJlc291cmNlXHJcbiAgICBpZiAocHJldklkeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vLyBjbGVhbiBvbmUgaXMgcmV1c2VkIGRpcmVjdGx5XHJcbiAgICAgIGlmIChuZXh0RGF0YVRpZCA9PT0gcmV1c2VUYXJnZXRUaWQpIHtcclxuICAgICAgICBjb25zdCBjbG9uZWROb2RlID0gcnNyY1swXS5jbG9uZU5vZGUodHJ1ZSkgYXMgVTtcclxuICAgICAgICB0b1BhdGNoLnB1c2goW2Nsb25lZE5vZGUsIG5leHRDaGlsZF0pO1xyXG4gICAgICAgIHRhcmdldFZpZXcucHVzaChbJ2FwcGVuZCcsIGNsb25lZE5vZGVdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXRWaWV3LnB1c2goWydhcHBlbmQnLCBuZXh0Q2hpbGRdKTtcclxuICAgICAgfVxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gZGlydHkgb25lIHNob3VsZCBiZSBwYXRjaGVkIGFuZCByZXVzZWRcclxuICAgIHRvUGF0Y2gucHVzaChbb3JpZ2luQ2hpbGRyZW5bcHJldklkeF0gYXMgVSwgbmV4dENoaWxkXSk7XHJcbiAgICB0YXJnZXRWaWV3LnB1c2goWydyZXVzZScsIHByZXZJZHhdKTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IFtfLCB1bnVzZWRJbmRpY2VzXSBvZiBhdmFpbGFibGVPd25lZFJlc291cmNlLnZhbHVlcygpKSB7XHJcbiAgICBmb3IgKGxldCB1bnVzZWQgb2YgdW51c2VkSW5kaWNlcykge1xyXG4gICAgICB0YXJnZXRWaWV3LnB1c2goWydyZW1vdmUnLCB1bnVzZWRdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBbdGFyZ2V0VmlldywgdG9QYXRjaF07XHJcbn1cclxuXHJcbi8vLyBUaGUgb3JpZ2luIHZpZXcgaW5zdHJ1Y3Rpb25zIGFyZSBzZW1hbnRpYy1wcmVzZXJ2ZWQgdG8gdGhlIHRhcmdldCBvbmVzLlxyXG4vLy8gVGhlIG1ham9yIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIG9yaWdpbiBvbmVzIGFuZCB0YXJnZXQgb25lcyBhcmUgdGhhdDpcclxuLy8vICsgSXQgY2FuIGJlIGVhc2lseSBhcHBsaWVkIHRvIGEgRE9NIHNlcXVlbmNlXHJcbi8vLyArIEl0IGhhcyBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcbi8vL1xyXG4vLy8gRXhhbXBsZTE6IGRvbTpbbzAsIG8xXSAtPiA8aW5zZXJ0IGF0IDEsIHQxPiAtPiBbbzAsIHQxLCBvMV1cclxuLy8vIEV4YW1wbGUyOiBkb206W28wLCBvMSwgbzIsIG8zXSAtPiA8c3dhcF9pbiBhdCAyLCAwPiAtPiBbbzEsIG8wLCBvMiwgbzNdXHJcbi8vLyBFeGFtcGxlMzogZG9tOltvMCwgbzEsIG8yLCBvMywgbzRdIC0+IDxzd2FwX2luIGF0IDMsIDA+IC0+IFtvMSwgbzIsIG8wLCBvM11cclxuLy8vIEV4YW1wbGU0OiBkb206W28wLCBvMSwgbzJdIC0+IDxyZW1vdmUgYXQgMT4gLT4gW28wLCBvMl1cclxuZXhwb3J0IHR5cGUgT3JpZ2luVmlld0luc3RydWN0aW9uPFQ+ID1cclxuICB8IFsnaW5zZXJ0JywgbnVtYmVyLCBUXVxyXG4gIHwgWydzd2FwX2luJywgbnVtYmVyLCBudW1iZXJdXHJcbiAgfCBbJ3JlbW92ZScsIG51bWJlcl07XHJcblxyXG4vLy8gQ2hhbmdlIGEgc2VxdWVuY2Ugb2YgdGFyZ2V0IHZpZXcgaW5zdHJ1Y3Rpb25zIHRvIHRoZSBvcmlnaW4gb25lcy5cclxuLy8vIEN1cnJlbnRseSwgaXQgYXBwbGllcyBhIGdyZWVkeSBzdHJhdGVneS5cclxuLy8vICsgRmlyc3QsIGl0IGFwcGxpZXMgYWxsIHJlbW92ZSBpbnN0cnVjdGlvbnMuXHJcbi8vLyArIFRoZW4sIGl0IGFwcGxpZXMgdGhlIHN3YXAgb25lcy5cclxuLy8vICsgRmluYWxseSwgaXQgaW5zZXJ0cyB0aGUgZXh0cmEgZWxlbWVudHMuXHJcbi8vL1xyXG4vLy8gU29tZSBiZXR0ZXIgc3RyYXRlZ3kgd291bGQgaGVscCBhbmQgYmUgaW1wbGVtZW50ZWQgaW4gZnV0dXJlLlxyXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlVmlld1BlcnNwZWN0aXZlPFQgZXh0ZW5kcyBFbGVtZW50Q2hpbGRyZW4sIFUgZXh0ZW5kcyBUID0gVD4oXHJcbiAgb3JpZ2luQ2hpbGRyZW46IFRbXSxcclxuICB0YXJnZXRWaWV3OiBUYXJnZXRWaWV3SW5zdHJ1Y3Rpb248VT5bXSxcclxuICB0SXNVID0gKF94OiBUKTogX3ggaXMgVSA9PiB0cnVlLFxyXG4pOiBPcmlnaW5WaWV3SW5zdHJ1Y3Rpb248VT5bXSB7XHJcbiAgY29uc3Qgb3JpZ2luVmlldzogT3JpZ2luVmlld0luc3RydWN0aW9uPFU+W10gPSBbXTtcclxuXHJcbiAgLy8vIHNlZSByZW1vdmUgaW5zdHJ1Y3Rpb25zXHJcbiAgbGV0IHJlbW92ZUluZGljZXM6IG51bWJlcltdID0gW107XHJcbiAgZm9yIChsZXQgaW5zdCBvZiB0YXJnZXRWaWV3KSB7XHJcbiAgICBpZiAoaW5zdFswXSA9PT0gJ3JlbW92ZScpIHtcclxuICAgICAgcmVtb3ZlSW5kaWNlcy5wdXNoKGluc3RbMV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZW1vdmVJbmRpY2VzID0gcmVtb3ZlSW5kaWNlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgY29uc3QgcmVtb3ZlU2hpZnQ6IChudW1iZXIgfCB1bmRlZmluZWQpW10gPSBbXTtcclxuXHJcbiAgLy8vIGFwcGx5IHJlbW92ZSBpbnN0cnVjdGlvbnMgYW5kIGdldCBlZmZlY3RcclxuICB7XHJcbiAgICBsZXQgciA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUluZGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgd2hpbGUgKHIgPCByZW1vdmVJbmRpY2VzW2ldKSB7XHJcbiAgICAgICAgcmVtb3ZlU2hpZnQucHVzaChyIC0gaSk7XHJcbiAgICAgICAgcisrO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbW92ZVNoaWZ0LnB1c2godW5kZWZpbmVkKTtcclxuICAgICAgb3JpZ2luVmlldy5wdXNoKFsncmVtb3ZlJywgcmVtb3ZlSW5kaWNlc1tpXSAtIGldKTtcclxuICAgICAgcisrO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKHIgPD0gb3JpZ2luQ2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgIHJlbW92ZVNoaWZ0LnB1c2gociAtIHJlbW92ZUluZGljZXMubGVuZ3RoKTtcclxuICAgICAgcisrO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBjb25zb2xlLmxvZyhyZW1vdmVJbmRpY2VzLCByZW1vdmVTaGlmdCk7XHJcbiAgLy8vIGdldCBzaGlmdCBjb25zaWRlcmluZyByZW1vdmUgZWZmZWN0c1xyXG4gIGNvbnN0IGdldFNoaWZ0ID0gKG9mZjogbnVtYmVyKSA9PiB7XHJcbiAgICBpZiAob2ZmID49IHJlbW92ZVNoaWZ0Lmxlbmd0aCB8fCByZW1vdmVTaGlmdFtvZmZdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9mZnNldCAke29mZn0gZm9yIGdldFNoaWZ0ICR7cmVtb3ZlU2hpZnR9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlU2hpZnRbb2ZmXSE7XHJcbiAgfTtcclxuXHJcbiAgLy8vIHZhcmlhYmxlcyB1c2VkIGJ5IGBpbnRlcnByZXRPcmlnaW5WaWV3YFxyXG4gIC8vLyBzY2FubmluZyB0aGUgdGFyZ2V0IHZpZXdcclxuICBsZXQgdGFyZ2V0Vmlld0N1cnNvciA9IDA7XHJcbiAgLy8vIHRoZSBhcHBlbmQgZWZmZWN0XHJcbiAgbGV0IGFwcGVuZE9mZnNldCA9IDA7XHJcbiAgLy8vIGNvbnZlcnRlZCBhcHBlbmQgaW5zdHJ1Y3Rpb25zLlxyXG4gIGNvbnN0IHN3YXBJbnM6IG51bWJlcltdID0gW107XHJcbiAgLy8vIGNvbnZlcnRlZCBhcHBlbmQgaW5zdHJ1Y3Rpb25zLlxyXG4gIGNvbnN0IGluc2VydHM6IFsnaW5zZXJ0JywgbnVtYmVyLCBVXVtdID0gW107XHJcblxyXG4gIC8vLyBhcHBseSBhcHBlbmQgYW5kIHJldXNlIGluc3RydWN0aW9ucyB0aWxsIHRoZSBvZmZzZXQgb2Ygb3JpZ2luIHNlcXVlbmNlLlxyXG4gIGNvbnN0IGludGVycHJldE9yaWdpblZpZXcgPSAob2ZmOiBudW1iZXIpID0+IHtcclxuICAgIC8vIGNvbnNvbGUubG9nKG9mZiwgZ2V0U2hpZnQob2ZmKSk7XHJcbiAgICBvZmYgPSBnZXRTaGlmdChvZmYpO1xyXG4gICAgd2hpbGUgKHRhcmdldFZpZXdDdXJzb3IgPCB0YXJnZXRWaWV3Lmxlbmd0aCkge1xyXG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xyXG4gICAgICBjb25zdCBpbnN0ID0gdGFyZ2V0Vmlld1t0YXJnZXRWaWV3Q3Vyc29yXTtcclxuICAgICAgc3dpdGNoIChpbnN0WzBdKSB7XHJcbiAgICAgICAgY2FzZSAnYXBwZW5kJzpcclxuICAgICAgICAgIGluc2VydHMucHVzaChbJ2luc2VydCcsIGFwcGVuZE9mZnNldCwgaW5zdFsxXV0pO1xyXG4gICAgICAgICAgYXBwZW5kT2Zmc2V0Kys7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdyZXVzZSc6XHJcbiAgICAgICAgICBjb25zdCB0YXJnZXRfb2ZmID0gZ2V0U2hpZnQoaW5zdFsxXSk7XHJcbiAgICAgICAgICBzd2FwSW5zLnB1c2godGFyZ2V0X29mZik7XHJcbiAgICAgICAgICBhcHBlbmRPZmZzZXQrKztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGNhc2UgXCJyZW1vdmVcIjpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRhcmdldFZpZXdDdXJzb3IrKztcclxuICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vLyBzY2FubmluZyB0aGUgb3JpZ2luIHZpZXdcclxuICBmb3IgKGxldCBvZmYgPSAwOyBvZmYgPCBvcmlnaW5DaGlsZHJlbi5sZW5ndGg7IG9mZisrKSB7XHJcbiAgICBjb25zdCBwcmV2Q2hpbGQgPSBvcmlnaW5DaGlsZHJlbltvZmZdO1xyXG5cclxuICAgIGlmIChyZW1vdmVTaGlmdFtvZmZdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCBwb3NpdGlvbiBvZiB1bnByZWRpY3RhYmxlIGVsZW1lbnRzXHJcbiAgICBpZiAoIXRJc1UocHJldkNoaWxkKSkge1xyXG4gICAgICBjb25zdCB0YXJnZXRfb2ZmID0gZ2V0U2hpZnQob2ZmKTtcclxuICAgICAgc3dhcElucy5wdXNoKHRhcmdldF9vZmYpO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcnByZXRPcmlnaW5WaWV3KG9mZik7XHJcbiAgfVxyXG4gIGludGVycHJldE9yaWdpblZpZXcob3JpZ2luQ2hpbGRyZW4ubGVuZ3RoKTtcclxuXHJcbiAgY29uc3Qgc2ltdWxhdGVkOiBudW1iZXJbXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3dhcElucy5sZW5ndGg7IGkrKykge1xyXG4gICAgc2ltdWxhdGVkLnB1c2goaSk7XHJcbiAgfVxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3dhcElucy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgb2ZmID0gc3dhcEluc1tpXTtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2ltdWxhdGVkLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGlmIChzaW11bGF0ZWRbal0gPT09IG9mZikge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3dhcF9pblwiLCBqLCBpLCBzaW11bGF0ZWQpO1xyXG4gICAgICAgIHNpbXVsYXRlZC5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgaWYgKGkgPD0gaikge1xyXG4gICAgICAgICAgc2ltdWxhdGVkLnNwbGljZShpLCAwLCBvZmYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzaW11bGF0ZWQuc3BsaWNlKGkgKyAxLCAwLCBvZmYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaiAhPT0gaSkge1xyXG4gICAgICAgICAgb3JpZ2luVmlldy5wdXNoKFsnc3dhcF9pbicsIGksIGpdKTtcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3dhcF9pbiB0aGVuXCIsIGosIGksIHNpbXVsYXRlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gWy4uLm9yaWdpblZpZXcsIC4uLmluc2VydHNdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBydW5PcmlnaW5WaWV3SW5zdHJ1Y3Rpb25zKHByZXY6IEVsZW1lbnQsIG9yaWdpblZpZXc6IE9yaWdpblZpZXdJbnN0cnVjdGlvbjxOb2RlPltdKSB7XHJcbiAgLy8gY29uc29sZS5sb2coXCJpbnRlcnByZXRlZCBvcmlnaW4gdmlld1wiLCBvcmlnaW5WaWV3KTtcclxuICBmb3IgKGNvbnN0IFtvcCwgb2ZmLCBmcl0gb2Ygb3JpZ2luVmlldykge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICBjYXNlICdpbnNlcnQnOlxyXG4gICAgICAgIHByZXYuaW5zZXJ0QmVmb3JlKGZyLCBwcmV2LmNoaWxkcmVuW29mZl0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzd2FwX2luJzpcclxuICAgICAgICBwcmV2Lmluc2VydEJlZm9yZShwcmV2LmNoaWxkcmVuW2ZyXSwgcHJldi5jaGlsZHJlbltvZmZdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncmVtb3ZlJzpcclxuICAgICAgICBwcmV2LmNoaWxkcmVuW29mZl0ucmVtb3ZlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG9wICcgKyBvcCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLy8gRW5kIG9mIFZpZXcgSW50ZXJwcmV0YXRpb25cclxuLy8vIEJlZ2luIG9mIFJlY3Vyc2l2ZSBTdmcgUGF0Y2hcclxuXHJcbi8vLyBQYXRjaCB0aGUgYHByZXYgPHN2Zz5gIGluIHRoZSBET00gYWNjb3JkaW5nIHRvIGBuZXh0IDxzdmc+YCBmcm9tIHRoZSBiYWNrZW5kLlxyXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hSb290KHByZXY6IFNWR0VsZW1lbnQsIG5leHQ6IFNWR0VsZW1lbnQpIHtcclxuICAvLy8gUGF0Y2ggYXR0cmlidXRlc1xyXG4gIHBhdGNoQXR0cmlidXRlcyhwcmV2LCBuZXh0KTtcclxuICAvLy8gUGF0Y2ggZ2xvYmFsIHN2ZyByZXNvdXJjZXNcclxuICBwYXRjaFN2Z0hlYWRlcihwcmV2LCBuZXh0KTtcclxuXHJcbiAgLy8vIFBhdGNoIGA8Zz5gIGNoaWxkcmVuLCBjYWxsIGByZXVzZU9yUGF0Y2hFbGVtYCB0byBwYXRjaC5cclxuICBwYXRjaENoaWxkcmVuKHByZXYsIG5leHQpO1xyXG4gIHJldHVybjtcclxuXHJcbiAgZnVuY3Rpb24gcGF0Y2hTdmdIZWFkZXIocHJldjogU1ZHRWxlbWVudCwgbmV4dDogU1ZHRWxlbWVudCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgY29uc3QgcHJldkNoaWxkID0gcHJldi5jaGlsZHJlbltpXTtcclxuICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dC5jaGlsZHJlbltpXTtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJwcmV2XCIsIHByZXZDaGlsZCk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwibmV4dFwiLCBuZXh0Q2hpbGQpO1xyXG4gICAgICBpZiAocHJldkNoaWxkLnRhZ05hbWUgPT09ICdkZWZzJykge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGQuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSAnZ2x5cGgnKSB7XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImFwcGVuZCBnbHlwaHM6XCIsIG5leHRDaGlsZC5jaGlsZHJlbiwgXCJ0b1wiLCBwcmV2Q2hpbGQpO1xyXG4gICAgICAgICAgcHJldkNoaWxkLmFwcGVuZCguLi5uZXh0Q2hpbGQuY2hpbGRyZW4pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJldkNoaWxkLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA9PT0gJ2NsaXAtcGF0aCcpIHtcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2xpcCBwYXRoOiByZXBsYWNlXCIpO1xyXG4gICAgICAgICAgLy8gdG9kbzogZ2NcclxuICAgICAgICAgIHByZXZDaGlsZC5hcHBlbmQoLi4ubmV4dENoaWxkLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocHJldkNoaWxkLnRhZ05hbWUgPT09ICdzdHlsZScgJiYgbmV4dENoaWxkLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXVzZScpICE9PSAnMScpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJlcGxhY2UgZXh0cmEgc3R5bGVcIiwgcHJldkNoaWxkLCBuZXh0Q2hpbGQpO1xyXG5cclxuICAgICAgICAvLyB0b2RvOiBnY1xyXG4gICAgICAgIGlmIChuZXh0Q2hpbGQudGV4dENvbnRlbnQpIHtcclxuICAgICAgICAgIC8vIHRvZG86IGxvb2tzIHNsb3dcclxuICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMzMjY0OTQvcGFyc2luZy1jc3MtaW4tamF2YXNjcmlwdC1qcXVlcnlcclxuICAgICAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpLFxyXG4gICAgICAgICAgICBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5cclxuICAgICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IG5leHRDaGlsZC50ZXh0Q29udGVudDtcclxuICAgICAgICAgIC8vIHRoZSBzdHlsZSB3aWxsIG9ubHkgYmUgcGFyc2VkIG9uY2UgaXQgaXMgYWRkZWQgdG8gYSBkb2N1bWVudFxyXG4gICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3ZnU2hlZXQgPSAocHJldkNoaWxkIGFzIEhUTUxTdHlsZUVsZW1lbnQpLnNoZWV0ITtcclxuICAgICAgICAgIGNvbnN0IHJ1bGVzVG9JbnNlcnQgPSBzdHlsZUVsZW1lbnQuc2hlZXQ/LmNzc1J1bGVzIHx8IFtdO1xyXG5cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicnVsZXMgdG8gaW5zZXJ0XCIsIGN1cnJlbnRTdmdTaGVldCwgcnVsZXNUb0luc2VydCk7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXNUb0luc2VydCkge1xyXG4gICAgICAgICAgICBjdXJyZW50U3ZnU2hlZXQuaW5zZXJ0UnVsZShydWxlLmNzc1RleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8vIGFwcGx5IGF0dHJpYnV0ZSBwYXRjaGVzIHRvIHRoZSBgcHJldiA8c3ZnIG9yIGc+YCBlbGVtZW50XHJcbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhwcmV2OiBFbGVtZW50LCBuZXh0OiBFbGVtZW50KSB7XHJcbiAgY29uc3QgcHJldkF0dHJzID0gcHJldi5hdHRyaWJ1dGVzO1xyXG4gIGNvbnN0IG5leHRBdHRycyA9IG5leHQuYXR0cmlidXRlcztcclxuICBpZiAocHJldkF0dHJzLmxlbmd0aCA9PT0gbmV4dEF0dHJzLmxlbmd0aCkge1xyXG4gICAgbGV0IHNhbWUgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2QXR0cnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcHJldkF0dHIgPSBwcmV2QXR0cnNbaV07XHJcbiAgICAgIGNvbnN0IG5leHRBdHRyID0gbmV4dEF0dHJzLmdldE5hbWVkSXRlbShwcmV2QXR0ci5uYW1lKTtcclxuICAgICAgaWYgKG5leHRBdHRyID09PSBudWxsIHx8IHByZXZBdHRyLnZhbHVlICE9PSBuZXh0QXR0ci52YWx1ZSkge1xyXG4gICAgICAgIHNhbWUgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzYW1lKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwic2FtZSBhdHRyaWJ1dGVzLCBza2lwXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGNvbnNvbGUubG9nKFwiZGlmZmVyZW50IGF0dHJpYnV0ZXMsIHJlcGxhY2VcIik7XHJcblxyXG4gIGNvbnN0IHJlbW92ZWRBdHRyczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2QXR0cnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHJlbW92ZWRBdHRycy5wdXNoKHByZXZBdHRyc1tpXS5uYW1lKTtcclxuICB9XHJcblxyXG4gIGZvciAoY29uc3QgYXR0ciBvZiByZW1vdmVkQXR0cnMpIHtcclxuICAgIHByZXYucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0QXR0cnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHByZXYuc2V0QXR0cmlidXRlKG5leHRBdHRyc1tpXS5uYW1lLCBuZXh0QXR0cnNbaV0udmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxuLy8vIGFwcGx5IHBhdGNoZXMgdG8gdGhlIGNoaWxkcmVuIHNlcXVlbmNlIG9mIGBwcmV2IDxzdmcgb3IgZz5gIGluIHRoZSBET01cclxuZnVuY3Rpb24gcGF0Y2hDaGlsZHJlbihwcmV2OiBFbGVtZW50LCBuZXh0OiBFbGVtZW50KSB7XHJcbiAgY29uc3QgW3RhcmdldFZpZXcsIHRvUGF0Y2hdID0gaW50ZXJwcmV0VGFyZ2V0VmlldzxTVkdHRWxlbWVudD4oXHJcbiAgICBwcmV2LmNoaWxkcmVuIGFzIHVua25vd24gYXMgU1ZHR0VsZW1lbnRbXSxcclxuICAgIG5leHQuY2hpbGRyZW4gYXMgdW5rbm93biBhcyBTVkdHRWxlbWVudFtdLFxyXG4gICAgaXNHRWxlbSxcclxuICApO1xyXG5cclxuICBmb3IgKGxldCBbcHJldkNoaWxkLCBuZXh0Q2hpbGRdIG9mIHRvUGF0Y2gpIHtcclxuICAgIHJldXNlT3JQYXRjaEVsZW0ocHJldkNoaWxkLCBuZXh0Q2hpbGQpO1xyXG4gIH1cclxuXHJcbiAgLy8gY29uc29sZS5sb2coXCJpbnRlcnByZXRlZCB0YXJnZXQgdmlld1wiLCB0YXJnZXRWaWV3KTtcclxuXHJcbiAgY29uc3Qgb3JpZ2luVmlldyA9IGNoYW5nZVZpZXdQZXJzcGVjdGl2ZShcclxuICAgIHByZXYuY2hpbGRyZW4gYXMgdW5rbm93biBhcyBTVkdHRWxlbWVudFtdLFxyXG4gICAgdGFyZ2V0VmlldyxcclxuICAgIGlzR0VsZW0sXHJcbiAgKTtcclxuXHJcbiAgcnVuT3JpZ2luVmlld0luc3RydWN0aW9ucyhwcmV2LCBvcmlnaW5WaWV3KTtcclxufVxyXG5cclxuLy8vIFJlcGxhY2UgdGhlIGBwcmV2YCBlbGVtZW50IHdpdGggYG5leHRgIGVsZW1lbnQuXHJcbi8vLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgYHByZXZgIGVsZW1lbnQgaXMgcmV1c2VkLlxyXG4vLy8gUmV0dXJuIGZhbHNlIGlmIHRoZSBgcHJldmAgZWxlbWVudCBpcyByZXBsYWNlZC5cclxuZnVuY3Rpb24gcmV1c2VPclBhdGNoRWxlbShwcmV2OiBTVkdHRWxlbWVudCwgbmV4dDogU1ZHR0VsZW1lbnQpIHtcclxuICBjb25zdCBjYW5SZXVzZSA9IGVxdWFsRWxlbShwcmV2LCBuZXh0KTtcclxuXHJcbiAgLy8vIEV2ZW4gaWYgdGhlIGVsZW1lbnQgaXMgcmV1c2VkLCB3ZSBzdGlsbCBuZWVkIHRvIHJlcGxhY2UgaXRzIGF0dHJpYnV0ZXMuXHJcbiAgbmV4dC5yZW1vdmVBdHRyaWJ1dGUoVHlwc3RTdmdBdHRycy5SZXVzZUZyb20pO1xyXG4gIHBhdGNoQXR0cmlidXRlcyhwcmV2LCBuZXh0KTtcclxuXHJcbiAgaWYgKGNhblJldXNlKSB7XHJcbiAgICByZXR1cm4gdHJ1ZSAvKiByZXVzZWQgKi87XHJcbiAgfVxyXG5cclxuICAvLy8gSGFyZCByZXBsYWNlIGVsZW1lbnRzIHRoYXQgaXMgbm90IGEgYDxnPmAgZWxlbWVudC5cclxuICByZXBsYWNlTm9uU1ZHRWxlbWVudHMocHJldiwgbmV4dCk7XHJcbiAgLy8vIFBhdGNoIGA8Zz5gIGNoaWxkcmVuLCB3aWxsIGNhbGwgYHJldXNlT3JQYXRjaEVsZW1gIGFnYWluLlxyXG4gIHBhdGNoQ2hpbGRyZW4ocHJldiwgbmV4dCk7XHJcbiAgcmV0dXJuIGZhbHNlIC8qIHJldXNlZCAqLztcclxuXHJcbiAgZnVuY3Rpb24gcmVwbGFjZU5vblNWR0VsZW1lbnRzKHByZXY6IEVsZW1lbnQsIG5leHQ6IEVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHJlbW92ZWRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHByZXZDaGlsZCA9IHByZXYuY2hpbGRyZW5baV07XHJcbiAgICAgIGlmICghaXNHRWxlbShwcmV2Q2hpbGQpKSB7XHJcbiAgICAgICAgcmVtb3ZlZEluZGljZXMucHVzaChpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgcmVtb3ZlZEluZGljZXMucmV2ZXJzZSgpKSB7XHJcbiAgICAgIHByZXYuY2hpbGRyZW5baW5kZXhdLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBuZXh0LmNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoIWlzR0VsZW0obmV4dENoaWxkKSkge1xyXG4gICAgICAgIHByZXYuYXBwZW5kQ2hpbGQobmV4dENoaWxkLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vLyBFbmQgb2YgUmVjdXJzaXZlIFN2ZyBQYXRjaFxyXG4iXX0=