export class FetchPackageRegistry {
    am;
    cache = new Map();
    constructor(am) {
        this.am = am;
    }
    resolvePath(path) {
        return `https://packages.typst.org/preview/${path.name}-${path.version}.tar.gz`;
    }
    pullPackageData(path) {
        const request = new XMLHttpRequest();
        request.overrideMimeType('text/plain; charset=x-user-defined');
        request.open('GET', this.resolvePath(path), false);
        request.send(null);
        if (request.status === 200 &&
            (request.response instanceof String || typeof request.response === 'string')) {
            return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
        }
        return undefined;
    }
    resolve(spec, context) {
        if (spec.namespace !== 'preview') {
            return undefined;
        }
        /// Check cache
        const path = this.resolvePath(spec);
        if (this.cache.has(path)) {
            return this.cache.get(path)();
        }
        /// Fetch data
        const data = this.pullPackageData(spec);
        if (!data) {
            return undefined;
        }
        /// Extract package bundle to the underlying access model `this.am`
        const previewDir = `/@memory/fetch/packages/preview/${spec.namespace}/${spec.name}/${spec.version}`;
        const entries = [];
        context.untar(data, (path, data, mtime) => {
            entries.push([previewDir + '/' + path, data, new Date(mtime)]);
        });
        const cacheClosure = () => {
            for (const [path, data, mtime] of entries) {
                this.am.insertFile(path, data, mtime);
            }
            /// Return the resolved directory to the package
            /// It is then used to access the package data by the access model `this.am`
            return previewDir;
        };
        this.cache.set(path, cacheClosure);
        /// Trigger write out
        return cacheClosure();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZS5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZnMvcGFja2FnZS5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsTUFBTSxPQUFPLG9CQUFvQjtJQUdYO0lBRnBCLEtBQUssR0FBMEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUV6RCxZQUFvQixFQUF1QjtRQUF2QixPQUFFLEdBQUYsRUFBRSxDQUFxQjtJQUFHLENBQUM7SUFFL0MsV0FBVyxDQUFDLElBQWlCO1FBQzNCLE9BQU8sc0NBQXNDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sU0FBUyxDQUFDO0lBQ2xGLENBQUM7SUFFRCxlQUFlLENBQUMsSUFBaUI7UUFDL0IsTUFBTSxPQUFPLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNyQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsb0NBQW9DLENBQUMsQ0FBQztRQUMvRCxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ25ELE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbkIsSUFDRSxPQUFPLENBQUMsTUFBTSxLQUFLLEdBQUc7WUFDdEIsQ0FBQyxPQUFPLENBQUMsUUFBUSxZQUFZLE1BQU0sSUFBSSxPQUFPLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLEVBQzVFLENBQUM7WUFDRCxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsT0FBTyxDQUFDLElBQWlCLEVBQUUsT0FBOEI7UUFDdkQsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ2pDLE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7UUFFRCxlQUFlO1FBQ2YsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDekIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUUsRUFBRSxDQUFDO1FBQ2pDLENBQUM7UUFFRCxjQUFjO1FBQ2QsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDVixPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO1FBRUQsbUVBQW1FO1FBQ25FLE1BQU0sVUFBVSxHQUFHLG1DQUFtQyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3BHLE1BQU0sT0FBTyxHQUFpQyxFQUFFLENBQUM7UUFDakQsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFZLEVBQUUsSUFBZ0IsRUFBRSxLQUFhLEVBQUUsRUFBRTtZQUNwRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRSxDQUFDLENBQUMsQ0FBQztRQUNILE1BQU0sWUFBWSxHQUFHLEdBQUcsRUFBRTtZQUN4QixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDO2dCQUMxQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3hDLENBQUM7WUFFRCxnREFBZ0Q7WUFDaEQsNEVBQTRFO1lBQzVFLE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUMsQ0FBQztRQUNGLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUVuQyxxQkFBcUI7UUFDckIsT0FBTyxZQUFZLEVBQUUsQ0FBQztJQUN4QixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWNrYWdlUmVnaXN0cnksIFBhY2thZ2VSZXNvbHZlQ29udGV4dCwgUGFja2FnZVNwZWMgfSBmcm9tICcuLi9pbnRlcm5hbC50eXBlcy5tanMnO1xyXG5pbXBvcnQgeyBXcml0YWJsZUFjY2Vzc01vZGVsIH0gZnJvbSAnLi9pbmRleC5tanMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEZldGNoUGFja2FnZVJlZ2lzdHJ5IGltcGxlbWVudHMgUGFja2FnZVJlZ2lzdHJ5IHtcclxuICBjYWNoZTogTWFwPHN0cmluZywgKCkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkPiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhbTogV3JpdGFibGVBY2Nlc3NNb2RlbCkge31cclxuXHJcbiAgcmVzb2x2ZVBhdGgocGF0aDogUGFja2FnZVNwZWMpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGBodHRwczovL3BhY2thZ2VzLnR5cHN0Lm9yZy9wcmV2aWV3LyR7cGF0aC5uYW1lfS0ke3BhdGgudmVyc2lvbn0udGFyLmd6YDtcclxuICB9XHJcblxyXG4gIHB1bGxQYWNrYWdlRGF0YShwYXRoOiBQYWNrYWdlU3BlYyk6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XHJcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMucmVzb2x2ZVBhdGgocGF0aCksIGZhbHNlKTtcclxuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHJlcXVlc3Quc3RhdHVzID09PSAyMDAgJiZcclxuICAgICAgKHJlcXVlc3QucmVzcG9uc2UgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHJlcXVlc3QucmVzcG9uc2UgPT09ICdzdHJpbmcnKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVxdWVzdC5yZXNwb25zZSwgKGM6IHN0cmluZykgPT4gYy5jaGFyQ29kZUF0KDApKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICByZXNvbHZlKHNwZWM6IFBhY2thZ2VTcGVjLCBjb250ZXh0OiBQYWNrYWdlUmVzb2x2ZUNvbnRleHQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKHNwZWMubmFtZXNwYWNlICE9PSAncHJldmlldycpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gQ2hlY2sgY2FjaGVcclxuICAgIGNvbnN0IHBhdGggPSB0aGlzLnJlc29sdmVQYXRoKHNwZWMpO1xyXG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKHBhdGgpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChwYXRoKSEoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gRmV0Y2ggZGF0YVxyXG4gICAgY29uc3QgZGF0YSA9IHRoaXMucHVsbFBhY2thZ2VEYXRhKHNwZWMpO1xyXG4gICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIEV4dHJhY3QgcGFja2FnZSBidW5kbGUgdG8gdGhlIHVuZGVybHlpbmcgYWNjZXNzIG1vZGVsIGB0aGlzLmFtYFxyXG4gICAgY29uc3QgcHJldmlld0RpciA9IGAvQG1lbW9yeS9mZXRjaC9wYWNrYWdlcy9wcmV2aWV3LyR7c3BlYy5uYW1lc3BhY2V9LyR7c3BlYy5uYW1lfS8ke3NwZWMudmVyc2lvbn1gO1xyXG4gICAgY29uc3QgZW50cmllczogW3N0cmluZywgVWludDhBcnJheSwgRGF0ZV1bXSA9IFtdO1xyXG4gICAgY29udGV4dC51bnRhcihkYXRhLCAocGF0aDogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5LCBtdGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGVudHJpZXMucHVzaChbcHJldmlld0RpciArICcvJyArIHBhdGgsIGRhdGEsIG5ldyBEYXRlKG10aW1lKV0pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjYWNoZUNsb3N1cmUgPSAoKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgW3BhdGgsIGRhdGEsIG10aW1lXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgdGhpcy5hbS5pbnNlcnRGaWxlKHBhdGgsIGRhdGEsIG10aW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8vIFJldHVybiB0aGUgcmVzb2x2ZWQgZGlyZWN0b3J5IHRvIHRoZSBwYWNrYWdlXHJcbiAgICAgIC8vLyBJdCBpcyB0aGVuIHVzZWQgdG8gYWNjZXNzIHRoZSBwYWNrYWdlIGRhdGEgYnkgdGhlIGFjY2VzcyBtb2RlbCBgdGhpcy5hbWBcclxuICAgICAgcmV0dXJuIHByZXZpZXdEaXI7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgY2FjaGVDbG9zdXJlKTtcclxuXHJcbiAgICAvLy8gVHJpZ2dlciB3cml0ZSBvdXRcclxuICAgIHJldHVybiBjYWNoZUNsb3N1cmUoKTtcclxuICB9XHJcbn1cclxuIl19