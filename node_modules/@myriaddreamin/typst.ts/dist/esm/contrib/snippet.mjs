import { withPackageRegistry, withAccessModel, preloadFontAssets, disableDefaultFontAssets, preloadRemoteFonts, } from '../options.init.mjs';
import { MemoryAccessModel } from '../fs/index.mjs';
import { FetchPackageRegistry } from '../fs/package.mjs';
import { randstr } from '../utils.mjs';
const isNode = 
// @ts-ignore
typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
/**
 * Convenient util class for compiling documents, which is a wrapper of the
 * {@link TypstCompiler} and {@link TypstRenderer}.
 *
 * Note: the interface of this class is less stable than {@link TypstCompiler}
 * and {@link TypstRenderer}.
 *
 * @example
 * Use the *global shared* compiler instance:
 *
 * ```typescript
 * import { $typst } from '@myriaddreamin/typst.ts';
 * ```
 *
 * Note: if you want to compile multiple documents, you should create a new
 * instance for each compilation work or maintain the shared state on the
 * utility instance `$typst` carefully, because the compilation process will
 * change the state of that.
 *
 * @example
 * Create an instance of utility:
 *
 * ```typescript
 * const $typst = new TypstSnippet({
 *   // optional renderer instance
 *   renderer: enableRendering ?? (() => {
 *     return createGlobalRenderer(createTypstRenderer,
 *       undefined, initOptions);
 *   }),
 *   compiler() => {
 *     return createGlobalCompiler(createTypstCompiler,
 *       initOptions);
 *   }
 * });
 * ```
 */
export class TypstSnippet {
    /** @internal */
    mainFilePath;
    /** @internal */
    cc;
    /** @internal */
    ex;
    /**
     * Create a new instance of {@link TypstSnippet}.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     *
     * @example
     *
     * Passes a global shared compiler instance that get initialized lazily:
     * ```typescript
     * const $typst = new TypstSnippet(() => {
     *  return createGlobalCompiler(createTypstCompiler, initOptions);
     * });
     *
     */
    constructor(options) {
        this.cc = options?.compiler || TypstSnippet.buildLocalCompiler;
        this.ex = options?.renderer || TypstSnippet.buildLocalRenderer;
        this.mainFilePath = '/main.typ';
        this.providers = [];
    }
    /**
     * Set lazy initialized compiler instance for the utility instance.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     */
    setCompiler(cc) {
        this.cc = cc;
    }
    /**
     * Get an initialized compiler instance from the utility instance.
     */
    async getCompiler() {
        return (typeof this.cc === 'function' ? (this.cc = await this.cc()) : this.cc);
    }
    /**
     * Set lazy initialized renderer instance for the utility instance.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     */
    setRenderer(ex) {
        this.ex = ex;
    }
    /**
     * Get an initialized renderer instance from the utility instance.
     */
    async getRenderer() {
        return typeof this.ex === 'function' ? (this.ex = await this.ex()) : this.ex;
    }
    providers;
    /**
     * add providers for bullding the compiler or renderer component.
     */
    use(...providers) {
        if (!this.providers) {
            throw new Error('already prepare uses for instances');
        }
        this.providers.push(...providers);
    }
    /**
     * todo: add docs
     */
    static preloadFontFromUrl(fontUrl) {
        return TypstSnippet.preloadFonts([fontUrl]);
    }
    /**
     * todo: add docs
     */
    static preloadFontData(fontData) {
        return TypstSnippet.preloadFonts([fontData]);
    }
    /**
     * todo: add docs
     */
    static preloadFonts(userFonts) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [preloadRemoteFonts(userFonts)],
        };
    }
    /**
     * don't load any default font assets.
     * todo: add docs
     */
    static disableDefaultFontAssets() {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [disableDefaultFontAssets()],
        };
    }
    /**
     * todo: add docs
     */
    static preloadFontAssets(options) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [preloadFontAssets(options)],
        };
    }
    /**
     * Set accessl model for the compiler instance
     * @example
     *
     * use memory access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m));
     * ```
     */
    static withAccessModel(accessModel) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [withAccessModel(accessModel)],
        };
    }
    /**
     * Set package registry for the compiler instance
     * @example
     *
     * use a customized package registry
     *
     * ```typescript
     * const n = new NodeFetchPackageRegistry();
     * $typst.use(TypstSnippet.withPackageRegistry(n));
     * ```
     */
    static withPackageRegistry(registry) {
        return {
            key: 'package-registry',
            forRoles: ['compiler'],
            provides: [withPackageRegistry(registry)],
        };
    }
    /**
     * Retrieve an access model to store the data of fetched files.
     * Provide a PackageRegistry instance for the compiler instance.
     *
     * @example
     *
     * use default (memory) access model
     *
     * ```typescript
     * $typst.use(await TypstSnippet.fetchPackageRegistry());
     * ```
     *
     * @example
     *
     * use external access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
     * ```
     */
    static fetchPackageRegistry(accessModel) {
        const m = accessModel || new MemoryAccessModel();
        const provides = [
            ...(accessModel ? [] : [withAccessModel(m)]),
            withPackageRegistry(new FetchPackageRegistry(m)),
        ];
        return {
            key: 'package-registry$fetch',
            forRoles: ['compiler'],
            provides,
        };
    }
    /**
     * Retrieve a fetcher for fetching package data.
     * Provide a PackageRegistry instance for the compiler instance.
     * @example
     *
     * use a customized fetcher
     *
     * ```typescript
     * import request from 'sync-request-curl';
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
     *   const response = request('GET', this.resolvePath(path), {
     *     insecure: true,
     *   });
     *
     *   if (response.statusCode === 200) {
     *     return response.getBody(undefined);
     *   }
     *   return undefined;
     * }));
     * ```
     */
    static fetchPackageBy(accessModel, fetcher) {
        class HttpPackageRegistry extends FetchPackageRegistry {
            pullPackageData(path) {
                return fetcher(path, this.resolvePath(path));
            }
        }
        return {
            key: 'package-registry$lambda',
            forRoles: ['compiler'],
            provides: [withPackageRegistry(new HttpPackageRegistry(accessModel))],
        };
    }
    /** @internal */
    ccOptions;
    /**
     * Set compiler init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setCompilerInitOptions(options) {
        this.requireIsUninitialized('compiler', this.cc);
        this.ccOptions = options;
    }
    /** @internal */
    exOptions;
    /**
     * Set renderer init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setRendererInitOptions(options) {
        this.requireIsUninitialized('renderer', this.ex);
        this.exOptions = options;
    }
    /**
     * Set shared main file path.
     */
    setMainFilePath(path) {
        this.mainFilePath = path;
    }
    /**
     * Get shared main file path.
     */
    getMainFilePath() {
        return this.mainFilePath;
    }
    removeTmp(opts) {
        if (opts.mainFilePath.startsWith('/tmp/')) {
            return this.unmapShadow(opts.mainFilePath);
        }
        return Promise.resolve();
    }
    /**
     * Add a source file to the compiler.
     * See {@link TypstCompiler#addSource}.
     */
    async addSource(path, content) {
        (await this.getCompiler()).addSource(path, content);
    }
    /**
     * Reset the shadow files.
     * Note: this function is independent to the {@link reset} function.
     * See {@link TypstCompiler#resetShadow}.
     */
    async resetShadow() {
        (await this.getCompiler()).resetShadow();
    }
    /**
     * Add a shadow file to the compiler.
     * See {@link TypstCompiler#mapShadow}.
     */
    async mapShadow(path, content) {
        (await this.getCompiler()).mapShadow(path, content);
    }
    /**
     * Remove a shadow file from the compiler.
     * See {@link TypstCompiler#unmapShadow}.
     */
    async unmapShadow(path) {
        (await this.getCompiler()).unmapShadow(path);
    }
    /**
     * Compile the document to vector (IR) format.
     * See {@link SweetCompileOptions}.
     */
    async vector(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to PDF format.
     * See {@link SweetCompileOptions}.
     */
    async pdf(o) {
        const opts = await this.getCompileOptions(o);
        opts.format = 'pdf';
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to SVG format.
     * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
     */
    async svg(o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderSvg({
            ...o,
            renderSession,
        }));
    }
    /**
     * Compile the document to canvas operations.
     * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
     */
    async canvas(container, o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderToCanvas({
            container,
            ...o,
            renderSession,
        }));
    }
    /**
     * Get semantic tokens for the document.
     */
    async query(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .query({
            ...o,
            ...opts,
        })
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Get token legend for semantic tokens.
     */
    async getSemanticTokenLegend() {
        return (await this.getCompiler()).getSemanticTokenLegend();
    }
    /**
     * Get semantic tokens for the document.
     * See {@link SweetCompileOptions}.
     * See {@link TypstCompiler#getSemanticTokens}.
     */
    async getSemanticTokens(o) {
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .getSemanticTokens({
            mainFilePath: opts.mainFilePath,
            resultId: o.resultId,
        })
            .finally(() => this.removeTmp(opts));
    }
    async getCompileOptions(opts) {
        if (opts === undefined) {
            return { mainFilePath: this.mainFilePath, diagnostics: 'none' };
        }
        else if (typeof opts === 'string') {
            throw new Error(`please specify opts as {mainContent: '...'} or {mainFilePath: '...'}`);
        }
        else if ('mainFilePath' in opts) {
            return { ...opts, diagnostics: 'none' };
        }
        else {
            const destFile = `/tmp/${randstr()}.typ`;
            await this.addSource(destFile, opts.mainContent);
            return { mainFilePath: destFile, inputs: opts.inputs, diagnostics: 'none' };
        }
    }
    async getVector(o) {
        if (o && 'vectorData' in o) {
            return o.vectorData;
        }
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    async transientRender(opts, f) {
        const rr = await this.getRenderer();
        if (!rr) {
            throw new Error('does not provide renderer instance');
        }
        const data = await this.getVector(opts);
        return await rr.runWithSession(async (session) => {
            rr.manipulateData({
                renderSession: session,
                action: 'reset',
                data,
            });
            return f(rr, session);
        });
    }
    prepareUseOnce = undefined;
    async prepareUse() {
        if (this.prepareUseOnce) {
            return this.prepareUseOnce;
        }
        return (this.prepareUseOnce = this.doPrepareUse());
    }
    async doPrepareUse() {
        if (!this.providers) {
            return;
        }
        const providers = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        this.providers = [];
        if ($typst == this &&
            !providers.some(p => p.key.includes('package-registry') || p.key.includes('access-model'))) {
            // Note: the default fetch backend always adds a withAccessModel(mem)
            if (isNode) {
                const escapeImport = new Function('m', 'return import(m)');
                try {
                    const m = new MemoryAccessModel();
                    const { default: request } = await escapeImport('sync-request');
                    $typst.use(TypstSnippet.withAccessModel(m), TypstSnippet.fetchPackageBy(m, (_, path) => {
                        const response = request('GET', path);
                        if (response.statusCode === 200) {
                            return response.getBody(undefined);
                        }
                        return undefined;
                    }));
                }
                catch (e) { }
            }
            else {
                $typst.use(TypstSnippet.fetchPackageRegistry());
            }
        }
        const providers2 = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        const ccOptions = (this.ccOptions ||= {});
        const ccBeforeBuild = (ccOptions.beforeBuild ||= []);
        const exOptions = (this.exOptions ||= {});
        const exBeforeBuild = (exOptions.beforeBuild ||= []);
        for (const provider of [...providers, ...providers2]) {
            if (provider.forRoles.includes('compiler')) {
                this.requireIsUninitialized('compiler', this.cc);
                ccBeforeBuild.push(...provider.provides);
            }
            if (provider.forRoles.includes('renderer')) {
                this.requireIsUninitialized('renderer', this.ex);
                exBeforeBuild.push(...provider.provides);
            }
        }
        this.providers = undefined;
    }
    requireIsUninitialized(role, c, e) {
        if (c && typeof c !== 'function') {
            throw new Error(`${role} has been initialized: ${c}`);
        }
    }
    /** @internal */
    static async buildLocalCompiler() {
        const { createTypstCompiler } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/compiler'));
        await this.prepareUse();
        const compiler = createTypstCompiler();
        await compiler.init(this.ccOptions);
        return compiler;
    }
    /** @internal */
    static async buildGlobalCompiler() {
        // lazy import compile module
        const { createGlobalCompiler } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/contrib/global-compiler'));
        const { createTypstCompiler } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/compiler'));
        await this.prepareUse();
        return createGlobalCompiler(createTypstCompiler, this.ccOptions);
    }
    /** @internal */
    static async buildLocalRenderer() {
        const { createTypstRenderer } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/renderer'));
        await this.prepareUse();
        const renderer = createTypstRenderer();
        await renderer.init(this.exOptions);
        return renderer;
    }
    /** @internal */
    static async buildGlobalRenderer() {
        // lazy import renderer module
        const { createGlobalRenderer } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/contrib/global-renderer'));
        const { createTypstRenderer } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/renderer'));
        await this.prepareUse();
        return createGlobalRenderer(createTypstRenderer, this.exOptions);
    }
}
/**
 * The lazy initialized global shared instance of {@link TypstSnippet}. See
 * {@link TypstSnippet} for more details.
 */
export const $typst = new TypstSnippet({
    compiler: TypstSnippet.buildGlobalCompiler,
    renderer: TypstSnippet.buildGlobalRenderer,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25pcHBldC5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJpYi9zbmlwcGV0Lm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLGVBQWUsRUFHZixpQkFBaUIsRUFDakIsd0JBQXdCLEVBQ3hCLGtCQUFrQixHQUduQixNQUFNLHFCQUFxQixDQUFDO0FBRzdCLE9BQU8sRUFBRSxpQkFBaUIsRUFBNEIsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQU96RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBK0R2QyxNQUFNLE1BQU07QUFDVixhQUFhO0FBQ2IsT0FBTyxPQUFPLEtBQUssV0FBVyxJQUFJLE9BQU8sQ0FBQyxRQUFRLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztBQUU5Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQ0c7QUFDSCxNQUFNLE9BQU8sWUFBWTtJQUN2QixnQkFBZ0I7SUFDUixZQUFZLENBQVM7SUFDN0IsZ0JBQWdCO0lBQ1IsRUFBRSxDQUE4QjtJQUN4QyxnQkFBZ0I7SUFDUixFQUFFLENBQThCO0lBRXhDOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxZQUFZLE9BR1g7UUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHLE9BQU8sRUFBRSxRQUFRLElBQUksWUFBWSxDQUFDLGtCQUFrQixDQUFDO1FBQy9ELElBQUksQ0FBQyxFQUFFLEdBQUcsT0FBTyxFQUFFLFFBQVEsSUFBSSxZQUFZLENBQUMsa0JBQWtCLENBQUM7UUFDL0QsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7UUFDaEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdB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QUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUM7SUFDckMsUUFBUSxFQUFFLFlBQVksQ0FBQyxtQkFBbUI7SUFDMUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxtQkFBbUI7Q0FDM0MsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDb21waWxlT3B0aW9ucywgVHlwc3RDb21waWxlciB9IGZyb20gJy4uL2NvbXBpbGVyLm1qcyc7XHJcbmltcG9ydCB7XHJcbiAgd2l0aFBhY2thZ2VSZWdpc3RyeSxcclxuICB3aXRoQWNjZXNzTW9kZWwsXHJcbiAgdHlwZSBCZWZvcmVCdWlsZEZuLFxyXG4gIHR5cGUgSW5pdE9wdGlvbnMsXHJcbiAgcHJlbG9hZEZvbnRBc3NldHMsXHJcbiAgZGlzYWJsZURlZmF1bHRGb250QXNzZXRzLFxyXG4gIHByZWxvYWRSZW1vdGVGb250cyxcclxuICBMb2FkUmVtb3RlQXNzZXRzT3B0aW9ucyxcclxuICBMb2FkUmVtb3RlRm9udHNPcHRpb25zLFxyXG59IGZyb20gJy4uL29wdGlvbnMuaW5pdC5tanMnO1xyXG5pbXBvcnQgdHlwZSB7IFR5cHN0UmVuZGVyZXIsIFJlbmRlclNlc3Npb24gfSBmcm9tICcuLi9yZW5kZXJlci5tanMnO1xyXG5pbXBvcnQgdHlwZSB7IFJlbmRlclRvQ2FudmFzT3B0aW9ucywgUmVuZGVyU3ZnT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMucmVuZGVyLm1qcyc7XHJcbmltcG9ydCB7IE1lbW9yeUFjY2Vzc01vZGVsLCB0eXBlIFdyaXRhYmxlQWNjZXNzTW9kZWwgfSBmcm9tICcuLi9mcy9pbmRleC5tanMnO1xyXG5pbXBvcnQgeyBGZXRjaFBhY2thZ2VSZWdpc3RyeSB9IGZyb20gJy4uL2ZzL3BhY2thZ2UubWpzJztcclxuaW1wb3J0IHtcclxuICBQYWNrYWdlUmVnaXN0cnksXHJcbiAgUGFja2FnZVNwZWMsXHJcbiAgU2VtYW50aWNUb2tlbnMsXHJcbiAgU2VtYW50aWNUb2tlbnNMZWdlbmQsXHJcbn0gZnJvbSAnLi4vaW50ZXJuYWwudHlwZXMubWpzJztcclxuaW1wb3J0IHsgcmFuZHN0ciB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XHJcblxyXG4vKipcclxuICogU29tZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIG9mIHZhbHVlIG9yIGp1c3QgdGhhdCB2YWx1ZS5cclxuICovXHJcbnR5cGUgUHJvbWlzZUp1c3Q8VD4gPSAoKCkgPT4gUHJvbWlzZTxUPikgfCBUO1xyXG5cclxuaW50ZXJmYWNlIENvbXBpbGVPcHRpb25zQ29tbW9uIHtcclxuICAvKipcclxuICAgKiBBZGRzIGEgc3RyaW5nIGtleS12YWx1ZSBwYWlyIHZpc2libGUgdGhyb3VnaCBgc3lzLmlucHV0c2BcclxuICAgKlxyXG4gICAqIE5vdGU6IHBhc3MgYHt9YCB0byBjbGVhciBgc3lzLmlucHV0c2BcclxuICAgKlxyXG4gICAqIE5vdGU6IFdoZW4gcGFzc2luZyBgdW5kZWZpbmVkYCwgY29tcGlsZXIgd2lsbCB1c2UgbGFzdCBzZXQgYHN5cy5pbnB1dHNgLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBtZWFucyB5b3Ugc2hvdWxkIGFsd2F5cyBzcGVjaWZ5IGlucHV0cyB3aGVuIHVzaW5nIGNvbXBpbGVyIGZvciBjb25jdXJyZW50IHRhc2tzLlxyXG4gICAqL1xyXG4gIGlucHV0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgc3dlZXQgb3B0aW9ucyBmb3IgY29tcGlsaW5nIGFuZCByZW5kZXJpbmcgdGhlIGRvY3VtZW50LlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU3dlZXRDb21waWxlT3B0aW9ucyA9IChcclxuICB8IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBwYXRoIG9mIHRoZSBtYWluIGZpbGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBtYWluRmlsZVBhdGg6IHN0cmluZztcclxuICAgIH1cclxuICB8IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBzb3VyY2UgY29udGVudCBvZiB0aGUgbWFpbiBmaWxlLlxyXG4gICAgICAgKi9cclxuICAgICAgbWFpbkNvbnRlbnQ6IHN0cmluZztcclxuICAgIH1cclxuKSAmXHJcbiAgQ29tcGlsZU9wdGlvbnNDb21tb247XHJcblxyXG4vKipcclxuICogVGhlIHN3ZWV0IG9wdGlvbnMgZm9yIGNvbXBpbGluZyBhbmQgcmVuZGVyaW5nIHRoZSBkb2N1bWVudC5cclxuICovXHJcbmV4cG9ydCB0eXBlIFN3ZWV0UmVuZGVyT3B0aW9ucyA9XHJcbiAgfCBTd2VldENvbXBpbGVPcHRpb25zXHJcbiAgfCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgYXJ0aWZhY3QgZGF0YSBpbiB2ZWN0b3IgZm9ybWF0LlxyXG4gICAgICAgKi9cclxuICAgICAgdmVjdG9yRGF0YTogVWludDhBcnJheTtcclxuICAgIH07XHJcblxyXG50eXBlIFJvbGUgPSAnY29tcGlsZXInIHwgJ3JlbmRlcmVyJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgc3dlZXQgc25pcHBldCBwcm92aWRlciBmb3IgYnVsbGRpbmcgdGhlIGNvbXBpbGVyIG9yIHJlbmRlcmVyIGNvbXBvbmVudC5cclxuICogU2VlIHtAbGluayBUeXBzdFNuaXBwZXQjdXNlfSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgZm9yUm9sZXM6IFJvbGVbXTtcclxuICBwcm92aWRlczogQmVmb3JlQnVpbGRGbltdO1xyXG59XHJcblxyXG5jb25zdCBpc05vZGUgPVxyXG4gIC8vIEB0cy1pZ25vcmVcclxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlbmllbnQgdXRpbCBjbGFzcyBmb3IgY29tcGlsaW5nIGRvY3VtZW50cywgd2hpY2ggaXMgYSB3cmFwcGVyIG9mIHRoZVxyXG4gKiB7QGxpbmsgVHlwc3RDb21waWxlcn0gYW5kIHtAbGluayBUeXBzdFJlbmRlcmVyfS5cclxuICpcclxuICogTm90ZTogdGhlIGludGVyZmFjZSBvZiB0aGlzIGNsYXNzIGlzIGxlc3Mgc3RhYmxlIHRoYW4ge0BsaW5rIFR5cHN0Q29tcGlsZXJ9XHJcbiAqIGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFVzZSB0aGUgKmdsb2JhbCBzaGFyZWQqIGNvbXBpbGVyIGluc3RhbmNlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7ICR0eXBzdCB9IGZyb20gJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzJztcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGU6IGlmIHlvdSB3YW50IHRvIGNvbXBpbGUgbXVsdGlwbGUgZG9jdW1lbnRzLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG5ld1xyXG4gKiBpbnN0YW5jZSBmb3IgZWFjaCBjb21waWxhdGlvbiB3b3JrIG9yIG1haW50YWluIHRoZSBzaGFyZWQgc3RhdGUgb24gdGhlXHJcbiAqIHV0aWxpdHkgaW5zdGFuY2UgYCR0eXBzdGAgY2FyZWZ1bGx5LCBiZWNhdXNlIHRoZSBjb21waWxhdGlvbiBwcm9jZXNzIHdpbGxcclxuICogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGF0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdXRpbGl0eTpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCAkdHlwc3QgPSBuZXcgVHlwc3RTbmlwcGV0KHtcclxuICogICAvLyBvcHRpb25hbCByZW5kZXJlciBpbnN0YW5jZVxyXG4gKiAgIHJlbmRlcmVyOiBlbmFibGVSZW5kZXJpbmcgPz8gKCgpID0+IHtcclxuICogICAgIHJldHVybiBjcmVhdGVHbG9iYWxSZW5kZXJlcihjcmVhdGVUeXBzdFJlbmRlcmVyLFxyXG4gKiAgICAgICB1bmRlZmluZWQsIGluaXRPcHRpb25zKTtcclxuICogICB9KSxcclxuICogICBjb21waWxlcigpID0+IHtcclxuICogICAgIHJldHVybiBjcmVhdGVHbG9iYWxDb21waWxlcihjcmVhdGVUeXBzdENvbXBpbGVyLFxyXG4gKiAgICAgICBpbml0T3B0aW9ucyk7XHJcbiAqICAgfVxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHlwc3RTbmlwcGV0IHtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHJpdmF0ZSBtYWluRmlsZVBhdGg6IHN0cmluZztcclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHJpdmF0ZSBjYz86IFByb21pc2VKdXN0PFR5cHN0Q29tcGlsZXI+O1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwcml2YXRlIGV4PzogUHJvbWlzZUp1c3Q8VHlwc3RSZW5kZXJlcj47XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHlwc3RTbmlwcGV0fS5cclxuICAgKiBAcGFyYW0gY2MgdGhlIGNvbXBpbGVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0Q29tcGlsZXJ9LlxyXG4gICAqIEBwYXJhbSBleCB0aGUgcmVuZGVyZXIgaW5zdGFuY2UsIHNlZSB7QGxpbmsgUHJvbWlzZUp1c3R9IGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogUGFzc2VzIGEgZ2xvYmFsIHNoYXJlZCBjb21waWxlciBpbnN0YW5jZSB0aGF0IGdldCBpbml0aWFsaXplZCBsYXppbHk6XHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0ICR0eXBzdCA9IG5ldyBUeXBzdFNuaXBwZXQoKCkgPT4ge1xyXG4gICAqICByZXR1cm4gY3JlYXRlR2xvYmFsQ29tcGlsZXIoY3JlYXRlVHlwc3RDb21waWxlciwgaW5pdE9wdGlvbnMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IHtcclxuICAgIGNvbXBpbGVyPzogUHJvbWlzZUp1c3Q8VHlwc3RDb21waWxlcj47XHJcbiAgICByZW5kZXJlcj86IFByb21pc2VKdXN0PFR5cHN0UmVuZGVyZXI+O1xyXG4gIH0pIHtcclxuICAgIHRoaXMuY2MgPSBvcHRpb25zPy5jb21waWxlciB8fCBUeXBzdFNuaXBwZXQuYnVpbGRMb2NhbENvbXBpbGVyO1xyXG4gICAgdGhpcy5leCA9IG9wdGlvbnM/LnJlbmRlcmVyIHx8IFR5cHN0U25pcHBldC5idWlsZExvY2FsUmVuZGVyZXI7XHJcbiAgICB0aGlzLm1haW5GaWxlUGF0aCA9ICcvbWFpbi50eXAnO1xyXG4gICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBsYXp5IGluaXRpYWxpemVkIGNvbXBpbGVyIGluc3RhbmNlIGZvciB0aGUgdXRpbGl0eSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gY2MgdGhlIGNvbXBpbGVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0Q29tcGlsZXJ9LlxyXG4gICAqL1xyXG4gIHNldENvbXBpbGVyKGNjOiBQcm9taXNlSnVzdDxUeXBzdENvbXBpbGVyPikge1xyXG4gICAgdGhpcy5jYyA9IGNjO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIGluaXRpYWxpemVkIGNvbXBpbGVyIGluc3RhbmNlIGZyb20gdGhlIHV0aWxpdHkgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q29tcGlsZXIoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB0aGlzLmNjID09PSAnZnVuY3Rpb24nID8gKHRoaXMuY2MgPSBhd2FpdCB0aGlzLmNjKCkpIDogdGhpcy5jYykhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGxhenkgaW5pdGlhbGl6ZWQgcmVuZGVyZXIgaW5zdGFuY2UgZm9yIHRoZSB1dGlsaXR5IGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSBleCB0aGUgcmVuZGVyZXIgaW5zdGFuY2UsIHNlZSB7QGxpbmsgUHJvbWlzZUp1c3R9IGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAgICovXHJcbiAgc2V0UmVuZGVyZXIoZXg6IFByb21pc2VKdXN0PFR5cHN0UmVuZGVyZXI+KSB7XHJcbiAgICB0aGlzLmV4ID0gZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYW4gaW5pdGlhbGl6ZWQgcmVuZGVyZXIgaW5zdGFuY2UgZnJvbSB0aGUgdXRpbGl0eSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBhc3luYyBnZXRSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdGhpcy5leCA9PT0gJ2Z1bmN0aW9uJyA/ICh0aGlzLmV4ID0gYXdhaXQgdGhpcy5leCgpKSA6IHRoaXMuZXg7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHByb3ZpZGVycz86IFByb21pc2VKdXN0PFR5cHN0U25pcHBldFByb3ZpZGVyPltdO1xyXG4gIC8qKlxyXG4gICAqIGFkZCBwcm92aWRlcnMgZm9yIGJ1bGxkaW5nIHRoZSBjb21waWxlciBvciByZW5kZXJlciBjb21wb25lbnQuXHJcbiAgICovXHJcbiAgdXNlKC4uLnByb3ZpZGVyczogUHJvbWlzZUp1c3Q8VHlwc3RTbmlwcGV0UHJvdmlkZXI+W10pIHtcclxuICAgIGlmICghdGhpcy5wcm92aWRlcnMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHJlYWR5IHByZXBhcmUgdXNlcyBmb3IgaW5zdGFuY2VzJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnByb3ZpZGVycy5wdXNoKC4uLnByb3ZpZGVycyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiB0b2RvOiBhZGQgZG9jc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBwcmVsb2FkRm9udEZyb21VcmwoZm9udFVybDogc3RyaW5nKTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIFR5cHN0U25pcHBldC5wcmVsb2FkRm9udHMoW2ZvbnRVcmxdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHRvZG86IGFkZCBkb2NzXHJcbiAgICovXHJcbiAgc3RhdGljIHByZWxvYWRGb250RGF0YShmb250RGF0YTogVWludDhBcnJheSk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiBUeXBzdFNuaXBwZXQucHJlbG9hZEZvbnRzKFtmb250RGF0YV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogdG9kbzogYWRkIGRvY3NcclxuICAgKi9cclxuICBzdGF0aWMgcHJlbG9hZEZvbnRzKHVzZXJGb250czogKHN0cmluZyB8IFVpbnQ4QXJyYXkpW10pOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdhY2Nlc3MtbW9kZWwnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3ByZWxvYWRSZW1vdGVGb250cyh1c2VyRm9udHMpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBkb24ndCBsb2FkIGFueSBkZWZhdWx0IGZvbnQgYXNzZXRzLlxyXG4gICAqIHRvZG86IGFkZCBkb2NzXHJcbiAgICovXHJcbiAgc3RhdGljIGRpc2FibGVEZWZhdWx0Rm9udEFzc2V0cygpOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdhY2Nlc3MtbW9kZWwnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW2Rpc2FibGVEZWZhdWx0Rm9udEFzc2V0cygpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiB0b2RvOiBhZGQgZG9jc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBwcmVsb2FkRm9udEFzc2V0cyhvcHRpb25zPzogTG9hZFJlbW90ZUFzc2V0c09wdGlvbnMpOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdhY2Nlc3MtbW9kZWwnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3ByZWxvYWRGb250QXNzZXRzKG9wdGlvbnMpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgYWNjZXNzbCBtb2RlbCBmb3IgdGhlIGNvbXBpbGVyIGluc3RhbmNlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBtZW1vcnkgYWNjZXNzIG1vZGVsXHJcbiAgICpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgbSA9IG5ldyBNZW1vcnlBY2Nlc3NNb2RlbCgpO1xyXG4gICAqICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LndpdGhBY2Nlc3NNb2RlbChtKSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgc3RhdGljIHdpdGhBY2Nlc3NNb2RlbChhY2Nlc3NNb2RlbDogV3JpdGFibGVBY2Nlc3NNb2RlbCk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ2FjY2Vzcy1tb2RlbCcsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzOiBbd2l0aEFjY2Vzc01vZGVsKGFjY2Vzc01vZGVsKV0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHBhY2thZ2UgcmVnaXN0cnkgZm9yIHRoZSBjb21waWxlciBpbnN0YW5jZVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiB1c2UgYSBjdXN0b21pemVkIHBhY2thZ2UgcmVnaXN0cnlcclxuICAgKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBuID0gbmV3IE5vZGVGZXRjaFBhY2thZ2VSZWdpc3RyeSgpO1xyXG4gICAqICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LndpdGhQYWNrYWdlUmVnaXN0cnkobikpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIHN0YXRpYyB3aXRoUGFja2FnZVJlZ2lzdHJ5KHJlZ2lzdHJ5OiBQYWNrYWdlUmVnaXN0cnkpOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdwYWNrYWdlLXJlZ2lzdHJ5JyxcclxuICAgICAgZm9yUm9sZXM6IFsnY29tcGlsZXInXSxcclxuICAgICAgcHJvdmlkZXM6IFt3aXRoUGFja2FnZVJlZ2lzdHJ5KHJlZ2lzdHJ5KV0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgYW4gYWNjZXNzIG1vZGVsIHRvIHN0b3JlIHRoZSBkYXRhIG9mIGZldGNoZWQgZmlsZXMuXHJcbiAgICogUHJvdmlkZSBhIFBhY2thZ2VSZWdpc3RyeSBpbnN0YW5jZSBmb3IgdGhlIGNvbXBpbGVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBkZWZhdWx0IChtZW1vcnkpIGFjY2VzcyBtb2RlbFxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqICR0eXBzdC51c2UoYXdhaXQgVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZVJlZ2lzdHJ5KCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBleHRlcm5hbCBhY2Nlc3MgbW9kZWxcclxuICAgKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBtID0gbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pLCBhd2FpdCBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlUmVnaXN0cnkobSkpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIHN0YXRpYyBmZXRjaFBhY2thZ2VSZWdpc3RyeShhY2Nlc3NNb2RlbD86IFdyaXRhYmxlQWNjZXNzTW9kZWwpOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICBjb25zdCBtID0gYWNjZXNzTW9kZWwgfHwgbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICBjb25zdCBwcm92aWRlcyA9IFtcclxuICAgICAgLi4uKGFjY2Vzc01vZGVsID8gW10gOiBbd2l0aEFjY2Vzc01vZGVsKG0pXSksXHJcbiAgICAgIHdpdGhQYWNrYWdlUmVnaXN0cnkobmV3IEZldGNoUGFja2FnZVJlZ2lzdHJ5KG0pKSxcclxuICAgIF07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6ICdwYWNrYWdlLXJlZ2lzdHJ5JGZldGNoJyxcclxuICAgICAgZm9yUm9sZXM6IFsnY29tcGlsZXInXSxcclxuICAgICAgcHJvdmlkZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgYSBmZXRjaGVyIGZvciBmZXRjaGluZyBwYWNrYWdlIGRhdGEuXHJcbiAgICogUHJvdmlkZSBhIFBhY2thZ2VSZWdpc3RyeSBpbnN0YW5jZSBmb3IgdGhlIGNvbXBpbGVyIGluc3RhbmNlLlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiB1c2UgYSBjdXN0b21pemVkIGZldGNoZXJcclxuICAgKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBpbXBvcnQgcmVxdWVzdCBmcm9tICdzeW5jLXJlcXVlc3QtY3VybCc7XHJcbiAgICogY29uc3QgbSA9IG5ldyBNZW1vcnlBY2Nlc3NNb2RlbCgpO1xyXG4gICAqICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LndpdGhBY2Nlc3NNb2RlbChtKSwgYXdhaXQgVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZUJ5KG0sIChfLCBodHRwVXJsKSA9PiB7XHJcbiAgICogICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QoJ0dFVCcsIHRoaXMucmVzb2x2ZVBhdGgocGF0aCksIHtcclxuICAgKiAgICAgaW5zZWN1cmU6IHRydWUsXHJcbiAgICogICB9KTtcclxuICAgKlxyXG4gICAqICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xyXG4gICAqICAgICByZXR1cm4gcmVzcG9uc2UuZ2V0Qm9keSh1bmRlZmluZWQpO1xyXG4gICAqICAgfVxyXG4gICAqICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgKiB9KSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgc3RhdGljIGZldGNoUGFja2FnZUJ5KFxyXG4gICAgYWNjZXNzTW9kZWw6IFdyaXRhYmxlQWNjZXNzTW9kZWwsXHJcbiAgICBmZXRjaGVyOiAocGF0aDogUGFja2FnZVNwZWMsIGRlZmF1bHRIdHRwVXJsOiBzdHJpbmcpID0+IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXHJcbiAgKTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgY2xhc3MgSHR0cFBhY2thZ2VSZWdpc3RyeSBleHRlbmRzIEZldGNoUGFja2FnZVJlZ2lzdHJ5IHtcclxuICAgICAgcHVsbFBhY2thZ2VEYXRhKHBhdGg6IFBhY2thZ2VTcGVjKTogVWludDhBcnJheSB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgcmV0dXJuIGZldGNoZXIocGF0aCwgdGhpcy5yZXNvbHZlUGF0aChwYXRoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ3BhY2thZ2UtcmVnaXN0cnkkbGFtYmRhJyxcclxuICAgICAgZm9yUm9sZXM6IFsnY29tcGlsZXInXSxcclxuICAgICAgcHJvdmlkZXM6IFt3aXRoUGFja2FnZVJlZ2lzdHJ5KG5ldyBIdHRwUGFja2FnZVJlZ2lzdHJ5KGFjY2Vzc01vZGVsKSldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBjY09wdGlvbnM6IFBhcnRpYWw8SW5pdE9wdGlvbnM+O1xyXG4gIC8qKlxyXG4gICAqIFNldCBjb21waWxlciBpbml0IG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyBnbG9iYWwgaW5zdGFuY2Uge0BsaW5rICR0eXBzdH0uXHJcbiAgICogU2VlIHtAbGluayBJbml0T3B0aW9uc30uXHJcbiAgICovXHJcbiAgc2V0Q29tcGlsZXJJbml0T3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPEluaXRPcHRpb25zPikge1xyXG4gICAgdGhpcy5yZXF1aXJlSXNVbmluaXRpYWxpemVkKCdjb21waWxlcicsIHRoaXMuY2MpO1xyXG4gICAgdGhpcy5jY09wdGlvbnMgPSBvcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGV4T3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz47XHJcbiAgLyoqXHJcbiAgICogU2V0IHJlbmRlcmVyIGluaXQgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIGdsb2JhbCBpbnN0YW5jZSB7QGxpbmsgJHR5cHN0fS5cclxuICAgKiBTZWUge0BsaW5rIEluaXRPcHRpb25zfS5cclxuICAgKi9cclxuICBzZXRSZW5kZXJlckluaXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8SW5pdE9wdGlvbnM+KSB7XHJcbiAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ3JlbmRlcmVyJywgdGhpcy5leCk7XHJcbiAgICB0aGlzLmV4T3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgc2hhcmVkIG1haW4gZmlsZSBwYXRoLlxyXG4gICAqL1xyXG4gIHNldE1haW5GaWxlUGF0aChwYXRoOiBzdHJpbmcpIHtcclxuICAgIHRoaXMubWFpbkZpbGVQYXRoID0gcGF0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzaGFyZWQgbWFpbiBmaWxlIHBhdGguXHJcbiAgICovXHJcbiAgZ2V0TWFpbkZpbGVQYXRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFpbkZpbGVQYXRoO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlVG1wKG9wdHM6IENvbXBpbGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAob3B0cy5tYWluRmlsZVBhdGguc3RhcnRzV2l0aCgnL3RtcC8nKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy51bm1hcFNoYWRvdyhvcHRzLm1haW5GaWxlUGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc291cmNlIGZpbGUgdG8gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNhZGRTb3VyY2V9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGFkZFNvdXJjZShwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSkuYWRkU291cmNlKHBhdGgsIGNvbnRlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHNoYWRvdyBmaWxlcy5cclxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIGluZGVwZW5kZW50IHRvIHRoZSB7QGxpbmsgcmVzZXR9IGZ1bmN0aW9uLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNyZXNldFNoYWRvd30uXHJcbiAgICovXHJcbiAgYXN5bmMgcmVzZXRTaGFkb3coKSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS5yZXNldFNoYWRvdygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2hhZG93IGZpbGUgdG8gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNtYXBTaGFkb3d9LlxyXG4gICAqL1xyXG4gIGFzeW5jIG1hcFNoYWRvdyhwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IFVpbnQ4QXJyYXkpIHtcclxuICAgIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpLm1hcFNoYWRvdyhwYXRoLCBjb250ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIHNoYWRvdyBmaWxlIGZyb20gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciN1bm1hcFNoYWRvd30uXHJcbiAgICovXHJcbiAgYXN5bmMgdW5tYXBTaGFkb3cocGF0aDogc3RyaW5nKSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS51bm1hcFNoYWRvdyhwYXRoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgdGhlIGRvY3VtZW50IHRvIHZlY3RvciAoSVIpIGZvcm1hdC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0Q29tcGlsZU9wdGlvbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIHZlY3RvcihvPzogU3dlZXRDb21waWxlT3B0aW9ucykge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLmNvbXBpbGUob3B0cylcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5yZXN1bHQpXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgdGhlIGRvY3VtZW50IHRvIFBERiBmb3JtYXQuXHJcbiAgICogU2VlIHtAbGluayBTd2VldENvbXBpbGVPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyBwZGYobz86IFN3ZWV0Q29tcGlsZU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgb3B0cy5mb3JtYXQgPSAncGRmJztcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKVxyXG4gICAgICAuY29tcGlsZShvcHRzKVxyXG4gICAgICAudGhlbihyZXMgPT4gcmVzLnJlc3VsdClcclxuICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5yZW1vdmVUbXAob3B0cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZSB0aGUgZG9jdW1lbnQgdG8gU1ZHIGZvcm1hdC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0UmVuZGVyT3B0aW9uc30gYW5kIHtAbGluayBSZW5kZXJTdmdPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyBzdmcobz86IFN3ZWV0UmVuZGVyT3B0aW9ucyAmIFJlbmRlclN2Z09wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaWVudFJlbmRlcihvLCAocmVuZGVyZXIsIHJlbmRlclNlc3Npb24pID0+XHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlclN2Zyh7XHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICByZW5kZXJTZXNzaW9uLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlIHRoZSBkb2N1bWVudCB0byBjYW52YXMgb3BlcmF0aW9ucy5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0UmVuZGVyT3B0aW9uc30gYW5kIHtAbGluayBSZW5kZXJUb0NhbnZhc09wdGlvbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGNhbnZhcyhcclxuICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXHJcbiAgICBvPzogU3dlZXRSZW5kZXJPcHRpb25zICYgT21pdDxSZW5kZXJUb0NhbnZhc09wdGlvbnMsICdjb250YWluZXInPixcclxuICApIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaWVudFJlbmRlcihvLCAocmVuZGVyZXIsIHJlbmRlclNlc3Npb24pID0+XHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRvQ2FudmFzKHtcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICByZW5kZXJTZXNzaW9uLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc2VtYW50aWMgdG9rZW5zIGZvciB0aGUgZG9jdW1lbnQuXHJcbiAgICovXHJcbiAgYXN5bmMgcXVlcnk8VD4obzogU3dlZXRDb21waWxlT3B0aW9ucyAmIHsgc2VsZWN0b3I6IHN0cmluZzsgZmllbGQ/OiBzdHJpbmcgfSk6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLnF1ZXJ5PFQ+KHtcclxuICAgICAgICAuLi5vLFxyXG4gICAgICAgIC4uLm9wdHMsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0b2tlbiBsZWdlbmQgZm9yIHNlbWFudGljIHRva2Vucy5cclxuICAgKi9cclxuICBhc3luYyBnZXRTZW1hbnRpY1Rva2VuTGVnZW5kKCk6IFByb21pc2U8U2VtYW50aWNUb2tlbnNMZWdlbmQ+IHtcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS5nZXRTZW1hbnRpY1Rva2VuTGVnZW5kKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc2VtYW50aWMgdG9rZW5zIGZvciB0aGUgZG9jdW1lbnQuXHJcbiAgICogU2VlIHtAbGluayBTd2VldENvbXBpbGVPcHRpb25zfS5cclxuICAgKiBTZWUge0BsaW5rIFR5cHN0Q29tcGlsZXIjZ2V0U2VtYW50aWNUb2tlbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFNlbWFudGljVG9rZW5zKG86IFN3ZWV0Q29tcGlsZU9wdGlvbnMgJiB7IHJlc3VsdElkPzogc3RyaW5nIH0pOiBQcm9taXNlPFNlbWFudGljVG9rZW5zPiB7XHJcbiAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRDb21waWxlT3B0aW9ucyhvKTtcclxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKVxyXG4gICAgICAuZ2V0U2VtYW50aWNUb2tlbnMoe1xyXG4gICAgICAgIG1haW5GaWxlUGF0aDogb3B0cy5tYWluRmlsZVBhdGgsXHJcbiAgICAgICAgcmVzdWx0SWQ6IG8ucmVzdWx0SWQsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q29tcGlsZU9wdGlvbnMoXHJcbiAgICBvcHRzPzogU3dlZXRDb21waWxlT3B0aW9ucyxcclxuICApOiBQcm9taXNlPENvbXBpbGVPcHRpb25zPGFueSwgJ25vbmUnPj4ge1xyXG4gICAgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4geyBtYWluRmlsZVBhdGg6IHRoaXMubWFpbkZpbGVQYXRoLCBkaWFnbm9zdGljczogJ25vbmUnIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBsZWFzZSBzcGVjaWZ5IG9wdHMgYXMge21haW5Db250ZW50OiAnLi4uJ30gb3Ige21haW5GaWxlUGF0aDogJy4uLid9YCk7XHJcbiAgICB9IGVsc2UgaWYgKCdtYWluRmlsZVBhdGgnIGluIG9wdHMpIHtcclxuICAgICAgcmV0dXJuIHsgLi4ub3B0cywgZGlhZ25vc3RpY3M6ICdub25lJyB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgZGVzdEZpbGUgPSBgL3RtcC8ke3JhbmRzdHIoKX0udHlwYDtcclxuICAgICAgYXdhaXQgdGhpcy5hZGRTb3VyY2UoZGVzdEZpbGUsIG9wdHMubWFpbkNvbnRlbnQpO1xyXG4gICAgICByZXR1cm4geyBtYWluRmlsZVBhdGg6IGRlc3RGaWxlLCBpbnB1dHM6IG9wdHMuaW5wdXRzLCBkaWFnbm9zdGljczogJ25vbmUnIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldFZlY3RvcihvPzogU3dlZXRSZW5kZXJPcHRpb25zKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICBpZiAobyAmJiAndmVjdG9yRGF0YScgaW4gbykge1xyXG4gICAgICByZXR1cm4gby52ZWN0b3JEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpXHJcbiAgICAgIC5jb21waWxlKG9wdHMpXHJcbiAgICAgIC50aGVuKHJlcyA9PiByZXMucmVzdWx0ISlcclxuICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5yZW1vdmVUbXAob3B0cykpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyB0cmFuc2llbnRSZW5kZXI8VD4oXHJcbiAgICBvcHRzOiBTd2VldFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQsXHJcbiAgICBmOiAocnI6IFR5cHN0UmVuZGVyZXIsIHNlc3Npb246IFJlbmRlclNlc3Npb24pID0+IFQsXHJcbiAgKTogUHJvbWlzZTxUPiB7XHJcbiAgICBjb25zdCByciA9IGF3YWl0IHRoaXMuZ2V0UmVuZGVyZXIoKTtcclxuICAgIGlmICghcnIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb2VzIG5vdCBwcm92aWRlIHJlbmRlcmVyIGluc3RhbmNlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRWZWN0b3Iob3B0cyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcnIucnVuV2l0aFNlc3Npb24oYXN5bmMgc2Vzc2lvbiA9PiB7XHJcbiAgICAgIHJyLm1hbmlwdWxhdGVEYXRhKHtcclxuICAgICAgICByZW5kZXJTZXNzaW9uOiBzZXNzaW9uLFxyXG4gICAgICAgIGFjdGlvbjogJ3Jlc2V0JyxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGYocnIsIHNlc3Npb24pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcmVwYXJlVXNlT25jZTogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICBwcml2YXRlIGFzeW5jIHByZXBhcmVVc2UoKSB7XHJcbiAgICBpZiAodGhpcy5wcmVwYXJlVXNlT25jZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcmVwYXJlVXNlT25jZTtcclxuICAgIH1cclxuICAgIHJldHVybiAodGhpcy5wcmVwYXJlVXNlT25jZSA9IHRoaXMuZG9QcmVwYXJlVXNlKCkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBkb1ByZXBhcmVVc2UoKSB7XHJcbiAgICBpZiAoIXRoaXMucHJvdmlkZXJzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwcm92aWRlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgdGhpcy5wcm92aWRlcnMubWFwKHAgPT4gKHR5cGVvZiBwID09PSAnZnVuY3Rpb24nID8gcCgpIDogcCkpLFxyXG4gICAgKTtcclxuICAgIHRoaXMucHJvdmlkZXJzID0gW107XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAkdHlwc3QgPT0gdGhpcyAmJlxyXG4gICAgICAhcHJvdmlkZXJzLnNvbWUocCA9PiBwLmtleS5pbmNsdWRlcygncGFja2FnZS1yZWdpc3RyeScpIHx8IHAua2V5LmluY2x1ZGVzKCdhY2Nlc3MtbW9kZWwnKSlcclxuICAgICkge1xyXG4gICAgICAvLyBOb3RlOiB0aGUgZGVmYXVsdCBmZXRjaCBiYWNrZW5kIGFsd2F5cyBhZGRzIGEgd2l0aEFjY2Vzc01vZGVsKG1lbSlcclxuICAgICAgaWYgKGlzTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGVzY2FwZUltcG9ydCA9IG5ldyBGdW5jdGlvbignbScsICdyZXR1cm4gaW1wb3J0KG0pJyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogcmVxdWVzdCB9ID0gYXdhaXQgZXNjYXBlSW1wb3J0KCdzeW5jLXJlcXVlc3QnKTtcclxuXHJcbiAgICAgICAgICAkdHlwc3QudXNlKFxyXG4gICAgICAgICAgICBUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pLFxyXG4gICAgICAgICAgICBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlQnkobSwgKF86IHVua25vd24sIHBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdCgnR0VUJywgcGF0aCk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5nZXRCb2R5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZVJlZ2lzdHJ5KCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvdmlkZXJzMiA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICB0aGlzLnByb3ZpZGVycy5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdmdW5jdGlvbicgPyBwKCkgOiBwKSksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNjT3B0aW9ucyA9ICh0aGlzLmNjT3B0aW9ucyB8fD0ge30pO1xyXG4gICAgY29uc3QgY2NCZWZvcmVCdWlsZCA9IChjY09wdGlvbnMuYmVmb3JlQnVpbGQgfHw9IFtdKTtcclxuXHJcbiAgICBjb25zdCBleE9wdGlvbnMgPSAodGhpcy5leE9wdGlvbnMgfHw9IHt9KTtcclxuICAgIGNvbnN0IGV4QmVmb3JlQnVpbGQgPSAoZXhPcHRpb25zLmJlZm9yZUJ1aWxkIHx8PSBbXSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBbLi4ucHJvdmlkZXJzLCAuLi5wcm92aWRlcnMyXSkge1xyXG4gICAgICBpZiAocHJvdmlkZXIuZm9yUm9sZXMuaW5jbHVkZXMoJ2NvbXBpbGVyJykpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ2NvbXBpbGVyJywgdGhpcy5jYyk7XHJcbiAgICAgICAgY2NCZWZvcmVCdWlsZC5wdXNoKC4uLnByb3ZpZGVyLnByb3ZpZGVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvdmlkZXIuZm9yUm9sZXMuaW5jbHVkZXMoJ3JlbmRlcmVyJykpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ3JlbmRlcmVyJywgdGhpcy5leCk7XHJcbiAgICAgICAgZXhCZWZvcmVCdWlsZC5wdXNoKC4uLnByb3ZpZGVyLnByb3ZpZGVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5wcm92aWRlcnMgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQ8VD4ocm9sZTogc3RyaW5nLCBjOiBQcm9taXNlSnVzdDxUPiwgZT86IFByb21pc2VKdXN0PFQ+KSB7XHJcbiAgICBpZiAoYyAmJiB0eXBlb2YgYyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cm9sZX0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQ6ICR7Y31gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgYXN5bmMgYnVpbGRMb2NhbENvbXBpbGVyKHRoaXM6IFR5cHN0U25pcHBldCkge1xyXG4gICAgY29uc3QgeyBjcmVhdGVUeXBzdENvbXBpbGVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9jb21waWxlcidcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9jb21waWxlci5tanMnKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnByZXBhcmVVc2UoKTtcclxuICAgIGNvbnN0IGNvbXBpbGVyID0gY3JlYXRlVHlwc3RDb21waWxlcigpO1xyXG4gICAgYXdhaXQgY29tcGlsZXIuaW5pdCh0aGlzLmNjT3B0aW9ucyk7XHJcbiAgICByZXR1cm4gY29tcGlsZXI7XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc3RhdGljIGFzeW5jIGJ1aWxkR2xvYmFsQ29tcGlsZXIodGhpczogVHlwc3RTbmlwcGV0KSB7XHJcbiAgICAvLyBsYXp5IGltcG9ydCBjb21waWxlIG1vZHVsZVxyXG4gICAgY29uc3QgeyBjcmVhdGVHbG9iYWxDb21waWxlciB9ID0gKGF3YWl0IGltcG9ydChcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAnQG15cmlhZGRyZWFtaW4vdHlwc3QudHMvY29udHJpYi9nbG9iYWwtY29tcGlsZXInXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi9nbG9iYWwtY29tcGlsZXIubWpzJyk7XHJcbiAgICBjb25zdCB7IGNyZWF0ZVR5cHN0Q29tcGlsZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL2NvbXBpbGVyJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4uL2NvbXBpbGVyLm1qcycpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVVzZSgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUdsb2JhbENvbXBpbGVyKGNyZWF0ZVR5cHN0Q29tcGlsZXIsIHRoaXMuY2NPcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgYXN5bmMgYnVpbGRMb2NhbFJlbmRlcmVyKHRoaXM6IFR5cHN0U25pcHBldCkge1xyXG4gICAgY29uc3QgeyBjcmVhdGVUeXBzdFJlbmRlcmVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9yZW5kZXJlcidcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9yZW5kZXJlci5tanMnKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnByZXBhcmVVc2UoKTtcclxuICAgIGNvbnN0IHJlbmRlcmVyID0gY3JlYXRlVHlwc3RSZW5kZXJlcigpO1xyXG4gICAgYXdhaXQgcmVuZGVyZXIuaW5pdCh0aGlzLmV4T3B0aW9ucyk7XHJcbiAgICByZXR1cm4gcmVuZGVyZXI7XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc3RhdGljIGFzeW5jIGJ1aWxkR2xvYmFsUmVuZGVyZXIodGhpczogVHlwc3RTbmlwcGV0KSB7XHJcbiAgICAvLyBsYXp5IGltcG9ydCByZW5kZXJlciBtb2R1bGVcclxuICAgIGNvbnN0IHsgY3JlYXRlR2xvYmFsUmVuZGVyZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL2NvbnRyaWIvZ2xvYmFsLXJlbmRlcmVyJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4vZ2xvYmFsLXJlbmRlcmVyLm1qcycpO1xyXG4gICAgY29uc3QgeyBjcmVhdGVUeXBzdFJlbmRlcmVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9yZW5kZXJlcidcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9yZW5kZXJlci5tanMnKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnByZXBhcmVVc2UoKTtcclxuICAgIHJldHVybiBjcmVhdGVHbG9iYWxSZW5kZXJlcihjcmVhdGVUeXBzdFJlbmRlcmVyLCB0aGlzLmV4T3B0aW9ucyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxhenkgaW5pdGlhbGl6ZWQgZ2xvYmFsIHNoYXJlZCBpbnN0YW5jZSBvZiB7QGxpbmsgVHlwc3RTbmlwcGV0fS4gU2VlXHJcbiAqIHtAbGluayBUeXBzdFNuaXBwZXR9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgJHR5cHN0ID0gbmV3IFR5cHN0U25pcHBldCh7XHJcbiAgY29tcGlsZXI6IFR5cHN0U25pcHBldC5idWlsZEdsb2JhbENvbXBpbGVyLFxyXG4gIHJlbmRlcmVyOiBUeXBzdFNuaXBwZXQuYnVpbGRHbG9iYWxSZW5kZXJlcixcclxufSk7XHJcbiJdfQ==