var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  changeViewPerspective: () => changeViewPerspective,
  interpretTargetView: () => interpretTargetView,
  patchRoot: () => patchRoot
});
module.exports = __toCommonJS(stdin_exports);
var TypstSvgAttrs;
(function(TypstSvgAttrs2) {
  TypstSvgAttrs2["Tid"] = "data-tid";
  TypstSvgAttrs2["ReuseFrom"] = "data-reuse-from";
})(TypstSvgAttrs || (TypstSvgAttrs = {}));
function isGElem(node) {
  return node.tagName === "g";
}
function equalElem(prev, next) {
  const prevDataTid = prev.getAttribute(TypstSvgAttrs.Tid);
  const nextDataTid = next.getAttribute(TypstSvgAttrs.Tid);
  return prevDataTid && prevDataTid === nextDataTid;
}
function interpretTargetView(originChildren, targetChildren, tIsU = (_x) => true) {
  const availableOwnedResource = /* @__PURE__ */ new Map();
  const targetView = [];
  for (let i = 0; i < originChildren.length; i++) {
    const prevChild = originChildren[i];
    if (!tIsU(prevChild)) {
      continue;
    }
    const data_tid = prevChild.getAttribute(TypstSvgAttrs.Tid);
    if (!data_tid) {
      targetView.push(["remove", i]);
      continue;
    }
    if (!availableOwnedResource.has(data_tid)) {
      availableOwnedResource.set(data_tid, [prevChild, []]);
    }
    availableOwnedResource.get(data_tid)[1].push(i);
  }
  const toPatch = [];
  for (let i = 0; i < targetChildren.length; i++) {
    const nextChild = targetChildren[i];
    if (!tIsU(nextChild)) {
      continue;
    }
    const nextDataTid = nextChild.getAttribute(TypstSvgAttrs.Tid);
    if (!nextDataTid) {
      throw new Error("not data tid for reusing g element for " + nextDataTid);
    }
    const reuseTargetTid = nextChild.getAttribute(TypstSvgAttrs.ReuseFrom);
    if (!reuseTargetTid) {
      targetView.push(["append", nextChild]);
      continue;
    }
    if (!availableOwnedResource.has(reuseTargetTid)) {
      throw new Error("no available resource for reuse " + reuseTargetTid);
    }
    const rsrc = availableOwnedResource.get(reuseTargetTid);
    const prevIdx = rsrc[1].shift();
    if (prevIdx === void 0) {
      if (nextDataTid === reuseTargetTid) {
        const clonedNode = rsrc[0].cloneNode(true);
        toPatch.push([clonedNode, nextChild]);
        targetView.push(["append", clonedNode]);
      } else {
        targetView.push(["append", nextChild]);
      }
      continue;
    }
    toPatch.push([originChildren[prevIdx], nextChild]);
    targetView.push(["reuse", prevIdx]);
  }
  for (let [_, unusedIndices] of availableOwnedResource.values()) {
    for (let unused of unusedIndices) {
      targetView.push(["remove", unused]);
    }
  }
  return [targetView, toPatch];
}
function changeViewPerspective(originChildren, targetView, tIsU = (_x) => true) {
  const originView = [];
  let removeIndices = [];
  for (let inst of targetView) {
    if (inst[0] === "remove") {
      removeIndices.push(inst[1]);
    }
  }
  removeIndices = removeIndices.sort((a, b) => a - b);
  const removeShift = [];
  {
    let r = 0;
    for (let i = 0; i < removeIndices.length; i++) {
      while (r < removeIndices[i]) {
        removeShift.push(r - i);
        r++;
      }
      removeShift.push(void 0);
      originView.push(["remove", removeIndices[i] - i]);
      r++;
    }
    while (r <= originChildren.length) {
      removeShift.push(r - removeIndices.length);
      r++;
    }
  }
  const getShift = (off) => {
    if (off >= removeShift.length || removeShift[off] === void 0) {
      throw new Error(`invalid offset ${off} for getShift ${removeShift}`);
    }
    return removeShift[off];
  };
  let targetViewCursor = 0;
  let appendOffset = 0;
  const swapIns = [];
  const inserts = [];
  const interpretOriginView = (off) => {
    off = getShift(off);
    while (targetViewCursor < targetView.length) {
      let done = false;
      const inst = targetView[targetViewCursor];
      switch (inst[0]) {
        case "append":
          inserts.push(["insert", appendOffset, inst[1]]);
          appendOffset++;
          break;
        case "reuse":
          const target_off = getShift(inst[1]);
          swapIns.push(target_off);
          appendOffset++;
          break;
        // case "remove":
        default:
          break;
      }
      targetViewCursor++;
      if (done) {
        break;
      }
    }
  };
  for (let off = 0; off < originChildren.length; off++) {
    const prevChild = originChildren[off];
    if (removeShift[off] === void 0) {
      continue;
    }
    if (!tIsU(prevChild)) {
      const target_off = getShift(off);
      swapIns.push(target_off);
      continue;
    }
    interpretOriginView(off);
  }
  interpretOriginView(originChildren.length);
  const simulated = [];
  for (let i = 0; i < swapIns.length; i++) {
    simulated.push(i);
  }
  for (let i = 0; i < swapIns.length; i++) {
    const off = swapIns[i];
    for (let j = 0; j < simulated.length; j++) {
      if (simulated[j] === off) {
        simulated.splice(j, 1);
        if (i <= j) {
          simulated.splice(i, 0, off);
        } else {
          simulated.splice(i + 1, 0, off);
        }
        if (j !== i) {
          originView.push(["swap_in", i, j]);
        }
        break;
      }
    }
  }
  return [...originView, ...inserts];
}
function runOriginViewInstructions(prev, originView) {
  for (const [op, off, fr] of originView) {
    switch (op) {
      case "insert":
        prev.insertBefore(fr, prev.children[off]);
        break;
      case "swap_in":
        prev.insertBefore(prev.children[fr], prev.children[off]);
        break;
      case "remove":
        prev.children[off].remove();
        break;
      default:
        throw new Error("unknown op " + op);
    }
  }
}
function patchRoot(prev, next) {
  patchAttributes(prev, next);
  patchSvgHeader(prev, next);
  patchChildren(prev, next);
  return;
  function patchSvgHeader(prev2, next2) {
    for (let i = 0; i < 3; i++) {
      const prevChild = prev2.children[i];
      const nextChild = next2.children[i];
      if (prevChild.tagName === "defs") {
        if (prevChild.getAttribute("class") === "glyph") {
          prevChild.append(...nextChild.children);
        } else if (prevChild.getAttribute("class") === "clip-path") {
          prevChild.append(...nextChild.children);
        }
      } else if (prevChild.tagName === "style" && nextChild.getAttribute("data-reuse") !== "1") {
        if (nextChild.textContent) {
          var doc = document.implementation.createHTMLDocument(""), styleElement = document.createElement("style");
          styleElement.textContent = nextChild.textContent;
          doc.body.appendChild(styleElement);
          const currentSvgSheet = prevChild.sheet;
          const rulesToInsert = styleElement.sheet?.cssRules || [];
          for (const rule of rulesToInsert) {
            currentSvgSheet.insertRule(rule.cssText);
          }
        }
      }
    }
  }
}
function patchAttributes(prev, next) {
  const prevAttrs = prev.attributes;
  const nextAttrs = next.attributes;
  if (prevAttrs.length === nextAttrs.length) {
    let same = true;
    for (let i = 0; i < prevAttrs.length; i++) {
      const prevAttr = prevAttrs[i];
      const nextAttr = nextAttrs.getNamedItem(prevAttr.name);
      if (nextAttr === null || prevAttr.value !== nextAttr.value) {
        same = false;
        break;
      }
    }
    if (same) {
      return;
    }
  }
  const removedAttrs = [];
  for (let i = 0; i < prevAttrs.length; i++) {
    removedAttrs.push(prevAttrs[i].name);
  }
  for (const attr of removedAttrs) {
    prev.removeAttribute(attr);
  }
  for (let i = 0; i < nextAttrs.length; i++) {
    prev.setAttribute(nextAttrs[i].name, nextAttrs[i].value);
  }
}
function patchChildren(prev, next) {
  const [targetView, toPatch] = interpretTargetView(prev.children, next.children, isGElem);
  for (let [prevChild, nextChild] of toPatch) {
    reuseOrPatchElem(prevChild, nextChild);
  }
  const originView = changeViewPerspective(prev.children, targetView, isGElem);
  runOriginViewInstructions(prev, originView);
}
function reuseOrPatchElem(prev, next) {
  const canReuse = equalElem(prev, next);
  next.removeAttribute(TypstSvgAttrs.ReuseFrom);
  patchAttributes(prev, next);
  if (canReuse) {
    return true;
  }
  replaceNonSVGElements(prev, next);
  patchChildren(prev, next);
  return false;
  function replaceNonSVGElements(prev2, next2) {
    const removedIndices = [];
    for (let i = 0; i < prev2.children.length; i++) {
      const prevChild = prev2.children[i];
      if (!isGElem(prevChild)) {
        removedIndices.push(i);
      }
    }
    for (const index of removedIndices.reverse()) {
      prev2.children[index].remove();
    }
    for (let i = 0; i < next2.children.length; i++) {
      const nextChild = next2.children[i];
      if (!isGElem(nextChild)) {
        prev2.appendChild(nextChild.cloneNode(true));
      }
    }
  }
}
