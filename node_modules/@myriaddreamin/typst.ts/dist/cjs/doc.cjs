var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  TypstDocument: () => TypstDocument
});
module.exports = __toCommonJS(stdin_exports);
var import_patch = require("./render/svg/patch.cjs");
class TypstDocument {
  props;
  session;
  sessionReady;
  disposeSession;
  constructor(props) {
    this.props = props;
    this.init();
  }
  static layoutPagesFullMode(doc) {
    return Promise.resolve(doc.session.retrievePagesInfo().map(() => {
      return {};
    }));
  }
  // copy from typst-preview
  static layoutSvgPagesPartialMode(doc, before) {
    const docRect = doc.shadowRoot.getBoundingClientRect();
    const cachedOffsetWidth = "offsetWidth" in doc.shadowRoot ? doc.shadowRoot.offsetWidth : Number.parseInt(window.getComputedStyle(doc.shadowRoot).width.replace("px", ""));
    const currentScaleRatio = 1;
    const computedRevScale = cachedOffsetWidth ? doc.session.docWidth / cachedOffsetWidth : 1;
    const revScale = computedRevScale / currentScaleRatio;
    const left = (window.screenLeft - docRect.left) * revScale;
    const top = (window.screenTop - docRect.top) * revScale;
    const width = window.innerWidth * revScale;
    const height = window.innerHeight * revScale;
    void before;
    const patchStr = doc.session.renderSvgDiff({
      window: {
        lo: {
          x: left,
          y: top
        },
        hi: {
          x: left + width,
          y: top + height
        }
      }
    });
    if (doc.shadowRoot.firstElementChild) {
      const elem = document.createElement("div");
      elem.innerHTML = patchStr;
      const svgElement = elem.firstElementChild;
      (0, import_patch.patchRoot)(doc.shadowRoot.firstElementChild, svgElement);
    } else {
      doc.shadowRoot.innerHTML = patchStr;
    }
    return Promise.resolve([]);
  }
  // copy from typst-preview
  // todo: generalize patchRoot here
  static layoutSvgPages(options) {
    return (doc, before) => {
      return TypstDocument.layoutSvgPagesPartialMode(doc, before);
    };
  }
  addChangements(change) {
    throw new Error("Method not implemented.");
  }
  renderPieces(pieces) {
    throw new Error("Method not implemented.");
  }
  onSessionReady() {
    return this.sessionReady;
  }
  dispose() {
    if (this.disposeSession !== void 0) {
      this.disposeSession();
    }
  }
  init() {
    if (this.sessionReady !== void 0) {
      throw new Error("Already initialized");
    }
    if (this.props.session !== void 0) {
      this.session = this.props.session;
      return this.sessionReady = Promise.resolve(this.session);
    }
    return this.sessionReady = new Promise((resolve) => {
      this.props.plugin.runWithSession((session) => {
        return new Promise((dispose) => {
          this.session = session;
          this.disposeSession = dispose;
          resolve(session);
        });
      });
    });
  }
}
