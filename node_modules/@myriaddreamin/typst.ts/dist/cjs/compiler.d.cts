import type * as typst from '@myriaddreamin/typst-ts-web-compiler';
import { SemanticTokens, SemanticTokensLegend } from "./internal.types.cjs";
import { type InitOptions } from "./options.init.cjs";
/**
 * Available formats for compiling the document.
 */
export type CompileFormat = 'vector' | 'pdf';
/**
 * The diagnostic message partially following the LSP specification.
 */
interface DiagnosticMessage {
    package: string;
    path: string;
    severity: string;
    range: string;
    message: string;
}
/**
 * Available formats for compiling the document.
 *
 * If set to unix, a diagnostics is in format of
 *
 * ```log
 * // with package
 * cetz:0.2.0@lib.typ:2:9-3:15: error: unexpected type in `+` application
 * // without package
 * main.typ:2:9-3:15: error: unexpected type in `+` application
 * ```
 *
 * If set to long, a diagnostics is in format of {@link DiagnosticMessage}.
 *
 * If set to full, a diagnostics is in format of {@link DiagnosticMessage}, but also with trace messages.
 */
export type DiagnosticsFormat = 'none' | 'unix' | 'full';
export type DiagnosticsData = {
    none: never;
    unix: string;
    full: DiagnosticMessage;
};
interface CompileOptionsCommon {
    /**
     * The path of the main file.
     */
    mainFilePath: string;
    /**
     * Adds a string key-value pair visible through `sys.inputs`
     *
     * Note: pass `{}` to clear `sys.inputs`
     *
     * Note: When passing `undefined`, compiler will use last set `sys.inputs`.
     *
     * Note: This means you should always specify inputs when using compiler for concurrent tasks.
     */
    inputs?: Record<string, string>;
}
interface TransientCompileOptions<F extends CompileFormat = any, Diagnostics extends DiagnosticsFormat = DiagnosticsFormat> extends CompileOptionsCommon {
    /**
     * The format of the artifact.
     * - 'vector': can then load to the renderer to render the document.
     * - 'pdf': for finally exporting pdf to the user.
     * @default 'vector'
     */
    format?: F;
    /**
     * Whether to include diagnostic information in the result.
     * Note: it will be set to 'full' by default in v0.6.0
     * @default 'full'
     */
    diagnostics?: Diagnostics;
}
interface IncrementalCompileOptions<Diagnostics extends DiagnosticsFormat = DiagnosticsFormat> extends CompileOptionsCommon {
    /**
     * The format of the incrementally exported artifact.
     * @default 'vector'
     */
    format?: 'vector';
    /**
     * The incremental server for the document.
     */
    incrementalServer: IncrementalServer;
    /**
     * Whether to include diagnostic information in the result.
     * Note: Before v0.6.0, when diagnostics is not set, the result will be a Uint8Array.
     * After v0.6.0, when diagnostics is not set, the result will be a CompileResult<Uint8Array> without diagnostics.
     * @default 'full'
     */
    diagnostics?: Diagnostics;
}
export interface QueryOptions extends CompileOptionsCommon {
    /**
     * select part of document for query.
     */
    selector: string;
    /**
     * cast result by accessing single field.
     */
    field?: string;
}
/**
 * The options for compiling the document.
 */
export type CompileOptions<Format extends CompileFormat = any, Diagnostics extends DiagnosticsFormat = DiagnosticsFormat> = TransientCompileOptions<Format, Diagnostics> | IncrementalCompileOptions;
export declare class IncrementalServer {
    /**
     * Reset the incremental server to the initial state.
     */
    reset(): void;
    /**
     * Return current result.
     */
    current(): Uint8Array | undefined;
    /**
     * Also attach the debug info to the result.
     */
    setAttachDebugInfo(enable: boolean): void;
}
interface CompileResult<T, D extends DiagnosticsFormat> {
    result?: T;
    diagnostics?: DiagnosticsData[D][];
}
/**
 * The interface of Typst compiler.
 */
export interface TypstCompiler {
    /**
     * Initialize the typst compiler.
     * @param {Partial<InitOptions>} options - The options for initializing the
     * typst compiler.
     */
    init(options?: Partial<InitOptions>): Promise<void>;
    /**
     * Reset the typst compiler to the initial state.
     * Note: without calling this function, the compiler will always keep caches
     * such as:
     * - loaded fonts
     * - source files corresponding to typst modules
     *
     * Note: this function is independent to the {@link resetShadow} function.
     * This is intended to optimize the performance of the compiler.
     */
    reset(): Promise<void>;
    /**
     * Compile an document with the maintained state.
     * @param {CompileOptions} options - The options for compiling the document.
     * @returns {Promise<Uint8Array>} - artifact in vector format.
     * You can then load the artifact to the renderer to render the document.
     */
    compile<D extends DiagnosticsFormat>(options: CompileOptions<'vector', D>): Promise<CompileResult<Uint8Array, D>>;
    compile<D extends DiagnosticsFormat>(options: CompileOptions<'pdf', D>): Promise<CompileResult<Uint8Array, D>>;
    compile<D extends DiagnosticsFormat>(options: CompileOptions<any, D>): Promise<CompileResult<Uint8Array, D>>;
    /**
     * experimental
     * Query the result with document
     */
    query<T>(options: QueryOptions): Promise<T>;
    /**
     * Print the AST of the main file.
     * @param {string} mainFilePath - The path of the main file.
     * @returns {Promise<string>} - an string representation of the AST.
     */
    getAst(mainFilePath: string): Promise<string>;
    /**
     * Add a source file to the compiler.
     * @param {string} path - The path of the source file.
     * @param {string} source - The source code of the source file.
     *
     */
    addSource(path: string, source: string): void;
    /**
     * Add a shadow file to the compiler.
     * @param {string} path - The path to the shadow file.
     * @param {Uint8Array} content - The content of the shadow file.
     *
     */
    mapShadow(path: string, content: Uint8Array): void;
    /**
     * Remove a shadow file from the compiler.
     * @param {string} path - The path to the shadow file.
     */
    unmapShadow(path: string): void;
    /**
     * Reset the shadow files.
     * Note: this function is independent to the {@link reset} function.
     */
    resetShadow(): void;
    /**
     * experimental
     * See Semantic tokens: https://github.com/microsoft/vscode/issues/86415
     */
    getSemanticTokenLegend(): Promise<SemanticTokensLegend>;
    /**
     * experimental
     * See Semantic tokens: https://github.com/microsoft/vscode/issues/86415
     *
     * @param {string} opts.mainFilePath - The path of the main file.
     * @param {string} opts.resultId - The id of the result.
     * @param {string} opts.offsetEncoding - The encoding of the offset.
     *   - 'utf-16': the offset is encoded in utf-16.
     *   - 'utf-8': the offset is encoded in utf-8.
     *   @default 'utf-16'
     * @returns {Promise<SemanticTokens>} - The semantic tokens.
     */
    getSemanticTokens(opts: {
        mainFilePath: string;
        resultId?: string;
        offsetEncoding?: string;
    }): Promise<SemanticTokens>;
    /**
     * experimental
     * Run with an incremental server which holds the state of the document in wasm.
     *
     * @param {function(IncrementalServer): Promise<T>} f - The function to run with the incremental server.
     * @returns {Promise<T>} - The result of the function.
     *
     * Note: the incremental server will be freed after the function is finished.
     */
    withIncrementalServer<T>(f: (s: IncrementalServer) => Promise<T>): Promise<T>;
}
/**
 * create a Typst compiler.
 * @returns {TypstCompiler} - The Typst compiler.
 * @example
 * ```typescript
 * import { createTypstCompiler } from 'typst';
 * const compiler = createTypstCompiler();
 * await compiler.init();
 * compiler.addSource('/main.typ', 'Hello, typst!');
 * await compiler.compile({ mainFilePath: '/main.typ' });
 * ```
 */
export declare function createTypstCompiler(): TypstCompiler;
export declare namespace createTypstCompiler {
    var _impl: typeof TypstCompilerDriver;
}
declare class TypstCompilerDriver {
    compiler: typst.TypstCompiler;
    compilerJs: typeof typst;
    static defaultAssets: "text"[];
    constructor();
    init(options?: Partial<InitOptions>): Promise<void>;
    compile(options: CompileOptions): Promise<any>;
    query(options: QueryOptions): Promise<any>;
    getSemanticTokenLegend(): Promise<SemanticTokensLegend>;
    getSemanticTokens(opts: {
        mainFilePath: string;
        resultId?: string;
        offsetEncoding?: string;
    }): Promise<SemanticTokens>;
    withIncrementalServer<T>(f: (s: IncrementalServer) => Promise<T>): Promise<T>;
    getAst(mainFilePath: string): Promise<string>;
    reset(): Promise<void>;
    addSource(path: string, source: string): void;
    mapShadow(path: string, content: Uint8Array): void;
    unmapShadow(path: string): void;
    resetShadow(): void;
    renderPageToCanvas(): Promise<any>;
}
export {};
//# sourceMappingURL=compiler.d.mts.map