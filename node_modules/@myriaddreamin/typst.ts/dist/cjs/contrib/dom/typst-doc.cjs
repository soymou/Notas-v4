var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  PreviewMode: () => PreviewMode,
  TypstDocumentContext: () => TypstDocumentContext,
  composeDoc: () => composeDoc,
  provideDoc: () => provideDoc
});
module.exports = __toCommonJS(stdin_exports);
var PreviewMode;
(function(PreviewMode2) {
  PreviewMode2[PreviewMode2["Doc"] = 0] = "Doc";
  PreviewMode2[PreviewMode2["Slide"] = 1] = "Slide";
})(PreviewMode || (PreviewMode = {}));
class TypstDocumentContext {
  hookedElem;
  kModule;
  opts;
  modes = [];
  /// Configuration fields
  /// enable partial rendering
  partialRendering = true;
  /// underlying renderer
  renderMode = "svg";
  r = void 0;
  /// preview mode
  previewMode = PreviewMode.Doc;
  /// whether this is a content preview
  isContentPreview = false;
  /// whether this content preview will mix outline titles
  isMixinOutline = false;
  /// background color
  backgroundColor = "black";
  /// default page color (empty string means transparent)
  pageColor = "white";
  /// pixel per pt
  pixelPerPt = 3;
  /// customized way to retrieving dom state
  retrieveDOMState;
  /// State fields
  /// whether svg is updating (in triggerSvgUpdate)
  isRendering = false;
  /// whether kModule is initialized
  moduleInitialized = false;
  /// patch queue for updating data.
  patchQueue = [];
  /// resources to dispose
  disposeList = [];
  /// canvas render ctoken
  canvasRenderCToken;
  /// There are two scales in this class: The real scale is to adjust the size
  /// of `hookedElem` to fit the svg. The virtual scale (scale ratio) is to let
  /// user zoom in/out the svg. For example:
  /// + the default value of virtual scale is 1, which means the svg is totally
  ///   fit in `hookedElem`.
  /// + if user set virtual scale to 0.5, then the svg will be zoomed out to fit
  ///   in half width of `hookedElem`. "real" current scale of `hookedElem`
  currentRealScale = 1;
  /// "virtual" current scale of `hookedElem`
  currentScaleRatio = 1;
  /// timeout for delayed viewport change
  vpTimeout = void 0;
  /// sampled by last render time.
  sampledRenderTime = 0;
  /// page to partial render
  partialRenderPage = 0;
  /// outline data
  outline = void 0;
  /// cursor position in form of [page, x, y]
  cursorPosition = void 0;
  // id: number = rnd++;
  /// Cache fields
  /// cached state of container, default to retrieve state from `this.hookedElem`
  cachedDOMState = {
    width: 0,
    height: 0,
    window: {
      innerWidth: 0,
      innerHeight: 0
    },
    boundingRect: {
      left: 0,
      top: 0,
      right: 0
    }
  };
  constructor(opts) {
    this.hookedElem = opts.hookedElem;
    this.kModule = opts.kModule;
    this.opts = opts || {};
    {
      const { renderMode, previewMode, isContentPreview, retrieveDOMState } = opts || {};
      this.partialRendering = false;
      this.renderMode = renderMode ?? this.renderMode;
      this.previewMode = previewMode ?? this.previewMode;
      this.isContentPreview = isContentPreview || false;
      this.retrieveDOMState = retrieveDOMState ?? (() => {
        return {
          width: this.hookedElem.offsetWidth,
          height: this.hookedElem.offsetHeight,
          window: {
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight
          },
          boundingRect: this.hookedElem.getBoundingClientRect()
        };
      });
      this.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue("--typst-preview-background-color");
    }
    this.hookedElem.classList.add("hide-scrollbar-x");
    this.hookedElem.parentElement?.classList.add("hide-scrollbar-x");
    if (this.previewMode === PreviewMode.Slide) {
      this.hookedElem.classList.add("hide-scrollbar-y");
      this.hookedElem.parentElement?.classList.add("hide-scrollbar-y");
    }
    this.installCtrlWheelHandler();
  }
  reset() {
    this.kModule.reset();
    this.moduleInitialized = false;
  }
  dispose() {
    const disposeList = this.disposeList;
    this.disposeList = [];
    disposeList.forEach((x) => x());
  }
  static derive(ctx, mode) {
    return ["rescale", "rerender", "postRender"].reduce((acc, x) => {
      acc[x] = ctx[`${x}$${mode}`].bind(ctx);
      console.assert(acc[x] !== void 0, `${x}$${mode} is undefined`);
      return acc;
    }, {});
  }
  registerMode(mode) {
    const facade = TypstDocumentContext.derive(this, mode);
    this.modes.push([mode, facade]);
    if (mode === this.renderMode) {
      this.r = facade;
    }
  }
  installCtrlWheelHandler() {
    const factors = [
      0.1,
      0.2,
      0.3,
      0.4,
      0.5,
      0.6,
      0.7,
      0.8,
      0.9,
      1,
      1.1,
      1.3,
      1.5,
      1.7,
      1.9,
      2.1,
      2.4,
      2.7,
      3,
      3.3,
      3.7,
      4.1,
      4.6,
      5.1,
      5.7,
      6.3,
      7,
      7.7,
      8.5,
      9.4,
      10
    ];
    const wheelEventHandler = (event) => {
      if (event.ctrlKey) {
        event.preventDefault();
        this.cachedDOMState = this.retrieveDOMState();
        if (window.onresize !== null) {
          window.onresize = null;
        }
        const prevScaleRatio = this.currentScaleRatio;
        if (event.deltaY < 0) {
          if (this.currentScaleRatio >= factors.at(-1)) {
            return;
          } else {
            this.currentScaleRatio = factors.filter((x) => x > this.currentScaleRatio).at(0);
          }
        } else if (event.deltaY > 0) {
          if (this.currentScaleRatio <= factors.at(0)) {
            return;
          } else {
            this.currentScaleRatio = factors.filter((x) => x < this.currentScaleRatio).at(-1);
          }
        } else {
          return;
        }
        const scrollFactor = this.currentScaleRatio / prevScaleRatio;
        const scrollX = event.pageX * (scrollFactor - 1);
        const scrollY = event.pageY * (scrollFactor - 1);
        if (Math.abs(this.currentScaleRatio - 1) < 1e-5) {
          this.hookedElem.classList.add("hide-scrollbar-x");
          this.hookedElem.parentElement?.classList.add("hide-scrollbar-x");
          if (this.previewMode === PreviewMode.Slide) {
            this.hookedElem.classList.add("hide-scrollbar-y");
            this.hookedElem.parentElement?.classList.add("hide-scrollbar-y");
          }
        } else {
          this.hookedElem.classList.remove("hide-scrollbar-x");
          this.hookedElem.parentElement?.classList.remove("hide-scrollbar-x");
          if (this.previewMode === PreviewMode.Slide) {
            this.hookedElem.classList.remove("hide-scrollbar-y");
            this.hookedElem.parentElement?.classList.remove("hide-scrollbar-y");
          }
        }
        const svg = this.hookedElem.firstElementChild;
        if (svg) {
          const scaleRatio = this.getSvgScaleRatio();
          const dataHeight = Number.parseFloat(svg.getAttribute("data-height"));
          const scaledHeight = Math.ceil(dataHeight * scaleRatio);
          this.hookedElem.style.height = `${scaledHeight * 2}px`;
        }
        window.scrollBy(scrollX, scrollY);
        this.addViewportChange();
        return false;
      }
    };
    if (this.renderMode !== "dom") {
      const vscodeAPI = typeof acquireVsCodeApi !== "undefined";
      if (vscodeAPI) {
        window.addEventListener("wheel", wheelEventHandler, {
          passive: false
        });
        this.disposeList.push(() => {
          window.removeEventListener("wheel", wheelEventHandler);
        });
      } else {
        document.body.addEventListener("wheel", wheelEventHandler, {
          passive: false
        });
        this.disposeList.push(() => {
          document.body.removeEventListener("wheel", wheelEventHandler);
        });
      }
    }
  }
  /// Get current scale from html to svg
  // Note: one should retrieve dom state before rescale
  getSvgScaleRatio() {
    const svg = this.hookedElem.firstElementChild;
    if (!svg) {
      return 0;
    }
    const container = this.cachedDOMState;
    const svgWidth = Number.parseFloat(svg.getAttribute("data-width") || svg.getAttribute("width") || "1");
    const svgHeight = Number.parseFloat(svg.getAttribute("data-height") || svg.getAttribute("height") || "1");
    this.currentRealScale = this.previewMode === PreviewMode.Slide ? Math.min(container.width / svgWidth, container.height / svgHeight) : container.width / svgWidth;
    return this.currentRealScale * this.currentScaleRatio;
  }
  processQueue(svgUpdateEvent) {
    const eventName = svgUpdateEvent[0];
    switch (eventName) {
      case "new":
      case "diff-v1": {
        if (eventName === "new") {
          this.reset();
        }
        this.kModule.manipulateData({
          action: "merge",
          data: svgUpdateEvent[1]
        });
        this.moduleInitialized = true;
        return true;
      }
      case "viewport-change": {
        if (!this.moduleInitialized) {
          console.log("viewport-change before initialization");
          return false;
        }
        return true;
      }
      default:
        console.log("svgUpdateEvent", svgUpdateEvent);
        return false;
    }
  }
  triggerUpdate() {
    if (this.isRendering) {
      return;
    }
    this.isRendering = true;
    const doUpdate = async () => {
      this.cachedDOMState = this.retrieveDOMState();
      if (this.patchQueue.length === 0) {
        this.isRendering = false;
        this.postprocessChanges();
        return;
      }
      try {
        let t0 = performance.now();
        const ctoken = this.canvasRenderCToken;
        if (ctoken) {
          await ctoken.cancel();
          await ctoken.wait();
          this.canvasRenderCToken = void 0;
          console.log("cancel canvas rendering");
        }
        let needRerender = false;
        while (this.patchQueue.length > 0) {
          needRerender = this.processQueue(this.patchQueue.shift()) || needRerender;
        }
        let t1 = performance.now();
        if (needRerender) {
          this.r.rescale();
          await this.r.rerender();
          this.r.rescale();
        }
        let t2 = performance.now();
        const d = (e, x, y) => `${e} ${(y - x).toFixed(2)} ms`;
        this.sampledRenderTime = t2 - t0;
        console.log([d("parse", t0, t1), d("rerender", t1, t2), d("total", t0, t2)].join(", "));
        requestAnimationFrame(doUpdate);
      } catch (e) {
        console.error(e);
        this.isRendering = false;
        this.postprocessChanges();
      }
    };
    requestAnimationFrame(doUpdate);
  }
  postprocessChanges() {
    this.r.postRender();
    if (this.previewMode === PreviewMode.Slide) {
      document.querySelectorAll(".typst-page-number-indicator").forEach((x) => {
        x.textContent = `${this.kModule.retrievePagesInfo().length}`;
      });
    }
  }
  addChangement(change) {
    if (change[0] === "new") {
      this.patchQueue.splice(0, this.patchQueue.length);
    }
    const pushChange = () => {
      this.vpTimeout = void 0;
      this.patchQueue.push(change);
      this.triggerUpdate();
    };
    if (this.vpTimeout !== void 0) {
      clearTimeout(this.vpTimeout);
    }
    if (change[0] === "viewport-change" && this.isRendering) {
      this.vpTimeout = setTimeout(pushChange, this.sampledRenderTime || 100);
    } else {
      pushChange();
    }
  }
  addViewportChange() {
    this.addChangement(["viewport-change", ""]);
  }
}
function provideDoc(Base) {
  return class TypstDocument {
    impl;
    kModule;
    constructor(options) {
      if (options.isContentPreview) {
        options.renderMode = "canvas";
      }
      this.kModule = options.kModule;
      this.impl = new Base(options);
      if (!this.impl.r) {
        throw new Error(`mode is not supported, ${options?.renderMode}`);
      }
      if (options.isContentPreview) {
        this.impl.partialRendering = true;
        this.impl.pixelPerPt = 1;
        this.impl.isMixinOutline = true;
      }
    }
    dispose() {
      this.impl.dispose();
    }
    reset() {
      this.impl.reset();
    }
    addChangement(change) {
      this.impl.addChangement(change);
    }
    addViewportChange() {
      this.impl.addViewportChange();
    }
    setPageColor(color) {
      this.impl.pageColor = color;
      this.addViewportChange();
    }
    setPartialRendering(partialRendering) {
      this.impl.partialRendering = partialRendering;
    }
    setCursor(page, x, y) {
      this.impl.cursorPosition = [page, x, y];
    }
    setPartialPageNumber(page) {
      if (page <= 0 || page > this.kModule.retrievePagesInfo().length) {
        return false;
      }
      this.impl.partialRenderPage = page - 1;
      this.addViewportChange();
      return true;
    }
    getPartialPageNumber() {
      return this.impl.partialRenderPage + 1;
    }
    setOutineData(outline) {
      this.impl.outline = outline;
      this.addViewportChange();
    }
  };
}
function composeDoc(Base, ...mixins) {
  return mixins.reduce((acc, mixin) => mixin(acc), Base);
}
