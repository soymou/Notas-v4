var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  $typst: () => $typst,
  TypstSnippet: () => TypstSnippet
});
module.exports = __toCommonJS(stdin_exports);
var import_options_init = require("../options.init.cjs");
var import_fs = require("../fs/index.cjs");
var import_package = require("../fs/package.cjs");
var import_utils = require("../utils.cjs");
const isNode = (
  // @ts-ignore
  typeof process !== "undefined" && process.versions != null && process.versions.node != null
);
class TypstSnippet {
  /** @internal */
  mainFilePath;
  /** @internal */
  cc;
  /** @internal */
  ex;
  /**
   * Create a new instance of {@link TypstSnippet}.
   * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
   * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
   *
   * @example
   *
   * Passes a global shared compiler instance that get initialized lazily:
   * ```typescript
   * const $typst = new TypstSnippet(() => {
   *  return createGlobalCompiler(createTypstCompiler, initOptions);
   * });
   *
   */
  constructor(options) {
    this.cc = options?.compiler || TypstSnippet.buildLocalCompiler;
    this.ex = options?.renderer || TypstSnippet.buildLocalRenderer;
    this.mainFilePath = "/main.typ";
    this.providers = [];
  }
  /**
   * Set lazy initialized compiler instance for the utility instance.
   * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
   */
  setCompiler(cc) {
    this.cc = cc;
  }
  /**
   * Get an initialized compiler instance from the utility instance.
   */
  async getCompiler() {
    return typeof this.cc === "function" ? this.cc = await this.cc() : this.cc;
  }
  /**
   * Set lazy initialized renderer instance for the utility instance.
   * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
   */
  setRenderer(ex) {
    this.ex = ex;
  }
  /**
   * Get an initialized renderer instance from the utility instance.
   */
  async getRenderer() {
    return typeof this.ex === "function" ? this.ex = await this.ex() : this.ex;
  }
  providers;
  /**
   * add providers for bullding the compiler or renderer component.
   */
  use(...providers) {
    if (!this.providers) {
      throw new Error("already prepare uses for instances");
    }
    this.providers.push(...providers);
  }
  /**
   * todo: add docs
   */
  static preloadFontFromUrl(fontUrl) {
    return TypstSnippet.preloadFonts([fontUrl]);
  }
  /**
   * todo: add docs
   */
  static preloadFontData(fontData) {
    return TypstSnippet.preloadFonts([fontData]);
  }
  /**
   * todo: add docs
   */
  static preloadFonts(userFonts) {
    return {
      key: "access-model",
      forRoles: ["compiler"],
      provides: [(0, import_options_init.preloadRemoteFonts)(userFonts)]
    };
  }
  /**
   * don't load any default font assets.
   * todo: add docs
   */
  static disableDefaultFontAssets() {
    return {
      key: "access-model",
      forRoles: ["compiler"],
      provides: [(0, import_options_init.disableDefaultFontAssets)()]
    };
  }
  /**
   * todo: add docs
   */
  static preloadFontAssets(options) {
    return {
      key: "access-model",
      forRoles: ["compiler"],
      provides: [(0, import_options_init.preloadFontAssets)(options)]
    };
  }
  /**
   * Set accessl model for the compiler instance
   * @example
   *
   * use memory access model
   *
   * ```typescript
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m));
   * ```
   */
  static withAccessModel(accessModel) {
    return {
      key: "access-model",
      forRoles: ["compiler"],
      provides: [(0, import_options_init.withAccessModel)(accessModel)]
    };
  }
  /**
   * Set package registry for the compiler instance
   * @example
   *
   * use a customized package registry
   *
   * ```typescript
   * const n = new NodeFetchPackageRegistry();
   * $typst.use(TypstSnippet.withPackageRegistry(n));
   * ```
   */
  static withPackageRegistry(registry) {
    return {
      key: "package-registry",
      forRoles: ["compiler"],
      provides: [(0, import_options_init.withPackageRegistry)(registry)]
    };
  }
  /**
   * Retrieve an access model to store the data of fetched files.
   * Provide a PackageRegistry instance for the compiler instance.
   *
   * @example
   *
   * use default (memory) access model
   *
   * ```typescript
   * $typst.use(await TypstSnippet.fetchPackageRegistry());
   * ```
   *
   * @example
   *
   * use external access model
   *
   * ```typescript
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
   * ```
   */
  static fetchPackageRegistry(accessModel) {
    const m = accessModel || new import_fs.MemoryAccessModel();
    const provides = [
      ...accessModel ? [] : [(0, import_options_init.withAccessModel)(m)],
      (0, import_options_init.withPackageRegistry)(new import_package.FetchPackageRegistry(m))
    ];
    return {
      key: "package-registry$fetch",
      forRoles: ["compiler"],
      provides
    };
  }
  /**
   * Retrieve a fetcher for fetching package data.
   * Provide a PackageRegistry instance for the compiler instance.
   * @example
   *
   * use a customized fetcher
   *
   * ```typescript
   * import request from 'sync-request-curl';
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
   *   const response = request('GET', this.resolvePath(path), {
   *     insecure: true,
   *   });
   *
   *   if (response.statusCode === 200) {
   *     return response.getBody(undefined);
   *   }
   *   return undefined;
   * }));
   * ```
   */
  static fetchPackageBy(accessModel, fetcher) {
    class HttpPackageRegistry extends import_package.FetchPackageRegistry {
      pullPackageData(path) {
        return fetcher(path, this.resolvePath(path));
      }
    }
    return {
      key: "package-registry$lambda",
      forRoles: ["compiler"],
      provides: [(0, import_options_init.withPackageRegistry)(new HttpPackageRegistry(accessModel))]
    };
  }
  /** @internal */
  ccOptions;
  /**
   * Set compiler init options for initializing global instance {@link $typst}.
   * See {@link InitOptions}.
   */
  setCompilerInitOptions(options) {
    this.requireIsUninitialized("compiler", this.cc);
    this.ccOptions = options;
  }
  /** @internal */
  exOptions;
  /**
   * Set renderer init options for initializing global instance {@link $typst}.
   * See {@link InitOptions}.
   */
  setRendererInitOptions(options) {
    this.requireIsUninitialized("renderer", this.ex);
    this.exOptions = options;
  }
  /**
   * Set shared main file path.
   */
  setMainFilePath(path) {
    this.mainFilePath = path;
  }
  /**
   * Get shared main file path.
   */
  getMainFilePath() {
    return this.mainFilePath;
  }
  removeTmp(opts) {
    if (opts.mainFilePath.startsWith("/tmp/")) {
      return this.unmapShadow(opts.mainFilePath);
    }
    return Promise.resolve();
  }
  /**
   * Add a source file to the compiler.
   * See {@link TypstCompiler#addSource}.
   */
  async addSource(path, content) {
    (await this.getCompiler()).addSource(path, content);
  }
  /**
   * Reset the shadow files.
   * Note: this function is independent to the {@link reset} function.
   * See {@link TypstCompiler#resetShadow}.
   */
  async resetShadow() {
    (await this.getCompiler()).resetShadow();
  }
  /**
   * Add a shadow file to the compiler.
   * See {@link TypstCompiler#mapShadow}.
   */
  async mapShadow(path, content) {
    (await this.getCompiler()).mapShadow(path, content);
  }
  /**
   * Remove a shadow file from the compiler.
   * See {@link TypstCompiler#unmapShadow}.
   */
  async unmapShadow(path) {
    (await this.getCompiler()).unmapShadow(path);
  }
  /**
   * Compile the document to vector (IR) format.
   * See {@link SweetCompileOptions}.
   */
  async vector(o) {
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).compile(opts).then((res) => res.result).finally(() => this.removeTmp(opts));
  }
  /**
   * Compile the document to PDF format.
   * See {@link SweetCompileOptions}.
   */
  async pdf(o) {
    const opts = await this.getCompileOptions(o);
    opts.format = "pdf";
    return (await this.getCompiler()).compile(opts).then((res) => res.result).finally(() => this.removeTmp(opts));
  }
  /**
   * Compile the document to SVG format.
   * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
   */
  async svg(o) {
    return this.transientRender(o, (renderer, renderSession) => renderer.renderSvg({
      ...o,
      renderSession
    }));
  }
  /**
   * Compile the document to canvas operations.
   * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
   */
  async canvas(container, o) {
    return this.transientRender(o, (renderer, renderSession) => renderer.renderToCanvas({
      container,
      ...o,
      renderSession
    }));
  }
  /**
   * Get semantic tokens for the document.
   */
  async query(o) {
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).query({
      ...o,
      ...opts
    }).finally(() => this.removeTmp(opts));
  }
  /**
   * Get token legend for semantic tokens.
   */
  async getSemanticTokenLegend() {
    return (await this.getCompiler()).getSemanticTokenLegend();
  }
  /**
   * Get semantic tokens for the document.
   * See {@link SweetCompileOptions}.
   * See {@link TypstCompiler#getSemanticTokens}.
   */
  async getSemanticTokens(o) {
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).getSemanticTokens({
      mainFilePath: opts.mainFilePath,
      resultId: o.resultId
    }).finally(() => this.removeTmp(opts));
  }
  async getCompileOptions(opts) {
    if (opts === void 0) {
      return { mainFilePath: this.mainFilePath, diagnostics: "none" };
    } else if (typeof opts === "string") {
      throw new Error(`please specify opts as {mainContent: '...'} or {mainFilePath: '...'}`);
    } else if ("mainFilePath" in opts) {
      return { ...opts, diagnostics: "none" };
    } else {
      const destFile = `/tmp/${(0, import_utils.randstr)()}.typ`;
      await this.addSource(destFile, opts.mainContent);
      return { mainFilePath: destFile, inputs: opts.inputs, diagnostics: "none" };
    }
  }
  async getVector(o) {
    if (o && "vectorData" in o) {
      return o.vectorData;
    }
    const opts = await this.getCompileOptions(o);
    return (await this.getCompiler()).compile(opts).then((res) => res.result).finally(() => this.removeTmp(opts));
  }
  async transientRender(opts, f) {
    const rr = await this.getRenderer();
    if (!rr) {
      throw new Error("does not provide renderer instance");
    }
    const data = await this.getVector(opts);
    return await rr.runWithSession(async (session) => {
      rr.manipulateData({
        renderSession: session,
        action: "reset",
        data
      });
      return f(rr, session);
    });
  }
  prepareUseOnce = void 0;
  async prepareUse() {
    if (this.prepareUseOnce) {
      return this.prepareUseOnce;
    }
    return this.prepareUseOnce = this.doPrepareUse();
  }
  async doPrepareUse() {
    if (!this.providers) {
      return;
    }
    const providers = await Promise.all(this.providers.map((p) => typeof p === "function" ? p() : p));
    this.providers = [];
    if ($typst == this && !providers.some((p) => p.key.includes("package-registry") || p.key.includes("access-model"))) {
      if (isNode) {
        const escapeImport = new Function("m", "return import(m)");
        try {
          const m = new import_fs.MemoryAccessModel();
          const { default: request } = await escapeImport("sync-request");
          $typst.use(TypstSnippet.withAccessModel(m), TypstSnippet.fetchPackageBy(m, (_, path) => {
            const response = request("GET", path);
            if (response.statusCode === 200) {
              return response.getBody(void 0);
            }
            return void 0;
          }));
        } catch (e) {
        }
      } else {
        $typst.use(TypstSnippet.fetchPackageRegistry());
      }
    }
    const providers2 = await Promise.all(this.providers.map((p) => typeof p === "function" ? p() : p));
    const ccOptions = this.ccOptions ||= {};
    const ccBeforeBuild = ccOptions.beforeBuild ||= [];
    const exOptions = this.exOptions ||= {};
    const exBeforeBuild = exOptions.beforeBuild ||= [];
    for (const provider of [...providers, ...providers2]) {
      if (provider.forRoles.includes("compiler")) {
        this.requireIsUninitialized("compiler", this.cc);
        ccBeforeBuild.push(...provider.provides);
      }
      if (provider.forRoles.includes("renderer")) {
        this.requireIsUninitialized("renderer", this.ex);
        exBeforeBuild.push(...provider.provides);
      }
    }
    this.providers = void 0;
  }
  requireIsUninitialized(role, c, e) {
    if (c && typeof c !== "function") {
      throw new Error(`${role} has been initialized: ${c}`);
    }
  }
  /** @internal */
  static async buildLocalCompiler() {
    const { createTypstCompiler } = await import(
      // @ts-ignore
      "@myriaddreamin/typst.ts/compiler"
    );
    await this.prepareUse();
    const compiler = createTypstCompiler();
    await compiler.init(this.ccOptions);
    return compiler;
  }
  /** @internal */
  static async buildGlobalCompiler() {
    const { createGlobalCompiler } = await import(
      // @ts-ignore
      "@myriaddreamin/typst.ts/contrib/global-compiler"
    );
    const { createTypstCompiler } = await import(
      // @ts-ignore
      "@myriaddreamin/typst.ts/compiler"
    );
    await this.prepareUse();
    return createGlobalCompiler(createTypstCompiler, this.ccOptions);
  }
  /** @internal */
  static async buildLocalRenderer() {
    const { createTypstRenderer } = await import(
      // @ts-ignore
      "@myriaddreamin/typst.ts/renderer"
    );
    await this.prepareUse();
    const renderer = createTypstRenderer();
    await renderer.init(this.exOptions);
    return renderer;
  }
  /** @internal */
  static async buildGlobalRenderer() {
    const { createGlobalRenderer } = await import(
      // @ts-ignore
      "@myriaddreamin/typst.ts/contrib/global-renderer"
    );
    const { createTypstRenderer } = await import(
      // @ts-ignore
      "@myriaddreamin/typst.ts/renderer"
    );
    await this.prepareUse();
    return createGlobalRenderer(createTypstRenderer, this.exOptions);
  }
}
const $typst = new TypstSnippet({
  compiler: TypstSnippet.buildGlobalCompiler,
  renderer: TypstSnippet.buildGlobalRenderer
});
