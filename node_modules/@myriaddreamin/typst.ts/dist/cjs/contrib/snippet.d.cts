import type { CompileOptions, TypstCompiler } from "../compiler.cjs";
import { type BeforeBuildFn, type InitOptions, LoadRemoteAssetsOptions } from "../options.init.cjs";
import type { TypstRenderer } from "../renderer.cjs";
import type { RenderToCanvasOptions, RenderSvgOptions } from "../options.render.cjs";
import { type WritableAccessModel } from "../fs/index.cjs";
import { PackageRegistry, PackageSpec, SemanticTokens, SemanticTokensLegend } from "../internal.types.cjs";
/**
 * Some function that returns a promise of value or just that value.
 */
type PromiseJust<T> = (() => Promise<T>) | T;
interface CompileOptionsCommon {
    /**
     * Adds a string key-value pair visible through `sys.inputs`
     *
     * Note: pass `{}` to clear `sys.inputs`
     *
     * Note: When passing `undefined`, compiler will use last set `sys.inputs`.
     *
     * Note: This means you should always specify inputs when using compiler for concurrent tasks.
     */
    inputs?: Record<string, string>;
}
/**
 * The sweet options for compiling and rendering the document.
 */
export type SweetCompileOptions = ({
    /**
     * The path of the main file.
     */
    mainFilePath: string;
} | {
    /**
     * The source content of the main file.
     */
    mainContent: string;
}) & CompileOptionsCommon;
/**
 * The sweet options for compiling and rendering the document.
 */
export type SweetRenderOptions = SweetCompileOptions | {
    /**
     * The artifact data in vector format.
     */
    vectorData: Uint8Array;
};
type Role = 'compiler' | 'renderer';
/**
 * The sweet snippet provider for bullding the compiler or renderer component.
 * See {@link TypstSnippet#use} for more details.
 */
export interface TypstSnippetProvider {
    key: string;
    forRoles: Role[];
    provides: BeforeBuildFn[];
}
/**
 * Convenient util class for compiling documents, which is a wrapper of the
 * {@link TypstCompiler} and {@link TypstRenderer}.
 *
 * Note: the interface of this class is less stable than {@link TypstCompiler}
 * and {@link TypstRenderer}.
 *
 * @example
 * Use the *global shared* compiler instance:
 *
 * ```typescript
 * import { $typst } from '@myriaddreamin/typst.ts';
 * ```
 *
 * Note: if you want to compile multiple documents, you should create a new
 * instance for each compilation work or maintain the shared state on the
 * utility instance `$typst` carefully, because the compilation process will
 * change the state of that.
 *
 * @example
 * Create an instance of utility:
 *
 * ```typescript
 * const $typst = new TypstSnippet({
 *   // optional renderer instance
 *   renderer: enableRendering ?? (() => {
 *     return createGlobalRenderer(createTypstRenderer,
 *       undefined, initOptions);
 *   }),
 *   compiler() => {
 *     return createGlobalCompiler(createTypstCompiler,
 *       initOptions);
 *   }
 * });
 * ```
 */
export declare class TypstSnippet {
    /**
     * Create a new instance of {@link TypstSnippet}.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     *
     * @example
     *
     * Passes a global shared compiler instance that get initialized lazily:
     * ```typescript
     * const $typst = new TypstSnippet(() => {
     *  return createGlobalCompiler(createTypstCompiler, initOptions);
     * });
     *
     */
    constructor(options?: {
        compiler?: PromiseJust<TypstCompiler>;
        renderer?: PromiseJust<TypstRenderer>;
    });
    /**
     * Set lazy initialized compiler instance for the utility instance.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     */
    setCompiler(cc: PromiseJust<TypstCompiler>): void;
    /**
     * Get an initialized compiler instance from the utility instance.
     */
    getCompiler(): Promise<TypstCompiler>;
    /**
     * Set lazy initialized renderer instance for the utility instance.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     */
    setRenderer(ex: PromiseJust<TypstRenderer>): void;
    /**
     * Get an initialized renderer instance from the utility instance.
     */
    getRenderer(): Promise<TypstRenderer | undefined>;
    private providers?;
    /**
     * add providers for bullding the compiler or renderer component.
     */
    use(...providers: PromiseJust<TypstSnippetProvider>[]): void;
    /**
     * todo: add docs
     */
    static preloadFontFromUrl(fontUrl: string): TypstSnippetProvider;
    /**
     * todo: add docs
     */
    static preloadFontData(fontData: Uint8Array): TypstSnippetProvider;
    /**
     * todo: add docs
     */
    static preloadFonts(userFonts: (string | Uint8Array)[]): TypstSnippetProvider;
    /**
     * don't load any default font assets.
     * todo: add docs
     */
    static disableDefaultFontAssets(): TypstSnippetProvider;
    /**
     * todo: add docs
     */
    static preloadFontAssets(options?: LoadRemoteAssetsOptions): TypstSnippetProvider;
    /**
     * Set accessl model for the compiler instance
     * @example
     *
     * use memory access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m));
     * ```
     */
    static withAccessModel(accessModel: WritableAccessModel): TypstSnippetProvider;
    /**
     * Set package registry for the compiler instance
     * @example
     *
     * use a customized package registry
     *
     * ```typescript
     * const n = new NodeFetchPackageRegistry();
     * $typst.use(TypstSnippet.withPackageRegistry(n));
     * ```
     */
    static withPackageRegistry(registry: PackageRegistry): TypstSnippetProvider;
    /**
     * Retrieve an access model to store the data of fetched files.
     * Provide a PackageRegistry instance for the compiler instance.
     *
     * @example
     *
     * use default (memory) access model
     *
     * ```typescript
     * $typst.use(await TypstSnippet.fetchPackageRegistry());
     * ```
     *
     * @example
     *
     * use external access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
     * ```
     */
    static fetchPackageRegistry(accessModel?: WritableAccessModel): TypstSnippetProvider;
    /**
     * Retrieve a fetcher for fetching package data.
     * Provide a PackageRegistry instance for the compiler instance.
     * @example
     *
     * use a customized fetcher
     *
     * ```typescript
     * import request from 'sync-request-curl';
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
     *   const response = request('GET', this.resolvePath(path), {
     *     insecure: true,
     *   });
     *
     *   if (response.statusCode === 200) {
     *     return response.getBody(undefined);
     *   }
     *   return undefined;
     * }));
     * ```
     */
    static fetchPackageBy(accessModel: WritableAccessModel, fetcher: (path: PackageSpec, defaultHttpUrl: string) => Uint8Array | undefined): TypstSnippetProvider;
    /**
     * Set compiler init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setCompilerInitOptions(options: Partial<InitOptions>): void;
    /**
     * Set renderer init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setRendererInitOptions(options: Partial<InitOptions>): void;
    /**
     * Set shared main file path.
     */
    setMainFilePath(path: string): void;
    /**
     * Get shared main file path.
     */
    getMainFilePath(): string;
    removeTmp(opts: CompileOptions): Promise<void>;
    /**
     * Add a source file to the compiler.
     * See {@link TypstCompiler#addSource}.
     */
    addSource(path: string, content: string): Promise<void>;
    /**
     * Reset the shadow files.
     * Note: this function is independent to the {@link reset} function.
     * See {@link TypstCompiler#resetShadow}.
     */
    resetShadow(): Promise<void>;
    /**
     * Add a shadow file to the compiler.
     * See {@link TypstCompiler#mapShadow}.
     */
    mapShadow(path: string, content: Uint8Array): Promise<void>;
    /**
     * Remove a shadow file from the compiler.
     * See {@link TypstCompiler#unmapShadow}.
     */
    unmapShadow(path: string): Promise<void>;
    /**
     * Compile the document to vector (IR) format.
     * See {@link SweetCompileOptions}.
     */
    vector(o?: SweetCompileOptions): Promise<Uint8Array<ArrayBufferLike> | undefined>;
    /**
     * Compile the document to PDF format.
     * See {@link SweetCompileOptions}.
     */
    pdf(o?: SweetCompileOptions): Promise<Uint8Array<ArrayBufferLike> | undefined>;
    /**
     * Compile the document to SVG format.
     * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
     */
    svg(o?: SweetRenderOptions & RenderSvgOptions): Promise<string>;
    /**
     * Compile the document to canvas operations.
     * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
     */
    canvas(container: HTMLElement, o?: SweetRenderOptions & Omit<RenderToCanvasOptions, 'container'>): Promise<void>;
    /**
     * Get semantic tokens for the document.
     */
    query<T>(o: SweetCompileOptions & {
        selector: string;
        field?: string;
    }): Promise<T>;
    /**
     * Get token legend for semantic tokens.
     */
    getSemanticTokenLegend(): Promise<SemanticTokensLegend>;
    /**
     * Get semantic tokens for the document.
     * See {@link SweetCompileOptions}.
     * See {@link TypstCompiler#getSemanticTokens}.
     */
    getSemanticTokens(o: SweetCompileOptions & {
        resultId?: string;
    }): Promise<SemanticTokens>;
    private getCompileOptions;
    private getVector;
    private transientRender;
    prepareUseOnce: Promise<void> | undefined;
    private prepareUse;
    private doPrepareUse;
    private requireIsUninitialized;
}
/**
 * The lazy initialized global shared instance of {@link TypstSnippet}. See
 * {@link TypstSnippet} for more details.
 */
export declare const $typst: TypstSnippet;
export {};
//# sourceMappingURL=snippet.d.mts.map