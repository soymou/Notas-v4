var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  buildComponent: () => buildComponent,
  globalFontPromises: () => globalFontPromises
});
module.exports = __toCommonJS(stdin_exports);
var idb = __toESM(require("idb"));
const globalFontPromises = [];
async function addPartialFonts({ builder, hooks }) {
  const t = performance.now();
  if ("queryLocalFonts" in window) {
    const fonts = await window.queryLocalFonts();
    console.log("local fonts count:", fonts.length);
    const db = await idb.openDB("typst-ts-store", 1, {
      upgrade(db2) {
        db2.createObjectStore("font-information", {
          keyPath: "postscriptName"
        });
      }
    });
    const information = await Promise.all(fonts.map(async (font) => {
      const postscriptName = font.postscriptName;
      return (await db.get("font-information", postscriptName))?.info;
    }));
    const get_font_info = builder.handler_for_font_info();
    await builder.add_web_fonts(fonts.map((font, font_idx) => {
      let gettingBuffer = false;
      let readyBuffer = void 0;
      const fullName = font.fullName;
      const postscriptName = font.postscriptName;
      const prev = information[font_idx];
      if (prev) {
        console.log("prev", postscriptName, prev);
      }
      return {
        family: font.family,
        style: font.style,
        fullName,
        postscriptName,
        ref: font,
        info: information[font_idx],
        blob: (idx) => {
          console.log(this, font, idx);
          if (readyBuffer) {
            return readyBuffer;
          }
          if (gettingBuffer) {
            return;
          }
          gettingBuffer = true;
          globalFontPromises.push((async () => {
            const blob = await font.blob();
            const buffer = await blob.arrayBuffer();
            readyBuffer = buffer;
            const realFontInfo = get_font_info(new Uint8Array(buffer));
            console.log(realFontInfo);
            db.put("font-information", {
              fullName,
              postscriptName,
              info: realFontInfo
            });
            return { buffer, idx };
          })());
        }
      };
    }));
  }
  const t2 = performance.now();
  console.log("addPartialFonts time used:", t2 - t);
}
class ComponentBuilder {
  loadedFonts = /* @__PURE__ */ new Set();
  fetcher = fetch;
  setFetcher(fetcher) {
    this.fetcher = fetcher;
  }
  async loadFonts(builder, fonts) {
    const escapeImport = new Function("m", "return import(m)");
    const fetcher = this.fetcher ||= await async function() {
      const { fetchBuilder, FileSystemCache } = await escapeImport("node-fetch-cache");
      const cache = new FileSystemCache({
        /// By default, we don't have a complicated cache policy.
        cacheDirectory: ".cache/typst/fonts"
      });
      const cachedFetcher = fetchBuilder.withCache(cache);
      return function(input, init) {
        const timeout = setTimeout(() => {
          console.warn("font fetching is stucking:", input);
        }, 15e3);
        return cachedFetcher(input, init).finally(() => {
          clearTimeout(timeout);
        });
      };
    }();
    const fontsToLoad = fonts.filter((font) => {
      if (font instanceof Uint8Array) {
        return true;
      }
      if (this.loadedFonts.has(font)) {
        return false;
      }
      this.loadedFonts.add(font);
      return true;
    });
    const fontLists = await Promise.all(fontsToLoad.map(async (font) => {
      if (font instanceof Uint8Array) {
        await builder.add_raw_font(font);
        return;
      }
      return new Uint8Array(await (await fetcher(font)).arrayBuffer());
    }));
    for (const font of fontLists) {
      if (!font) {
        continue;
      }
      await builder.add_raw_font(font);
    }
  }
  async build(options, builder, hooks) {
    const buildCtx = { ref: this, builder, hooks };
    for (const fn of options?.beforeBuild ?? []) {
      await fn(void 0, buildCtx);
    }
    if (hooks.latelyBuild) {
      hooks.latelyBuild(buildCtx);
    }
    const component = await builder.build();
    return component;
  }
}
async function buildComponent(options, gModule, Builder, hooks) {
  await gModule.init(options?.getModule?.());
  return await new ComponentBuilder().build(options, new Builder(), hooks);
}
