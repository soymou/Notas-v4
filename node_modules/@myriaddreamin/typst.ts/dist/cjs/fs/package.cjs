var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  FetchPackageRegistry: () => FetchPackageRegistry
});
module.exports = __toCommonJS(stdin_exports);
class FetchPackageRegistry {
  am;
  cache = /* @__PURE__ */ new Map();
  constructor(am) {
    this.am = am;
  }
  resolvePath(path) {
    return `https://packages.typst.org/preview/${path.name}-${path.version}.tar.gz`;
  }
  pullPackageData(path) {
    const request = new XMLHttpRequest();
    request.overrideMimeType("text/plain; charset=x-user-defined");
    request.open("GET", this.resolvePath(path), false);
    request.send(null);
    if (request.status === 200 && (request.response instanceof String || typeof request.response === "string")) {
      return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
    }
    return void 0;
  }
  resolve(spec, context) {
    if (spec.namespace !== "preview") {
      return void 0;
    }
    const path = this.resolvePath(spec);
    if (this.cache.has(path)) {
      return this.cache.get(path)();
    }
    const data = this.pullPackageData(spec);
    if (!data) {
      return void 0;
    }
    const previewDir = `/@memory/fetch/packages/preview/${spec.namespace}/${spec.name}/${spec.version}`;
    const entries = [];
    context.untar(data, (path2, data2, mtime) => {
      entries.push([previewDir + "/" + path2, data2, new Date(mtime)]);
    });
    const cacheClosure = () => {
      for (const [path2, data2, mtime] of entries) {
        this.am.insertFile(path2, data2, mtime);
      }
      return previewDir;
    };
    this.cache.set(path, cacheClosure);
    return cacheClosure();
  }
}
