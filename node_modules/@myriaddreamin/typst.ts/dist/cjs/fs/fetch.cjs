var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  FetchAccessModel: () => FetchAccessModel
});
module.exports = __toCommonJS(stdin_exports);
class FetchAccessModel {
  root;
  fullyCached;
  mTimes = /* @__PURE__ */ new Map();
  mRealPaths = /* @__PURE__ */ new Map();
  mData = /* @__PURE__ */ new Map();
  constructor(root, options) {
    this.root = root;
    if (root.endsWith("/")) {
      this.root = this.root.slice(0, this.root.length - 1);
    }
    if (options?.polyfillHeadRequest) {
    }
    this.fullyCached = !!options?.fullyCached;
  }
  reset() {
    this.mTimes.clear();
    this.mRealPaths.clear();
    this.mData.clear();
  }
  resolvePath(path) {
    return this.root + path;
  }
  insertFile(path, data, mtime) {
    this.mTimes.set(path, mtime);
    this.mData.set(path, data);
  }
  removeFile(path) {
    this.mTimes.delete(path);
    this.mData.delete(path);
  }
  async getPreloadScript() {
    const snapshot = [];
    snapshot.push("((async () => {");
    snapshot.push(`const snapshot = {  root: '', mTimes: new Map(),  mRealPaths: new Map(),  mData: [],};`);
    snapshot.push(`const runFetch = async (path) => {`);
    snapshot.push(`  const res = await fetch(snapshot.root + path);`);
    snapshot.push(`  const buffer = await res.arrayBuffer();`);
    snapshot.push(`  return [path, new Uint8Array(buffer)];`);
    snapshot.push(`};`);
    snapshot.push(`snapshot.root = ${JSON.stringify(this.root)};`);
    snapshot.push(`snapshot.mTimes = new Map([${[...this.mTimes.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${v?.getTime() || "undefined"}]`).join(", ")}]);`);
    snapshot.push(`snapshot.mRealPaths = new Map([${[...this.mRealPaths.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${JSON.stringify(v)}]`).join(", ")}]);`);
    const dataEntries = await Promise.all([...this.mData.entries()].map(async ([k, v]) => {
      k = JSON.stringify(k);
      return v ? `runFetch(${k})` : `Promise.resolve([${k}, undefined])`;
    }));
    snapshot.push(`snapshot.mData = await Promise.all([${dataEntries.join(", ")}]);`);
    snapshot.push(`return snapshot;`);
    snapshot.push("})())");
    return snapshot.join("\n");
  }
  getLastModified(path) {
    const request = new XMLHttpRequest();
    request.open("HEAD", path, false);
    request.send(null);
    if (request.status === 200) {
      return request.getResponseHeader("Last-Modified");
    }
    return null;
  }
  getMTimeInternal(path) {
    const lastModified = this.getLastModified(this.resolvePath(path));
    if (lastModified) {
      return new Date(lastModified);
    }
    return void 0;
  }
  getMTime(path) {
    if (path.startsWith("/@memory/")) {
      if (this.mTimes.has(path)) {
        return this.mTimes.get(path);
      }
      return void 0;
    }
    if (!this.fullyCached) {
      return this.getMTimeInternal(path);
    }
    if (this.mTimes.has(path)) {
      return this.mTimes.get(path);
    }
    const mTime = this.getMTimeInternal(path);
    this.mTimes.set(path, mTime);
    return mTime;
  }
  // todo: isFile
  isFile() {
    return true;
  }
  // todo: getRealPath
  getRealPath(path) {
    return path;
  }
  readAllInternal(path) {
    const request = new XMLHttpRequest();
    request.overrideMimeType("text/plain; charset=x-user-defined");
    request.open("GET", this.resolvePath(path), false);
    request.send(null);
    if (request.status === 200 && (request.response instanceof String || typeof request.response === "string")) {
      return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
    }
    return void 0;
  }
  readAll(path) {
    if (path.startsWith("/@memory/")) {
      if (this.mData.has(path)) {
        return this.mData.get(path);
      }
      return void 0;
    }
    if (!this.fullyCached) {
      return this.readAllInternal(path);
    }
    if (this.mData.has(path)) {
      return this.mData.get(path);
    }
    const data = this.readAllInternal(path);
    this.mData.set(path, data);
    return data;
  }
}
