var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  _resolveAssets: () => _resolveAssets,
  disableDefaultFontAssets: () => disableDefaultFontAssets,
  preloadFontAssets: () => preloadFontAssets,
  preloadRemoteFonts: () => preloadRemoteFonts,
  preloadSystemFonts: () => preloadSystemFonts,
  withAccessModel: () => withAccessModel,
  withPackageRegistry: () => withPackageRegistry
});
module.exports = __toCommonJS(stdin_exports);
const BeforeBuildSymbol = Symbol("beforeBuild");
const _textFonts = [
  "DejaVuSansMono-Bold.ttf",
  "DejaVuSansMono-BoldOblique.ttf",
  "DejaVuSansMono-Oblique.ttf",
  "DejaVuSansMono.ttf",
  "LibertinusSerif-Bold.otf",
  "LibertinusSerif-BoldItalic.otf",
  "LibertinusSerif-Italic.otf",
  "LibertinusSerif-Regular.otf",
  "LibertinusSerif-Semibold.otf",
  "LibertinusSerif-SemiboldItalic.otf",
  "NewCM10-Bold.otf",
  "NewCM10-BoldItalic.otf",
  "NewCM10-Italic.otf",
  "NewCM10-Regular.otf",
  "NewCMMath-Bold.otf",
  "NewCMMath-Book.otf",
  "NewCMMath-Regular.otf"
];
const _cjkFonts = [
  "InriaSerif-Bold.ttf",
  "InriaSerif-BoldItalic.ttf",
  "InriaSerif-Italic.ttf",
  "InriaSerif-Regular.ttf",
  "Roboto-Regular.ttf",
  "NotoSerifCJKsc-Regular.otf"
];
const _emojiFonts = ["TwitterColorEmoji.ttf", "NotoColorEmoji-Regular-COLR.subset.ttf"];
function disableDefaultFontAssets() {
  return preloadRemoteFonts([], { assets: false });
}
function preloadFontAssets(options) {
  return preloadRemoteFonts([], options);
}
function _resolveAssets(options) {
  const fonts = [];
  if (options && options?.assets !== false && options?.assets?.length && options?.assets?.length > 0) {
    let defaultPrefix = {
      text: "https://cdn.jsdelivr.net/gh/typst/typst-assets@v0.13.1/files/fonts/",
      _: "https://cdn.jsdelivr.net/gh/typst/typst-dev-assets@v0.13.1/files/fonts/"
    };
    let assetUrlPrefix = options.assetUrlPrefix ?? defaultPrefix;
    if (typeof assetUrlPrefix === "string") {
      assetUrlPrefix = { _: assetUrlPrefix };
    } else {
      assetUrlPrefix = { ...defaultPrefix, ...assetUrlPrefix };
    }
    for (const key of Object.keys(assetUrlPrefix)) {
      const u = assetUrlPrefix[key];
      if (u[u.length - 1] !== "/") {
        assetUrlPrefix[key] = u + "/";
      }
    }
    const prefix = (asset, f) => f.map((font) => (assetUrlPrefix[asset] || assetUrlPrefix["_"]) + font);
    for (const asset of options.assets) {
      switch (asset) {
        case "text":
          fonts.push(...prefix(asset, _textFonts));
          break;
        case "cjk":
          fonts.push(...prefix(asset, _cjkFonts));
          break;
        case "emoji":
          fonts.push(...prefix(asset, _emojiFonts));
          break;
      }
    }
  }
  return fonts;
}
function preloadRemoteFonts(userFonts, options) {
  const assetFonts = _resolveAssets(options);
  const loader = async (_, { ref, builder }) => {
    if (options?.fetcher) {
      ref.setFetcher(options.fetcher);
    }
    await ref.loadFonts(builder, [...userFonts, ...assetFonts]);
  };
  loader._preloadRemoteFontOptions = options;
  loader._kind = "fontLoader";
  return loader;
}
function preloadSystemFonts({ byFamily }) {
  return async (_, { builder }) => {
    const t = performance.now();
    if ("queryLocalFonts" in window) {
      const fonts = await window.queryLocalFonts();
      byFamily = byFamily ?? [];
      for (const font of fonts) {
        if (!byFamily.includes(font.family)) {
          continue;
        }
        const data = await (await font.blob()).arrayBuffer();
        await builder.add_raw_font(new Uint8Array(data));
      }
    }
    const t2 = performance.now();
    console.log("preload system font time used:", t2 - t);
  };
}
function withPackageRegistry(packageRegistry) {
  return async (_, { builder }) => {
    return new Promise((resolve) => {
      builder.set_package_registry(packageRegistry, function(spec) {
        return packageRegistry.resolve(spec, this);
      });
      resolve();
    });
  };
}
function withAccessModel(accessModel) {
  return async (_, ctx) => {
    if (ctx.alreadySetAccessModel) {
      throw new Error(`already set some assess model before: ${ctx.alreadySetAccessModel.constructor?.name}(${ctx.alreadySetAccessModel})`);
    }
    ctx.alreadySetAccessModel = accessModel;
    return new Promise((resolve) => {
      ctx.builder.set_access_model(accessModel, (path) => {
        const lastModified = accessModel.getMTime(path);
        if (lastModified) {
          return lastModified.getTime();
        }
        return 0;
      }, (path) => {
        return accessModel.isFile(path) || false;
      }, (path) => {
        return accessModel.getRealPath(path) || path;
      }, (path) => {
        return accessModel.readAll(path);
      });
      resolve();
    });
  };
}
