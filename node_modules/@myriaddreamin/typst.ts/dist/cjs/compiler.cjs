var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  IncrementalServer: () => IncrementalServer,
  createTypstCompiler: () => createTypstCompiler
});
module.exports = __toCommonJS(stdin_exports);
var import_init = require("./init.cjs");
var import_internal_types = require("./internal.types.cjs");
var import_options_init = require("./options.init.cjs");
var import_wasm = require("./wasm.cjs");
class IncrementalServer {
  /**
   * @internal
   */
  [import_internal_types.kObject];
  /**
   * @internal
   */
  constructor(s) {
    this[import_internal_types.kObject] = s;
  }
  /**
   * Reset the incremental server to the initial state.
   */
  reset() {
    this[import_internal_types.kObject].reset();
  }
  /**
   * Return current result.
   */
  current() {
    return this[import_internal_types.kObject].current();
  }
  /**
   * Also attach the debug info to the result.
   */
  setAttachDebugInfo(enable) {
    this[import_internal_types.kObject].set_attach_debug_info(enable);
  }
}
const gCompilerModule = new import_wasm.LazyWasmModule(async (bin) => {
  const module2 = await import("@myriaddreamin/typst-ts-web-compiler");
  return await module2.default(bin);
});
function createTypstCompiler() {
  return new TypstCompilerDriver();
}
class TypstCompilerDriver {
  compiler;
  compilerJs;
  static defaultAssets = ["text"];
  constructor() {
  }
  async init(options) {
    this.compilerJs = await import("@myriaddreamin/typst-ts-web-compiler");
    const TypstCompilerBuilder = this.compilerJs.TypstCompilerBuilder;
    const compilerOptions = { ...options || {} };
    const beforeBuild = compilerOptions.beforeBuild ??= [];
    const hasPreloadRemoteFonts = beforeBuild.some((fn) => fn._preloadRemoteFontOptions !== void 0);
    const hasSpecifiedAssets = beforeBuild.some((fn) => fn._preloadRemoteFontOptions?.assets !== void 0);
    const hasDisableAssets = beforeBuild.some((fn) => fn._preloadRemoteFontOptions?.assets === false);
    if (!hasPreloadRemoteFonts || !hasSpecifiedAssets && !hasDisableAssets) {
      beforeBuild.push((0, import_options_init.preloadRemoteFonts)([], { assets: TypstCompilerDriver.defaultAssets }));
    }
    const hasFontLoader = beforeBuild.some((fn) => fn._kind === "fontLoader");
    if (!hasFontLoader) {
      throw new Error("TypstCompiler: no font loader found, please use font loaders, e.g. preloadRemoteFonts or preloadSystemFonts");
    }
    this.compiler = await (0, import_init.buildComponent)(options, gCompilerModule, TypstCompilerBuilder, {});
  }
  compile(options) {
    return new Promise((resolve) => {
      if ("incrementalServer" in options) {
        resolve(this.compiler.incr_compile(options.mainFilePath, convertInputs(options.inputs), options.incrementalServer[import_internal_types.kObject], getDiagnosticsArg(options.diagnostics)));
        return;
      }
      resolve(this.compiler.compile(options.mainFilePath, convertInputs(options.inputs), options.format || "vector", getDiagnosticsArg(options.diagnostics)));
    });
  }
  query(options) {
    return new Promise((resolve) => {
      resolve(JSON.parse(this.compiler.query(options.mainFilePath, convertInputs(options.inputs), options.selector, options.field)));
    });
  }
  getSemanticTokenLegend() {
    return new Promise((resolve) => {
      resolve(this.compiler.get_semantic_token_legend());
    });
  }
  getSemanticTokens(opts) {
    return new Promise((resolve) => {
      this.compiler.reset();
      resolve(this.compiler.get_semantic_tokens(opts.offsetEncoding || "utf-16", opts.mainFilePath, opts.resultId));
    });
  }
  async withIncrementalServer(f) {
    const srv = new IncrementalServer(this.compiler.create_incr_server());
    try {
      return await f(srv);
    } finally {
      srv[import_internal_types.kObject].free();
    }
  }
  async getAst(mainFilePath) {
    return this.compiler.get_ast(mainFilePath);
  }
  async reset() {
    await new Promise((resolve) => {
      this.compiler.reset();
      resolve(void 0);
    });
  }
  addSource(path, source) {
    if (arguments.length > 2) {
      throw new Error("use of addSource(path, source, isMain) is deprecated, please use addSource(path, source) instead");
    }
    this.compiler.add_source(path, source);
  }
  mapShadow(path, content) {
    this.compiler.map_shadow(path, content);
  }
  unmapShadow(path) {
    this.compiler.unmap_shadow(path);
  }
  resetShadow() {
    this.compiler.reset_shadow();
  }
  renderPageToCanvas() {
    throw new Error("Please use the api TypstRenderer.renderToCanvas in v0.4.0");
  }
}
createTypstCompiler._impl = TypstCompilerDriver;
function convertInputs(inputs) {
  return inputs ? Object.entries(inputs) : void 0;
}
function getDiagnosticsArg(diagnostics) {
  switch (diagnostics) {
    case "none":
      return 1;
    case "unix":
      return 2;
    case "full":
    default:
      return 3;
  }
}
