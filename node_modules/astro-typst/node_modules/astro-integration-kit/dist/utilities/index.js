import{AstroError as y}from"astro/errors";var f=e=>t=>t;function c(e){let t=[];if(e){for(let r of e)if(r){if(Array.isArray(r)){t.push(...c(r));continue}r instanceof Promise||t.push(r.name)}}return t}var l=f("astro:config:setup")(({config:e},{plugin:t})=>{if(!t||t instanceof Promise)return!1;let r=new Set(c(e?.vite?.plugins)),o=new Set;if(typeof t=="string"&&o.add(t),typeof t=="object")if(Array.isArray(t)){let n=new Set(c(t));for(let s of n)o.add(s)}else o.add(t.name);return[...o].some(n=>r.has(n))});var u=f("astro:config:setup")((e,{plugin:t,warnDuplicated:r=!0})=>{let{updateConfig:o,logger:n}=e;r&&l(e,{plugin:t})&&n.warn(`The Vite plugin "${t.name}" is already present in your Vite configuration, this plugin may not behave correctly.`),o({vite:{plugins:[t]}})});var I=e=>{let t=1;return`${e.replace(/-(\d+)$/,(r,o)=>(t=Number.parseInt(o)+1,""))}-${t}`},h=e=>`\0${e}`,A=(e,t,r)=>{let o=Array.isArray(t)?t:Object.entries(t).map(([i,a])=>({id:i,content:a,context:void 0})),n={};for(let{id:i,context:a}of o)n[i]??=[],n[i]?.push(...a===void 0?["server","client"]:[a]);for(let[i,a]of Object.entries(n))if(a.length!==[...new Set(a)].length)throw new y(`Virtual import with id "${i}" has been registered several times with conflicting contexts.`);let s=Object.fromEntries(o.map(({id:i})=>{if(!r&&i.startsWith("astro:"))throw new y(`Virtual import name prefix can't be "astro:" (for "${i}") because it's reserved for Astro core.`);return[h(i),i]}));return{name:e,resolveId(i){if(o.find(a=>a.id===i))return h(i)},load(i,a){let g=s[i];if(g){let P=a?.ssr?"server":"client",d=o.find(p=>p.id===g&&(p.context===void 0||p.context===P));if(d)return d.content}}}},w=f("astro:config:setup")((e,{name:t,imports:r,__enableCorePowerDoNotUseOrYouWillBeFired:o=!1})=>{let n=`vite-plugin-${t}`;for(;l(e,{plugin:n});)n=I(n);u(e,{warnDuplicated:!1,plugin:A(n,r,o)})});import{AstroError as x}from"astro/errors";var m=f("astro:config:setup")(({config:e},{name:t,position:r,relativeTo:o})=>{let n=e.integrations.findIndex(i=>i.name===t);if(n===-1)return!1;if(r===void 0)return!0;if(o===void 0)throw new x("Cannot perform a relative integration check without a relative reference.","Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.");let s=e.integrations.findIndex(i=>i.name===o);if(s===-1)throw new x("Cannot check relative position against an absent integration.");return r==="before"?n<s:n>s});var b=f("astro:config:setup")(({command:e,injectRoute:t},r)=>{e==="dev"&&t(r)});import{readdirSync as T,statSync as k}from"fs";import{join as V,relative as H,resolve as U}from"pathe";var v=(e,t=e)=>{let r=T(e),o=[];for(let n of r){let s=V(e,n);if(k(s).isDirectory()){let a=v(s,t);o=o.concat(a)}else{let a=H(t,s);o.push(a)}}return o},$=f("astro:config:setup")(({addWatchFile:e,command:t,updateConfig:r},o)=>{if(t!=="dev")return;let n=v(o).map(s=>U(o,s));for(let s of n)e(s);r({vite:{plugins:[{name:`rollup-aik-watch-directory-${o}`,buildStart(){for(let s of n)this.addWatchFile(s)}}]}})});var j=f("astro:config:setup")((e,{integration:t,ensureUnique:r})=>{let{logger:o,updateConfig:n}=e;if(r&&m(e,{name:t.name})){o.warn(`Integration "${t.name}" has already been added by the user or another integration. Skipping.`);return}n({integrations:[t]})});export{j as addIntegration,w as addVirtualImports,u as addVitePlugin,m as hasIntegration,l as hasVitePlugin,b as injectDevRoute,$ as watchDirectory};
//# sourceMappingURL=index.js.map