// src/dev/hmr-integration.ts
import { z as z2 } from "astro/zod";

// src/core/define-integration.ts
import { AstroError } from "astro/errors";
import { z } from "astro/zod";

// src/internal/error-map.ts
var errorMap = (baseError, ctx) => {
  const baseErrorPath = flattenErrorPath(baseError.path);
  if (baseError.code === "invalid_union") {
    const typeOrLiteralErrByPath = /* @__PURE__ */ new Map();
    for (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {
      if (unionError.code === "invalid_type" || unionError.code === "invalid_literal") {
        const flattenedErrorPath = flattenErrorPath(unionError.path);
        if (typeOrLiteralErrByPath.has(flattenedErrorPath)) {
          typeOrLiteralErrByPath.get(flattenedErrorPath).expected.push(unionError.expected);
        } else {
          typeOrLiteralErrByPath.set(flattenedErrorPath, {
            code: unionError.code,
            received: unionError.received,
            expected: [unionError.expected]
          });
        }
      }
    }
    const messages = [
      prefix(
        baseErrorPath,
        typeOrLiteralErrByPath.size ? "Did not match union:" : "Did not match union."
      )
    ];
    return {
      message: messages.concat(
        [...typeOrLiteralErrByPath.entries()].filter(
          ([, error]) => error.expected.length === baseError.unionErrors.length
        ).map(
          ([key, error]) => key === baseErrorPath ? (
            // Avoid printing the key again if it's a base error
            `> ${getTypeOrLiteralMsg(error)}`
          ) : `> ${prefix(key, getTypeOrLiteralMsg(error))}`
        )
      ).join("\n")
    };
  }
  if (baseError.code === "invalid_literal" || baseError.code === "invalid_type") {
    return {
      message: prefix(
        baseErrorPath,
        getTypeOrLiteralMsg({
          code: baseError.code,
          received: baseError.received,
          expected: [baseError.expected]
        })
      )
    };
  } else if (baseError.message) {
    return { message: prefix(baseErrorPath, baseError.message) };
  } else {
    return { message: prefix(baseErrorPath, ctx.defaultError) };
  }
};
var getTypeOrLiteralMsg = (error) => {
  if (error.received === "undefined") return "Required";
  const expectedDeduped = new Set(error.expected);
  switch (error.code) {
    case "invalid_type":
      return `Expected type \`${unionExpectedVals(
        expectedDeduped
      )}\`, received ${JSON.stringify(error.received)}`;
    case "invalid_literal":
      return `Expected \`${unionExpectedVals(
        expectedDeduped
      )}\`, received ${JSON.stringify(error.received)}`;
  }
};
var prefix = (key, msg) => key.length ? `**${key}**: ${msg}` : msg;
var unionExpectedVals = (expectedVals) => [...expectedVals].map((expectedVal, idx) => {
  if (idx === 0) return JSON.stringify(expectedVal);
  const sep = " | ";
  return `${sep}${JSON.stringify(expectedVal)}`;
}).join("");
var flattenErrorPath = (errorPath) => errorPath.join(".");

// src/core/define-integration.ts
var defineIntegration = ({
  name,
  optionsSchema,
  setup
}) => {
  return (...args) => {
    const parsedOptions = (optionsSchema ?? z.never().optional()).safeParse(
      args[0],
      {
        errorMap
      }
    );
    if (!parsedOptions.success) {
      throw new AstroError(
        `Invalid options passed to "${name}" integration
`,
        parsedOptions.error.issues.map((i) => i.message).join("\n")
      );
    }
    const options = parsedOptions.data;
    const { hooks, ...extra } = setup({ name, options });
    return {
      ...extra,
      hooks,
      name
    };
  };
};

// src/utilities/watch-directory.ts
import { readdirSync, statSync } from "fs";
import { join, relative, resolve } from "pathe";

// src/core/define-utility.ts
var defineUtility = (_hook) => (
  /**
   * The function itself
   * @param {Function} fn;
   */
  (fn) => fn
);

// src/utilities/watch-directory.ts
var getFilesRecursively = (dir, baseDir = dir) => {
  const files = readdirSync(dir);
  let filepaths = [];
  for (const file of files) {
    const filepath = join(dir, file);
    const _stat = statSync(filepath);
    if (_stat.isDirectory()) {
      const subDirectoryFiles = getFilesRecursively(filepath, baseDir);
      filepaths = filepaths.concat(subDirectoryFiles);
    } else {
      const relativePath = relative(baseDir, filepath);
      filepaths.push(relativePath);
    }
  }
  return filepaths;
};
var watchDirectory = defineUtility("astro:config:setup")(
  ({ addWatchFile, command, updateConfig }, directory) => {
    if (command !== "dev") {
      return;
    }
    const paths = getFilesRecursively(directory).map(
      (p) => resolve(directory, p)
    );
    for (const path of paths) {
      addWatchFile(path);
    }
    updateConfig({
      vite: {
        plugins: [
          {
            name: `rollup-aik-watch-directory-${directory}`,
            buildStart() {
              for (const path of paths) {
                this.addWatchFile(path);
              }
            }
          }
        ]
      }
    });
  }
);

// src/dev/hmr-integration.ts
var hmrIntegration = defineIntegration({
  name: "astro-integration-kit/hmr",
  optionsSchema: z2.union([
    z2.object({
      directory: z2.string()
    }),
    z2.object({
      directories: z2.array(z2.string())
    })
  ]),
  setup({ options }) {
    return {
      hooks: {
        "astro:config:setup": (params) => {
          if ("directories" in options) {
            for (const directory of options.directories) {
              watchDirectory(params, directory);
            }
          } else {
            watchDirectory(params, options.directory);
          }
        }
      }
    };
  }
});

// src/dev/import-fresh.ts
import { statSync as statSync2 } from "fs";
import { createRequire } from "module";
import { pathToFileURL } from "url";
async function importFresh(packageName, callerUrl) {
  const isRelativePath = packageName.startsWith("./") || packageName.startsWith("../");
  if (isRelativePath && !callerUrl) {
    throw new Error(
      `importFresh: callerUrl (import.meta.url) is required when importing relative paths like "${packageName}"`
    );
  }
  const require2 = createRequire(callerUrl || import.meta.url);
  const resolvedPath = (() => {
    try {
      return require2.resolve(packageName);
    } catch (error) {
      if (isRelativePath) {
        const extensions = [
          ".js",
          ".mjs",
          ".cjs",
          ".ts",
          ".mts",
          ".cts",
          "/index.js",
          "/index.mjs",
          "/index.cjs",
          "/index.ts",
          "/index.mts",
          "/index.cts"
        ];
        for (const ext of extensions) {
          try {
            return require2.resolve(packageName + ext);
          } catch {
          }
        }
      }
      throw error;
    }
  })();
  const fileStats = statSync2(resolvedPath);
  const newSpecifier = new URL(pathToFileURL(resolvedPath).href);
  newSpecifier.searchParams.set("t", Math.floor(fileStats.mtimeMs).toString());
  return await import(
    /* @vite-ignore */
    newSpecifier.href
  );
}
export {
  hmrIntegration,
  importFresh
};
//# sourceMappingURL=index.js.map