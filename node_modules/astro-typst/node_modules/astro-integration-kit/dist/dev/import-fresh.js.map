{"version":3,"sources":["../../src/dev/import-fresh.ts"],"sourcesContent":["import { statSync } from \"node:fs\";\nimport { createRequire } from \"node:module\";\nimport { pathToFileURL } from \"node:url\";\n\n/**\n * This function resolves the given package name and imports it with a cache-busting\n * query parameter to ensure a fresh import that bypasses Node.js's module cache.\n * This is useful during development when you need to reload modules that may have\n * changed without restarting the process.\n *\n * @template T - The expected type of the imported module's default export or module object.\n * @param packageName - The name or path of the package/module to import\n * @param callerUrl - The import.meta.url of the calling module, required for relative paths\n * @returns A promise that resolves to the imported module with type T.\n *\n * @example\n * ```ts\n * import { importFresh } from \"astro-integration-kit/dev\";\n *\n * // Bare specifiers work without callerUrl\n * const { default : myIntegration } = await importFresh<typeof import(\"my-integration\")>(\"my-integration\");\n *\n * // Relative paths require callerUrl\n * const { default : localIntegration } = await importFresh<typeof import(\"./integration\")>(\"./integration\", import.meta.url);\n *\n * export default defineConfig({\n *   integrations: [myIntegration(), localIntegration()]\n * });\n * ```\n */\nexport async function importFresh<T = any>(\n\tpackageName: string,\n\tcallerUrl?: string,\n): Promise<T> {\n\tconst isRelativePath =\n\t\tpackageName.startsWith(\"./\") || packageName.startsWith(\"../\");\n\n\tif (isRelativePath && !callerUrl) {\n\t\tthrow new Error(\n\t\t\t`importFresh: callerUrl (import.meta.url) is required when importing relative paths like \"${packageName}\"`,\n\t\t);\n\t}\n\n\tconst require = createRequire(callerUrl || import.meta.url);\n\n\tconst resolvedPath = (() => {\n\t\ttry {\n\t\t\treturn require.resolve(packageName);\n\t\t} catch (error) {\n\t\t\t// If the path doesn't resolve, try common extensions for directory/index imports\n\t\t\tif (isRelativePath) {\n\t\t\t\tconst extensions = [\n\t\t\t\t\t\".js\",\n\t\t\t\t\t\".mjs\",\n\t\t\t\t\t\".cjs\",\n\t\t\t\t\t\".ts\",\n\t\t\t\t\t\".mts\",\n\t\t\t\t\t\".cts\",\n\t\t\t\t\t\"/index.js\",\n\t\t\t\t\t\"/index.mjs\",\n\t\t\t\t\t\"/index.cjs\",\n\t\t\t\t\t\"/index.ts\",\n\t\t\t\t\t\"/index.mts\",\n\t\t\t\t\t\"/index.cts\",\n\t\t\t\t];\n\n\t\t\t\tfor (const ext of extensions) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn require.resolve(packageName + ext);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Continue to next extension\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Re-throw original error if no extensions work or not a relative path\n\t\t\tthrow error;\n\t\t}\n\t})();\n\n\tconst fileStats = statSync(resolvedPath);\n\tconst newSpecifier = new URL(pathToFileURL(resolvedPath).href);\n\tnewSpecifier.searchParams.set(\"t\", Math.floor(fileStats.mtimeMs).toString());\n\n\treturn (await import(/* @vite-ignore */ newSpecifier.href)) as T;\n}\n"],"mappings":";AAAA,SAAS,gBAAgB;AACzB,SAAS,qBAAqB;AAC9B,SAAS,qBAAqB;AA4B9B,eAAsB,YACrB,aACA,WACa;AACb,QAAM,iBACL,YAAY,WAAW,IAAI,KAAK,YAAY,WAAW,KAAK;AAE7D,MAAI,kBAAkB,CAAC,WAAW;AACjC,UAAM,IAAI;AAAA,MACT,4FAA4F,WAAW;AAAA,IACxG;AAAA,EACD;AAEA,QAAMA,WAAU,cAAc,aAAa,YAAY,GAAG;AAE1D,QAAM,gBAAgB,MAAM;AAC3B,QAAI;AACH,aAAOA,SAAQ,QAAQ,WAAW;AAAA,IACnC,SAAS,OAAO;AAEf,UAAI,gBAAgB;AACnB,cAAM,aAAa;AAAA,UAClB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAEA,mBAAW,OAAO,YAAY;AAC7B,cAAI;AACH,mBAAOA,SAAQ,QAAQ,cAAc,GAAG;AAAA,UACzC,QAAQ;AAAA,UAER;AAAA,QACD;AAAA,MACD;AAEA,YAAM;AAAA,IACP;AAAA,EACD,GAAG;AAEH,QAAM,YAAY,SAAS,YAAY;AACvC,QAAM,eAAe,IAAI,IAAI,cAAc,YAAY,EAAE,IAAI;AAC7D,eAAa,aAAa,IAAI,KAAK,KAAK,MAAM,UAAU,OAAO,EAAE,SAAS,CAAC;AAE3E,SAAQ,MAAM;AAAA;AAAA,IAA0B,aAAa;AAAA;AACtD;","names":["require"]}