{"version":3,"sources":["../../src/dev/hmr-integration.ts","../../src/core/define-integration.ts","../../src/internal/error-map.ts","../../src/utilities/watch-directory.ts","../../src/core/define-utility.ts"],"sourcesContent":["import { z } from \"astro/zod\";\nimport { defineIntegration } from \"../core/define-integration.js\";\nimport { watchDirectory } from \"../utilities/watch-directory.js\";\n\nexport const hmrIntegration = defineIntegration({\n\tname: \"astro-integration-kit/hmr\",\n\toptionsSchema: z.union([\n\t\tz.object({\n\t\t\tdirectory: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tdirectories: z.array(z.string()),\n\t\t}),\n\t]),\n\tsetup({ options }) {\n\t\treturn {\n\t\t\thooks: {\n\t\t\t\t\"astro:config:setup\": (params) => {\n\t\t\t\t\tif (\"directories\" in options) {\n\t\t\t\t\t\tfor (const directory of options.directories) {\n\t\t\t\t\t\t\twatchDirectory(params, directory);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twatchDirectory(params, options.directory);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n});\n","import type { AstroIntegration } from \"astro\";\nimport { AstroError } from \"astro/errors\";\nimport { z } from \"astro/zod\";\nimport { errorMap } from \"../internal/error-map.js\";\nimport type { ExtendedPrettify } from \"../internal/types.ts\";\nimport type { Hooks } from \"./types.js\";\n\ntype AstroIntegrationSetupFn<Options extends z.ZodTypeAny, TApi> = (params: {\n\tname: string;\n\toptions: z.output<Options>;\n}) => Omit<AstroIntegration, \"name\" | \"hooks\"> &\n\tTApi & {\n\t\t// Enable autocomplete and intellisense for non-core hooks\n\t\thooks: Partial<Hooks>;\n\t};\n\n/**\n * A powerful wrapper around the standard Astro Integrations API. It allows integration authors to handle user options and global logic easily.\n *\n * @param {object} params\n * @param {string} params.name - The name of your integration\n * @param {import(\"astro/zod\").AnyZodObject} params.optionsSchema - An optional zod schema to handle your integration options\n * @param {function} params.setup - This will be called from your `astro:config:setup` call with the user options\n *\n * @see https://astro-integration-kit.netlify.app/core/define-integration/\n *\n * @example\n * ```ts\n * export default defineIntegration({\n * \t\tname: \"my-integration\",\n * \t\tsetup({ options }) {\n * \t\t\tconsole.log(options.foo); // \"bar\"\n * \t\t}\n * })\n * ```\n */\nexport const defineIntegration = <\n\tTApiBase,\n\t// Apply Prettify on a generic type parameter so it goes through\n\t// the type expansion and beta reduction to form a minimal type\n\t// for the emitted declarations on libraries.\n\tTApi extends ExtendedPrettify<Omit<TApiBase, keyof AstroIntegration>>,\n\tTOptionsSchema extends z.ZodTypeAny = z.ZodNever,\n>({\n\tname,\n\toptionsSchema,\n\tsetup,\n}: {\n\tname: string;\n\toptionsSchema?: TOptionsSchema;\n\tsetup: AstroIntegrationSetupFn<TOptionsSchema, TApiBase>;\n}): ((\n\t...args: [z.input<TOptionsSchema>] extends [never]\n\t\t? []\n\t\t: undefined extends z.input<TOptionsSchema>\n\t\t\t? [options?: z.input<TOptionsSchema>]\n\t\t\t: [options: z.input<TOptionsSchema>]\n) => AstroIntegration & TApi) => {\n\treturn (...args): AstroIntegration & TApi => {\n\t\tconst parsedOptions = (optionsSchema ?? z.never().optional()).safeParse(\n\t\t\targs[0],\n\t\t\t{\n\t\t\t\terrorMap,\n\t\t\t},\n\t\t);\n\n\t\tif (!parsedOptions.success) {\n\t\t\tthrow new AstroError(\n\t\t\t\t`Invalid options passed to \"${name}\" integration\\n`,\n\t\t\t\tparsedOptions.error.issues.map((i) => i.message).join(\"\\n\"),\n\t\t\t);\n\t\t}\n\n\t\tconst options = parsedOptions.data as z.output<TOptionsSchema>;\n\n\t\tconst { hooks, ...extra } = setup({ name, options });\n\n\t\treturn {\n\t\t\t...(extra as unknown as TApi),\n\t\t\thooks,\n\t\t\tname,\n\t\t};\n\t};\n};\n","import type { ZodErrorMap } from \"astro/zod\";\n\n// Source: https://github.com/withastro/astro/blob/d278e66ec6ded7a3ad441e6c3c5f9c265217936f/packages/astro/src/content/error-map.ts\n\ntype TypeOrLiteralErrByPathEntry = {\n\tcode: \"invalid_type\" | \"invalid_literal\";\n\treceived: unknown;\n\texpected: Array<unknown>;\n};\n\nexport const errorMap: ZodErrorMap = (baseError, ctx) => {\n\tconst baseErrorPath = flattenErrorPath(baseError.path);\n\tif (baseError.code === \"invalid_union\") {\n\t\t// Optimization: Combine type and literal errors for keys that are common across ALL union types\n\t\t// Ex. a union between `{ key: z.literal('tutorial') }` and `{ key: z.literal('blog') }` will\n\t\t// raise a single error when `key` does not match:\n\t\t// > Did not match union.\n\t\t// > key: Expected `'tutorial' | 'blog'`, received 'foo'\n\t\tconst typeOrLiteralErrByPath = new Map<\n\t\t\tstring,\n\t\t\tTypeOrLiteralErrByPathEntry\n\t\t>();\n\t\tfor (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {\n\t\t\tif (\n\t\t\t\tunionError.code === \"invalid_type\" ||\n\t\t\t\tunionError.code === \"invalid_literal\"\n\t\t\t) {\n\t\t\t\tconst flattenedErrorPath = flattenErrorPath(unionError.path);\n\t\t\t\tif (typeOrLiteralErrByPath.has(flattenedErrorPath)) {\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: This code is copied directly from Astro\n\t\t\t\t\ttypeOrLiteralErrByPath\n\t\t\t\t\t\t.get(flattenedErrorPath)!\n\t\t\t\t\t\t.expected.push(unionError.expected);\n\t\t\t\t} else {\n\t\t\t\t\ttypeOrLiteralErrByPath.set(flattenedErrorPath, {\n\t\t\t\t\t\tcode: unionError.code,\n\t\t\t\t\t\treceived: (unionError as any).received,\n\t\t\t\t\t\texpected: [unionError.expected],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst messages: string[] = [\n\t\t\tprefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\ttypeOrLiteralErrByPath.size\n\t\t\t\t\t? \"Did not match union:\"\n\t\t\t\t\t: \"Did not match union.\",\n\t\t\t),\n\t\t];\n\t\treturn {\n\t\t\tmessage: messages\n\t\t\t\t.concat(\n\t\t\t\t\t[...typeOrLiteralErrByPath.entries()]\n\t\t\t\t\t\t// If type or literal error isn't common to ALL union types,\n\t\t\t\t\t\t// filter it out. Can lead to confusing noise.\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t([, error]) =>\n\t\t\t\t\t\t\t\terror.expected.length === baseError.unionErrors.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map(([key, error]) =>\n\t\t\t\t\t\t\tkey === baseErrorPath\n\t\t\t\t\t\t\t\t? // Avoid printing the key again if it's a base error\n\t\t\t\t\t\t\t\t\t`> ${getTypeOrLiteralMsg(error)}`\n\t\t\t\t\t\t\t\t: `> ${prefix(key, getTypeOrLiteralMsg(error))}`,\n\t\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.join(\"\\n\"),\n\t\t};\n\t}\n\tif (\n\t\tbaseError.code === \"invalid_literal\" ||\n\t\tbaseError.code === \"invalid_type\"\n\t) {\n\t\treturn {\n\t\t\tmessage: prefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\tgetTypeOrLiteralMsg({\n\t\t\t\t\tcode: baseError.code,\n\t\t\t\t\treceived: (baseError as any).received,\n\t\t\t\t\texpected: [baseError.expected],\n\t\t\t\t}),\n\t\t\t),\n\t\t};\n\t\t// biome-ignore lint/style/noUselessElse: This code is copied directly from Astro\n\t} else if (baseError.message) {\n\t\treturn { message: prefix(baseErrorPath, baseError.message) };\n\t\t// biome-ignore lint/style/noUselessElse: This code is copied directly from Astro\n\t} else {\n\t\treturn { message: prefix(baseErrorPath, ctx.defaultError) };\n\t}\n};\n\nconst getTypeOrLiteralMsg = (error: TypeOrLiteralErrByPathEntry): string => {\n\tif (error.received === \"undefined\") return \"Required\";\n\tconst expectedDeduped = new Set(error.expected);\n\tswitch (error.code) {\n\t\tcase \"invalid_type\":\n\t\t\treturn `Expected type \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t\tcase \"invalid_literal\":\n\t\t\treturn `Expected \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t}\n};\n\nconst prefix = (key: string, msg: string) =>\n\tkey.length ? `**${key}**: ${msg}` : msg;\n\nconst unionExpectedVals = (expectedVals: Set<unknown>) =>\n\t[...expectedVals]\n\t\t.map((expectedVal, idx) => {\n\t\t\tif (idx === 0) return JSON.stringify(expectedVal);\n\t\t\tconst sep = \" | \";\n\t\t\treturn `${sep}${JSON.stringify(expectedVal)}`;\n\t\t})\n\t\t.join(\"\");\n\nconst flattenErrorPath = (errorPath: (string | number)[]) =>\n\terrorPath.join(\".\");\n","import { readdirSync, statSync } from \"node:fs\";\nimport { join, relative, resolve } from \"pathe\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\nconst getFilesRecursively = (dir: string, baseDir = dir) => {\n\tconst files = readdirSync(dir);\n\tlet filepaths: Array<string> = [];\n\n\tfor (const file of files) {\n\t\tconst filepath = join(dir, file);\n\t\tconst _stat = statSync(filepath);\n\n\t\tif (_stat.isDirectory()) {\n\t\t\t// Recursively get files from subdirectories\n\t\t\tconst subDirectoryFiles = getFilesRecursively(filepath, baseDir);\n\t\t\tfilepaths = filepaths.concat(subDirectoryFiles);\n\t\t} else {\n\t\t\t// Calculate relative path and add it to the array\n\t\t\tconst relativePath = relative(baseDir, filepath);\n\t\t\tfilepaths.push(relativePath);\n\t\t}\n\t}\n\n\treturn filepaths;\n};\n\n/**\n * In development, will reload the Astro dev server if any files within\n * the directory has changed.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {string} directory\n *\n * @see https://astro-integration-kit.netlify.app/utilities/watch-directory/\n *\n * @example\n * ```ts\n * watchDirectory(params, resolve())\n * ```\n */\nexport const watchDirectory = defineUtility(\"astro:config:setup\")(\n\t({ addWatchFile, command, updateConfig }, directory: string) => {\n\t\tif (command !== \"dev\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst paths = getFilesRecursively(directory).map((p) =>\n\t\t\tresolve(directory, p),\n\t\t);\n\n\t\tfor (const path of paths) {\n\t\t\taddWatchFile(path);\n\t\t}\n\n\t\tupdateConfig({\n\t\t\tvite: {\n\t\t\t\tplugins: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: `rollup-aik-watch-directory-${directory}`,\n\t\t\t\t\t\tbuildStart() {\n\t\t\t\t\t\t\tfor (const path of paths) {\n\t\t\t\t\t\t\t\tthis.addWatchFile(path);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t},\n);\n","import type { HookParameters } from \"astro\";\nimport type { Hooks } from \"./types.js\";\n\n/**\n * A utility to be used on an Astro hook.\n *\n * @see defineUtility\n */\nexport type HookUtility<\n\tTHook extends keyof Hooks,\n\tTArgs extends Array<any>,\n\tTReturn,\n> = (params: HookParameters<THook>, ...args: TArgs) => TReturn;\n\n/**\n * Allows defining a type-safe function requiring all the params of a given hook.\n * It uses currying to make TypeScript happy.\n *\n * @param {string} _hook\n *\n * @see https://astro-integration-kit.netlify.app/core/define-utility/\n *\n * @example\n * ```ts\n * const test = defineUtility(\"astro:config:setup\")((params, foo: boolean) => {\n *  return \"bar\";\n * });\n * ```\n */\nexport const defineUtility =\n\t<THook extends keyof Hooks>(_hook: THook) =>\n\t/**\n\t * The function itself\n\t * @param {Function} fn;\n\t */\n\t<TArgs extends Array<any>, T>(\n\t\tfn: HookUtility<THook, TArgs, T>,\n\t): HookUtility<THook, TArgs, T> =>\n\t\tfn;\n"],"mappings":"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","names":["z","z"]}