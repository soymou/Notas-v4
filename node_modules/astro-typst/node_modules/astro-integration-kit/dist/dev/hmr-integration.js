// src/dev/hmr-integration.ts
import { z as z2 } from "astro/zod";

// src/core/define-integration.ts
import { AstroError } from "astro/errors";
import { z } from "astro/zod";

// src/internal/error-map.ts
var errorMap = (baseError, ctx) => {
  const baseErrorPath = flattenErrorPath(baseError.path);
  if (baseError.code === "invalid_union") {
    const typeOrLiteralErrByPath = /* @__PURE__ */ new Map();
    for (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {
      if (unionError.code === "invalid_type" || unionError.code === "invalid_literal") {
        const flattenedErrorPath = flattenErrorPath(unionError.path);
        if (typeOrLiteralErrByPath.has(flattenedErrorPath)) {
          typeOrLiteralErrByPath.get(flattenedErrorPath).expected.push(unionError.expected);
        } else {
          typeOrLiteralErrByPath.set(flattenedErrorPath, {
            code: unionError.code,
            received: unionError.received,
            expected: [unionError.expected]
          });
        }
      }
    }
    const messages = [
      prefix(
        baseErrorPath,
        typeOrLiteralErrByPath.size ? "Did not match union:" : "Did not match union."
      )
    ];
    return {
      message: messages.concat(
        [...typeOrLiteralErrByPath.entries()].filter(
          ([, error]) => error.expected.length === baseError.unionErrors.length
        ).map(
          ([key, error]) => key === baseErrorPath ? (
            // Avoid printing the key again if it's a base error
            `> ${getTypeOrLiteralMsg(error)}`
          ) : `> ${prefix(key, getTypeOrLiteralMsg(error))}`
        )
      ).join("\n")
    };
  }
  if (baseError.code === "invalid_literal" || baseError.code === "invalid_type") {
    return {
      message: prefix(
        baseErrorPath,
        getTypeOrLiteralMsg({
          code: baseError.code,
          received: baseError.received,
          expected: [baseError.expected]
        })
      )
    };
  } else if (baseError.message) {
    return { message: prefix(baseErrorPath, baseError.message) };
  } else {
    return { message: prefix(baseErrorPath, ctx.defaultError) };
  }
};
var getTypeOrLiteralMsg = (error) => {
  if (error.received === "undefined") return "Required";
  const expectedDeduped = new Set(error.expected);
  switch (error.code) {
    case "invalid_type":
      return `Expected type \`${unionExpectedVals(
        expectedDeduped
      )}\`, received ${JSON.stringify(error.received)}`;
    case "invalid_literal":
      return `Expected \`${unionExpectedVals(
        expectedDeduped
      )}\`, received ${JSON.stringify(error.received)}`;
  }
};
var prefix = (key, msg) => key.length ? `**${key}**: ${msg}` : msg;
var unionExpectedVals = (expectedVals) => [...expectedVals].map((expectedVal, idx) => {
  if (idx === 0) return JSON.stringify(expectedVal);
  const sep = " | ";
  return `${sep}${JSON.stringify(expectedVal)}`;
}).join("");
var flattenErrorPath = (errorPath) => errorPath.join(".");

// src/core/define-integration.ts
var defineIntegration = ({
  name,
  optionsSchema,
  setup
}) => {
  return (...args) => {
    const parsedOptions = (optionsSchema ?? z.never().optional()).safeParse(
      args[0],
      {
        errorMap
      }
    );
    if (!parsedOptions.success) {
      throw new AstroError(
        `Invalid options passed to "${name}" integration
`,
        parsedOptions.error.issues.map((i) => i.message).join("\n")
      );
    }
    const options = parsedOptions.data;
    const { hooks, ...extra } = setup({ name, options });
    return {
      ...extra,
      hooks,
      name
    };
  };
};

// src/utilities/watch-directory.ts
import { readdirSync, statSync } from "fs";
import { join, relative, resolve } from "pathe";

// src/core/define-utility.ts
var defineUtility = (_hook) => (
  /**
   * The function itself
   * @param {Function} fn;
   */
  (fn) => fn
);

// src/utilities/watch-directory.ts
var getFilesRecursively = (dir, baseDir = dir) => {
  const files = readdirSync(dir);
  let filepaths = [];
  for (const file of files) {
    const filepath = join(dir, file);
    const _stat = statSync(filepath);
    if (_stat.isDirectory()) {
      const subDirectoryFiles = getFilesRecursively(filepath, baseDir);
      filepaths = filepaths.concat(subDirectoryFiles);
    } else {
      const relativePath = relative(baseDir, filepath);
      filepaths.push(relativePath);
    }
  }
  return filepaths;
};
var watchDirectory = defineUtility("astro:config:setup")(
  ({ addWatchFile, command, updateConfig }, directory) => {
    if (command !== "dev") {
      return;
    }
    const paths = getFilesRecursively(directory).map(
      (p) => resolve(directory, p)
    );
    for (const path of paths) {
      addWatchFile(path);
    }
    updateConfig({
      vite: {
        plugins: [
          {
            name: `rollup-aik-watch-directory-${directory}`,
            buildStart() {
              for (const path of paths) {
                this.addWatchFile(path);
              }
            }
          }
        ]
      }
    });
  }
);

// src/dev/hmr-integration.ts
var hmrIntegration = defineIntegration({
  name: "astro-integration-kit/hmr",
  optionsSchema: z2.union([
    z2.object({
      directory: z2.string()
    }),
    z2.object({
      directories: z2.array(z2.string())
    })
  ]),
  setup({ options }) {
    return {
      hooks: {
        "astro:config:setup": (params) => {
          if ("directories" in options) {
            for (const directory of options.directories) {
              watchDirectory(params, directory);
            }
          } else {
            watchDirectory(params, options.directory);
          }
        }
      }
    };
  }
});
export {
  hmrIntegration
};
//# sourceMappingURL=hmr-integration.js.map