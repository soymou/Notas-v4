import{fileURLToPath as j}from"url";import{dirname as E,resolve as N}from"pathe";var S=e=>{let t=e;return t.startsWith("file://")&&(t=E(j(t))),{resolve:(...n)=>N(t,...n)}};import{AstroError as R}from"astro/errors";import{z as b}from"astro/zod";var v=(e,t)=>{let n=T(e.path);if(e.code==="invalid_union"){let o=new Map;for(let i of e.unionErrors.flatMap(s=>s.errors))if(i.code==="invalid_type"||i.code==="invalid_literal"){let s=T(i.path);o.has(s)?o.get(s).expected.push(i.expected):o.set(s,{code:i.code,received:i.received,expected:[i.expected]})}return{message:[u(n,o.size?"Did not match union:":"Did not match union.")].concat([...o.entries()].filter(([,i])=>i.expected.length===e.unionErrors.length).map(([i,s])=>i===n?`> ${y(s)}`:`> ${u(i,y(s))}`)).join(`
`)}}return e.code==="invalid_literal"||e.code==="invalid_type"?{message:u(n,y({code:e.code,received:e.received,expected:[e.expected]}))}:e.message?{message:u(n,e.message)}:{message:u(n,t.defaultError)}},y=e=>{if(e.received==="undefined")return"Required";let t=new Set(e.expected);switch(e.code){case"invalid_type":return`Expected type \`${A(t)}\`, received ${JSON.stringify(e.received)}`;case"invalid_literal":return`Expected \`${A(t)}\`, received ${JSON.stringify(e.received)}`}},u=(e,t)=>e.length?`**${e}**: ${t}`:t,A=e=>[...e].map((t,n)=>n===0?JSON.stringify(t):` | ${JSON.stringify(t)}`).join(""),T=e=>e.join(".");var $=({name:e,optionsSchema:t,setup:n})=>(...o)=>{let r=(t??b.never().optional()).safeParse(o[0],{errorMap:v});if(!r.success)throw new R(`Invalid options passed to "${e}" integration
`,r.error.issues.map(p=>p.message).join(`
`));let i=r.data,{hooks:s,...a}=n({name:e,options:i});return{...a,hooks:s,name:e}};var h=e=>e;var V=e=>h({...e,setup:(...t)=>{let n=e.setup(...t);return new Proxy(Object.freeze({}),{has:(o,r)=>typeof r=="string",get:(o,r)=>n(r)})}});var l=e=>t=>t;var U=e=>{let{name:t,plugins:n,hooks:o,...r}=e,i=n.filter((p,d,f)=>f.findLastIndex(c=>c.name===p.name)===d).map(p=>p.setup({name:t})),s=[...Object.keys(o),...i.flatMap(Object.keys)].filter((p,d,f)=>f.indexOf(p)===d);return{hooks:Object.fromEntries(s.map(p=>[p,d=>{let f=i.filter(g=>p in g&&!!g[p]),c={};for(let g of f)Object.assign(c,g[p](d));return o[p]?.({...c,...d})}])),...r}};import{AstroError as H}from"astro/errors";function x(e){let t=[];if(e){for(let n of e)if(n){if(Array.isArray(n)){t.push(...x(n));continue}n instanceof Promise||t.push(n.name)}}return t}var m=l("astro:config:setup")(({config:e},{plugin:t})=>{if(!t||t instanceof Promise)return!1;let n=new Set(x(e?.vite?.plugins)),o=new Set;if(typeof t=="string"&&o.add(t),typeof t=="object")if(Array.isArray(t)){let r=new Set(x(t));for(let i of r)o.add(i)}else o.add(t.name);return[...o].some(r=>n.has(r))});var P=l("astro:config:setup")((e,{plugin:t,warnDuplicated:n=!0})=>{let{updateConfig:o,logger:r}=e;n&&m(e,{plugin:t})&&r.warn(`The Vite plugin "${t.name}" is already present in your Vite configuration, this plugin may not behave correctly.`),o({vite:{plugins:[t]}})});var z=e=>{let t=1;return`${e.replace(/-(\d+)$/,(n,o)=>(t=Number.parseInt(o)+1,""))}-${t}`},I=e=>`\0${e}`,D=(e,t,n)=>{let o=Array.isArray(t)?t:Object.entries(t).map(([s,a])=>({id:s,content:a,context:void 0})),r={};for(let{id:s,context:a}of o)r[s]??=[],r[s]?.push(...a===void 0?["server","client"]:[a]);for(let[s,a]of Object.entries(r))if(a.length!==[...new Set(a)].length)throw new H(`Virtual import with id "${s}" has been registered several times with conflicting contexts.`);let i=Object.fromEntries(o.map(({id:s})=>{if(!n&&s.startsWith("astro:"))throw new H(`Virtual import name prefix can't be "astro:" (for "${s}") because it's reserved for Astro core.`);return[I(s),s]}));return{name:e,resolveId(s){if(o.find(a=>a.id===s))return I(s)},load(s,a){let p=i[s];if(p){let d=a?.ssr?"server":"client",f=o.find(c=>c.id===p&&(c.context===void 0||c.context===d));if(f)return f.content}}}},_=l("astro:config:setup")((e,{name:t,imports:n,__enableCorePowerDoNotUseOrYouWillBeFired:o=!1})=>{let r=`vite-plugin-${t}`;for(;m(e,{plugin:r});)r=z(r);P(e,{warnDuplicated:!1,plugin:D(r,n,o)})});import{AstroError as w}from"astro/errors";var k=l("astro:config:setup")(({config:e},{name:t,position:n,relativeTo:o})=>{let r=e.integrations.findIndex(s=>s.name===t);if(r===-1)return!1;if(n===void 0)return!0;if(o===void 0)throw new w("Cannot perform a relative integration check without a relative reference.","Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.");let i=e.integrations.findIndex(s=>s.name===o);if(i===-1)throw new w("Cannot check relative position against an absent integration.");return n==="before"?r<i:r>i});var M=l("astro:config:setup")(({command:e,injectRoute:t},n)=>{e==="dev"&&t(n)});import{readdirSync as C,statSync as W}from"fs";import{join as B,relative as F,resolve as L}from"pathe";var O=(e,t=e)=>{let n=C(e),o=[];for(let r of n){let i=B(e,r);if(W(i).isDirectory()){let a=O(i,t);o=o.concat(a)}else{let a=F(t,i);o.push(a)}}return o},Z=l("astro:config:setup")(({addWatchFile:e,command:t,updateConfig:n},o)=>{if(t!=="dev")return;let r=O(o).map(i=>L(o,i));for(let i of r)e(i);n({vite:{plugins:[{name:`rollup-aik-watch-directory-${o}`,buildStart(){for(let i of r)this.addWatchFile(i)}}]}})});var J=l("astro:config:setup")((e,{integration:t,ensureUnique:n})=>{let{logger:o,updateConfig:r}=e;if(n&&k(e,{name:t.name})){o.warn(`Integration "${t.name}" has already been added by the user or another integration. Skipping.`);return}r({integrations:[t]})});export{J as addIntegration,_ as addVirtualImports,P as addVitePlugin,S as createResolver,V as defineAllHooksPlugin,$ as defineIntegration,h as definePlugin,l as defineUtility,k as hasIntegration,m as hasVitePlugin,M as injectDevRoute,Z as watchDirectory,U as withPlugins};
//# sourceMappingURL=index.js.map